This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cdsrc.json
.gitignore
AGENTS.md
anforderung.md
app/annotations.cds
app/package.json
app/README.md
app/ui5.yaml
app/webapp/Component.js
app/webapp/css/customStyles.css
app/webapp/ext/ChatSidePanelContent.fragment.xml
app/webapp/i18n/i18n.properties
app/webapp/index.html
app/webapp/main.js
app/webapp/manifest.json
app/webapp/test/flpSandbox.html
app/webapp/test/integration/FirstJourney.js
app/webapp/test/integration/opaTests.qunit.html
app/webapp/test/integration/opaTests.qunit.js
app/webapp/test/integration/pages/StammtischeList.js
app/webapp/test/integration/pages/StammtischeObjectPage.js
app/webapp/test/integration/pages/TeilnehmerObjectPage.js
app/webapp/test/testsuite.qunit.html
app/webapp/test/testsuite.qunit.js
db/data/sap.stammtisch-Praesentatoren.csv
db/data/sap.stammtisch-Stammtische.csv
db/data/sap.stammtisch-Teilnehmer.csv
db/schema.cds
eslint.config.mjs
package.json
srv/lib/mcp-client.js
srv/m365-mcp/graph-client.js
srv/m365-mcp/helpers/logging.js
srv/m365-mcp/index.js
srv/m365-mcp/mcp-jsonschema.js
srv/m365-mcp/mcp-tool-manifest.js
srv/m365-mcp/tools/calendar.js
srv/m365-mcp/tools/index.js
srv/m365-mcp/tools/mail.js
srv/service.cds
srv/service.js
srv/utils/markdown-converter.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AGENTS.md">
# Repository Guidelines

## Project Structure & Module Organization
- `db/` CDS domain models (`schema.cds`) and CSV seed data under `db/data/`.
- `srv/` CAP service layer: `service.cds` + `service.js`, shared MCP client helpers in `srv/lib/`, markdown utilities in `srv/utils/`.
- `app/` SAPUI5 frontend (`webapp/` sources, tests under `webapp/test/`).
- `docs/` project documentation; generated build artifacts stay out of VCS.
- Root `package.json` configures CAP, Postgres, and dev scripts.

## Build, Test, and Development Commands
- Install deps (root): `npm install` (and `cd app && npm install` for UI tooling).
- Run CAP in watch mode with UI: `npm run watch-app` (opens `app/webapp/index.html`).
- Run CAP service only: `npm start` (serves on `http://localhost:9999`).
- Initialize database: `npx cds deploy --to postgres` (configure Postgres first).
- UI5 build: `cd app && npx ui5 build --all` (outputs `dist/`).
- UI tests (browser): `cd app && npx ui5 serve -o test/testsuite.qunit.html`.
- UI tests (headless): `cd app && npx ui5 test --all`.

## Coding Style & Naming Conventions
- Language: Node.js ES Modules (import/export). Use 2‑space indent and semicolons.
- Filenames under `srv/` favour lowercase or kebab‑case (e.g., `markdown-converter.js`).
- CDS: namespaces lower‑case dot notation; entities in PascalCase.
- UI5: components/controllers PascalCase; i18n keys lower.dot.case.
- Linting: ESLint with CAP’s recommended config (`eslint.config.mjs`). Prefer `npx eslint .` if installed.

## Testing Guidelines
- UI: QUnit/OPA tests live in `app/webapp/test/` (e.g., `test/integration/FirstJourney.js`, `pages/*`). Name files `*.qunit.js` for suites.
- Backend: no unit tests yet; add Mocha/Jest under `test/` or `srv/test/` following ESM.
- PRs should keep tests green (`ui5 test`) and include new/updated tests for changed behavior.

## Commit & Pull Request Guidelines
- Commits: concise, imperative. Prefer Conventional Commits: `feat(srv): add callLLM stream handling`.
- PRs: include a clear description, linked issues, steps to validate, and screenshots/GIFs for UI changes. Note DB/schema changes and required migrations.

## Security & Configuration Tips
- Do not commit secrets. Use `.env` for local dev and environment variables to override `cds.requires` (Postgres, destinations, AI services). `.gitignore` already excludes common files.
- Service runs at port `9999` (see `package.json`). Service root: `/service/stammtisch`; action `callLLM` in `srv/service.js` executes the multi‑tool agent.
- Supporting agent helpers live in `srv/lib/` and `srv/utils/`; avoid reintroducing generated artefacts into version control.
</file>

<file path="anforderung.md">
# Anforderungsdokument: Integration des M365 MCP

**Datum:** 24.09.2025
**Version:** 1.0
**Autor:** Gemini AI

## 1. Einleitung & Zielsetzung

Dieses Dokument beschreibt die technischen Anforderungen für die Integration eines Microsoft 365 (M365) Model Context Protocol (MCP) Clients in das bestehende `StammtischAI`-Projekt.

**Ziel:** Der KI-Agent der StammtischAI-Anwendung soll um die Fähigkeit erweitert werden, mit M365-Diensten zu interagieren. Dazu gehören das Lesen und Senden von E-Mails, die Verwaltung von Kalendereinträgen sowie das Lesen von Excel-Dateien, die in OneDrive gespeichert sind.

## 2. Architekturübersicht

Die Integration erfolgt durch die Implementierung eines neuen **in-process MCP-Clients**. Im Gegensatz zu den bestehenden MCP-Clients (PostgreSQL, Brave, etc.), die als separate Prozesse über `stdio` kommunizieren, wird die M365-Logik direkt in den Hauptprozess der CAP-Anwendung eingebettet. Dies vereinfacht die Authentifizierung und das Deployment.

Der M365-Client wird folgende Funktionalitäten kapseln:
*   **Authentifizierung:** Nutzt eine vorhandene `m365 login` CLI-Sitzung für die lokale Entwicklung.
*   **Tool-Definition:** Stellt eine Reihe von vordefinierten Tools (z.B. `mail.latestMessage.get`) zur Verfügung.
*   **API-Kommunikation:** Führt die eigentlichen Aufrufe gegen die Microsoft Graph API aus.

**Besonderheit Excel-Workflow (Hybrid-Ansatz):**
Der Agent wird befähigt, einen mehrstufigen Prozess für die Analyse von Excel-Anhängen durchzuführen:
1.  **Download via M365-Tool:** Der Agent lädt einen E-Mail-Anhang mit einem neuen M365-Tool (`mail.attachment.download`) auf das lokale Dateisystem des Servers herunter.
2.  **Analyse via lokalem Excel-Tool:** Der Agent übergibt den Pfad der heruntergeladenen Datei an den bereits existierenden, leistungsstarken Excel-MCP (`@negokaz/excel-mcp-server`) zur Analyse.

## 3. Detaillierte Umsetzungs-Schritte

### 3.1 Neue Verzeichnisstruktur anlegen

Erstellen Sie im `srv`-Verzeichnis die folgende Ordnerstruktur, um die M365-Logik sauber zu kapseln:

```
StammtischAI/
└── srv/
    ├── m365-mcp/      <-- NEUER ORDNER
    │   ├── helpers/   <-- NEUER ORDNER
    │   └── ... (Dateien folgen in Schritt 3.2)
    ├── lib/
    └── service.js
```

### 3.2 Neue Quelldateien erstellen

Erstellen Sie die folgenden Dateien mit dem angegebenen Inhalt innerhalb des neuen `srv/m365-mcp/` Verzeichnisses.

#### 3.2.1 `srv/m365-mcp/helpers/logging.js`
*   **Zweck:** Enthält eine Hilfsfunktion zum sicheren Konvertieren von Objekten in JSON für das Logging.

```javascript
// srv/m365-mcp/helpers/logging.js

function safeJson(x, max = 4000) {
  try {
    const s = typeof x === 'string' ? x : JSON.stringify(x);
    return s.length > max ? s.slice(0, max) + ' …[truncated]' : s;
  } catch {
    try { return String(x); } catch { return '[unprintable]'; }
  }
}

module.exports = { safeJson };
```

#### 3.2.2 `srv/m365-mcp/mcp-tool-manifest.js`
*   **Zweck:** Definiert die "Speisekarte" der verfügbaren M365-Tools, inklusive ihrer Namen, Beschreibungen und der erwarteten Parameter (Input Schema). Dies ist die zentrale Definitionsdatei.

```javascript
// srv/m365-mcp/mcp-tool-manifest.js
// Gekürzte Version für die Übersichtlichkeit. Die volle Liste der 16 Tools ist im Anhang des PoC.
const manifestVersion = '0.1.0';

function clone(value) {
  return JSON.parse(JSON.stringify(value));
}

const toolDefinitions = [
  {
    name: 'mail.latestMessage.get',
    description: 'Liest deterministisch die neueste Nachricht aus einem Mailordner und liefert Metadaten.',
    inputSchema: {
      type: 'object',
      properties: {
        folderId: { type: 'string', description: 'ID oder bekannter Name des Zielordners, z. B. inbox.', default: 'inbox' },
      }
    },
    metadata: { scopes: ['Mail.Read'] }
  },
  {
    name: 'mail.attachment.download',
    description: 'Lädt einen bestimmten Anhang einer Nachricht und speichert ihn deterministisch im Zielpfad.',
    inputSchema: {
      type: 'object',
      required: ['messageId', 'attachmentId', 'targetPath'],
      properties: {
        messageId: { type: 'string' },
        attachmentId: { type: 'string' },
        targetPath: { type: 'string', description: 'Ablageort für den heruntergeladenen Anhang.' }
      }
    },
    metadata: { scopes: ['Mail.Read'] }
  },
  {
    name: 'calendar.events.list',
    description: 'Listet Kalenderereignisse in einem Zeitraum mit deterministischer Filterung.',
    inputSchema: {
      type: 'object',
      required: ['startDateTime', 'endDateTime'],
      properties: {
        startDateTime: { type: 'string', description: 'IS0-8601 Startzeitpunkt.' },
        endDateTime: { type: 'string', description: 'IS0-8601 Endzeitpunkt.' }
      }
    },
    metadata: { scopes: ['Calendars.Read'] }
  },
  // Fügen Sie hier bei Bedarf weitere Tool-Definitionen aus dem PoC hinzu.
  // z.B. mail.message.replyDraft, calendar.event.createOrUpdate, etc.
];

function createM365ToolManifest() {
  return {
    namespace: 'm365',
    version: manifestVersion,
    tools: toolDefinitions.map((tool) => clone(tool))
  };
}

module.exports = { createM365ToolManifest };
```

#### 3.2.3 `srv/m365-mcp/mcp-m365-tools.js`
*   **Zweck:** Implementiert die serverseitige Logik für jedes im Manifest definierte Tool.

```javascript
// srv/m365-mcp/mcp-m365-tools.js

function assertFunction(fn, message) {
  if (typeof fn !== 'function') throw new Error(message);
}

function createM365ToolHandlers(dependencies = {}) {
  const handlers = {};
  const mailDeps = dependencies.mail || {};
  const calendarDeps = dependencies.calendar || {};

  handlers['mail.latestMessage.get'] = async ({ folderId = 'inbox' } = {}) => {
    assertFunction(mailDeps.getLatestMessage, 'mail.getLatestMessage dependency missing');
    const result = await mailDeps.getLatestMessage({ folderId });
    if (!result) return null;
    const from = result.from?.emailAddress?.address;
    return {
      messageId: result.id,
      subject: result.subject,
      receivedDateTime: result.receivedDateTime,
      from: from,
    };
  };
  
  handlers['mail.attachment.download'] = async ({ messageId, attachmentId, targetPath }) => {
    assertFunction(mailDeps.downloadAttachment, 'mail.downloadAttachment dependency missing');
    const result = await mailDeps.downloadAttachment({ messageId, attachmentId, targetPath });
    return { status: 'saved', filePath: result.filePath };
  };

  handlers['calendar.events.list'] = async ({ startDateTime, endDateTime }) => {
    assertFunction(calendarDeps.listEvents, 'calendar.listEvents dependency missing');
    const result = await calendarDeps.listEvents({ startDateTime, endDateTime });
    return { events: result?.events || [] };
  };

  return handlers;
}

module.exports = { createM365ToolHandlers };
```

#### 3.2.4 `srv/m365-mcp/mcp-m365-defaults.js`
*   **Zweck:** Die Kernlogik für die Authentifizierung (nur CLI-Methode) und die Kommunikation mit der MS Graph API.

```javascript
// srv/m365-mcp/mcp-m365-defaults.js
const { execFile } = require('child_process');
const fs = require('fs/promises');
const path = require('path');

function ensureFetch(fetchImpl) {
  if (typeof fetchImpl === 'function') return fetchImpl;
  if (typeof globalThis.fetch === 'function') return globalThis.fetch.bind(globalThis);
  throw new Error('Eine fetch-Implementierung wird für Microsoft Graph benötigt.');
}

function createCliOnlyTokenManager() {
  let cachedToken = null;

  async function acquireTokenFromCli() {
    if (cachedToken) return cachedToken; // Vereinfachtes Caching
    
    const token = await new Promise((resolve) => {
      execFile('m365', ['util', 'accesstoken', 'get', '--resource', 'https://graph.microsoft.com', '--output', 'text'], (err, stdout) => {
        if (err) return resolve(null);
        resolve(String(stdout || '').trim());
      });
    });

    if (!token) {
      throw new Error('Konnte keinen M365 Access Token über die CLI erhalten. Bitte "m365 login" ausführen.');
    }
    console.log('[M365 MCP] Token via m365 CLI erfolgreich erhalten.');
    cachedToken = token;
    return token;
  }

  return { getToken: acquireTokenFromCli };
}

async function createDefaultM365Dependencies(options = {}) {
  const fetchImpl = ensureFetch(options.fetchImpl);
  const baseUrl = 'https://graph.microsoft.com/v1.0';
  const tokenManager = createCliOnlyTokenManager();

  async function graphFetch(pathname, { method = 'GET', headers = {}, body } = {}) {
    const token = await tokenManager.getToken();
    const url = new URL(pathname, baseUrl);
    const finalHeaders = { Authorization: `Bearer ${token}`, ...headers };
    if (body && typeof body === 'object') {
        finalHeaders['Content-Type'] = 'application/json';
        body = JSON.stringify(body);
    }
    const response = await fetchImpl(url.toString(), { method, headers: finalHeaders, body });
    if (!response.ok) {
        const text = await response.text().catch(() => '');
        throw new Error(`Graph API Fehler: ${response.status} ${text}`);
    }
    if (response.status === 204) return null; // No Content
    return response.json();
  }

  const mail = {
    getLatestMessage: ({ folderId }) => graphFetch(`/me/mailFolders/${folderId}/messages?$top=1&$orderby=receivedDateTime desc`),
    downloadAttachment: async ({ messageId, attachmentId, targetPath }) => {
        const attachment = await graphFetch(`/me/messages/${messageId}/attachments/${attachmentId}`);
        const content = Buffer.from(attachment.contentBytes, 'base64');
        await fs.mkdir(path.dirname(targetPath), { recursive: true });
        await fs.writeFile(targetPath, content);
        return { filePath: targetPath };
    }
  };
  
  const calendar = {
    listEvents: ({ startDateTime, endDateTime }) => graphFetch(`/me/calendarview?startDateTime=${startDateTime}&endDateTime=${endDateTime}`)
  };

  return { mail, calendar };
}

module.exports = { createDefaultM365Dependencies };
```

#### 3.2.5 `srv/m365-mcp/mcp-m365-inprocess.js` & `srv/m365-mcp/mcp-jsonschema.js`
*   **Zweck:** Diese beiden Dateien sind "Boilerplate"-Code, der die Brücke zwischen dem Manifest, den Handlern und dem Client schlägt.

```javascript
// srv/m365-mcp/mcp-m365-inprocess.js
const { createM365ToolManifest } = require('./mcp-tool-manifest');
const { createM365ToolHandlers } = require('./mcp-m365-tools');

function createM365InProcessClient({ dependencies }) {
  const manifest = createM365ToolManifest();
  const handlers = createM365ToolHandlers(dependencies);
  const handlerNames = new Set(Object.keys(handlers));

  async function callTool({ name, arguments: args = {} } = {}) {
    if (!handlerNames.has(name)) throw new Error(`Unbekanntes MCP Tool: ${name}`);
    return handlers[name](args);
  }
  
  return {
    callTool,
    listTools: async () => manifest,
    close: async () => {},
  };
}

module.exports = { createM365InProcessClient };
```

```javascript
// srv/m365-mcp/mcp-jsonschema.js
function jsonSchemaToZod(schema, z) {
  // Diese Funktion konvertiert das JSON-Schema aus dem Manifest in ein Zod-Schema,
  // das von LangChain zur Validierung der Tool-Parameter verwendet wird.
  // Der Code aus dem PoC kann hier 1:1 übernommen werden.
  // ... (Inhalt aus der PoC-Datei hier einfügen)
  if (!schema || typeof schema !== 'object') throw new Error('schema must be an object');
  // ...
  return z.object({}); // Platzhalter, hier den echten Code einfügen
}
module.exports = { jsonSchemaToZod };
```

### 3.3 Abhängigkeiten installieren

Öffnen Sie ein Terminal im Hauptverzeichnis des `StammtischAI`-Projekts und installieren Sie die `zod`-Bibliothek.

```bash
npm install zod
```

### 3.4 Bestehende Dateien anpassen

#### 3.4.1 `srv/lib/mcp-client.js` modifizieren
*   **Änderung:** Fügen Sie die Initialisierung für den neuen in-process M365 Client hinzu.

```javascript
// srv/lib/mcp-client.js (VOLLSTÄNDIGE, AKTUALISIERTE VERSION)

import cds from '@sap/cds';
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import path from 'path';
import { fileURLToPath } from 'url';

// +++ NEU START: Importiere die M365-Client-Logik +++
import { createM365InProcessClient } from '../m365-mcp/mcp-m365-inprocess.js';
import { createDefaultM365Dependencies } from '../m365-mcp/mcp-m365-defaults.js';
// +++ NEU ENDE +++

// ... (bestehende Variablen-Deklarationen)
let m365Client = null; // +++ NEU: M365 Client Variable

// ... (bestehende init-Funktionen für postgres, brave, etc. bleiben unverändert)

// +++ NEU START: Eigene Initialisierungsfunktion für den M365 Client +++
async function initM365InProcessClient() {
  if (m365Client) return m365Client;
  // Nur initialisieren, wenn die Authentifizierungsmethode konfiguriert ist
  if (process.env.M365_AUTH_METHOD !== 'cli') {
      console.log("Skipping M365 client initialization: M365_AUTH_METHOD is not set to 'cli'.");
      return null;
  }
  console.log(`Initializing in-process Microsoft 365 MCP client...`);
  try {
    const dependencies = await createDefaultM365Dependencies();
    m365Client = createM365InProcessClient({ dependencies });
    console.log("✅ Microsoft 365 in-process MCP client initialized successfully.");
    return m365Client;
  } catch (error) {
    console.error("❌ Failed to initialize in-process M365 client:", error.message);
    return null;
  }
}
// +++ NEU ENDE +++

export async function initAllMCPClients() {
  console.log("Initializing all MCP clients...");

  const [pgClient, braveClient, playwrightClient, fsClient, xlsxClient, m365] = await Promise.all([
    initPostgresMCPClient(),
    initBraveSearchMCPClient(),
    initPlaywrightMCPClient(),
    initFilesystemMCPClient(),
    initExcelMCPClient(),
    initM365InProcessClient() // +++ NEU: Neuer Client
  ]);

  return {
    postgres: pgClient,
    braveSearch: braveClient,
    playwright: playwrightClient,
    filesystem: fsClient,
    excel: xlsxClient,
    m365: m365, // +++ NEU: Neuer Client im Rückgabeobjekt
  };
}

// ... (Rest der Datei, `closeMCPClients` um m365Client erweitern)
```

#### 3.4.2 `srv/service.js` modifizieren
*   **Änderung:** Bringen Sie dem Agenten bei, die neuen M365-Tools zu laden und zu verwenden.

```javascript
// srv/service.js (AUSZUG AUS `initializeAgent`)

// ... (bestehende imports)

// +++ NEU START: Importiere Helfer für die M365-Tools +++
import { z } from "zod";
import { DynamicStructuredTool } from "@langchain/core/tools";
// Pfad muss ggf. angepasst werden
const { jsonSchemaToZod } = require("./m365-mcp/mcp-jsonschema.js");
// +++ NEU ENDE +++

// ...

const initializeAgent = async () => {
    if (agentExecutor) return agentExecutor;
    console.log("Initializing Agent with all capabilities...");
    try {
        mcpClients = await initAllMCPClients();
        let allTools = [];

        // ... (bestehender Code zum Laden von postgres, brave, excel etc. Tools)
        allTools.push(...postgresTools, ...braveSearchTools, ...excelTools);

        // +++ NEU START: Lade die M365-Tools dynamisch aus dem Manifest +++
        if (mcpClients.m365) {
            console.log("Loading Microsoft 365 tools...");
            const m365Manifest = await mcpClients.m365.listTools();
            const m365LangchainTools = m365Manifest.tools.map(toolDef => {
                const zodSchema = jsonSchemaToZod(toolDef.inputSchema, z);
                return new DynamicStructuredTool({
                    name: toolDef.name,
                    description: toolDef.description,
                    schema: zodSchema,
                    func: async (input) => {
                        const result = await mcpClients.m365.callTool({ name: toolDef.name, arguments: input });
                        return typeof result === 'string' ? result : JSON.stringify(result);
                    }
                });
            });
            allTools.push(...m365LangchainTools);
            console.log(`✅ Loaded ${m365LangchainTools.length} Microsoft 365 tools.`);
        }
        // +++ NEU ENDE +++

        console.log("All available tools:", allTools.map(tool => tool.name));
        
        // ... (Rest der Funktion: LLM initialisieren, Agent erstellen, etc.)
        
    } catch (error) {
        console.error("❌ Failed to initialize agent:", error);
        throw error;
    }
};
```

### 3.5 Authentifizierung konfigurieren

Erstellen oder bearbeiten Sie die `.env`-Datei im Hauptverzeichnis des `StammtischAI`-Projekts und fügen Sie die folgende Zeile hinzu:

```ini
# .env Datei
# ... (andere Variablen)

# Konfiguration für den M365 Client: Nur die 'm365 login' CLI verwenden
M365_AUTH_METHOD=cli
```

Der Entwickler muss sicherstellen, dass die M365 CLI installiert (`npm i -g @pnp/cli-microsoft365`) und er angemeldet ist (`m365 login`).

### 3.6 System Prompt des Agenten aktualisieren

Öffnen Sie die Datei `srv/prompts/assistant-prompt.js` und fügen Sie im `SYSTEM_PROMPT` einen neuen Abschnitt hinzu, der die M365-Fähigkeiten und den Hybrid-Workflow erklärt.

**Fügen Sie diesen Block zum `SYSTEM_PROMPT` hinzu:**

```
## Erweiterte Agent-Funktionen mit Microsoft 365

Du hast zusätzlich Zugriff auf Microsoft 365.

### Fähigkeiten
- **E-Mails:** Letzte E-Mail lesen (`mail.latestMessage.get`), Anhänge herunterladen (`mail.attachment.download`).
- **Kalender:** Termine auflisten (`calendar.events.list`).

### WICHTIGER WORKFLOW FÜR EXCEL-ANHÄNGE
Wenn du eine Excel-Datei aus einem E-Mail-Anhang analysieren sollst, folge IMMER diesem Plan:
1.  **Schritt 1:** Lade den Anhang zuerst mit `mail.attachment.download` in ein temporäres Verzeichnis herunter. Das Tool gibt dir den benötigten Dateipfad.
2.  **Schritt 2:** Verwende dann die `excel_*` Tools (z.B. `excel_read_sheet`) und übergib ihnen den Dateipfad aus Schritt 1 für die Analyse.
3.  **Schritt 3:** Berichte dem Benutzer das Ergebnis.
```

## 4. Akzeptanzkriterien

Die Umsetzung gilt als erfolgreich, wenn:
1.  Die Anwendung ohne Fehler startet und in den Logs die erfolgreiche Initialisierung des "Microsoft 365 in-process MCP client" angezeigt wird.
2.  Der Agent in der Lage ist, auf die Anfrage "Lies die letzte E-Mail in meinem Posteingang" zu reagieren und den Betreff der E-Mail korrekt wiedergibt.
3.  Der Agent auf die Anfrage "Welche Termine habe ich heute?" korrekt mit einer Liste von Terminen antwortet.
4.  Der Agent den in 3.6 beschriebenen Hybrid-Workflow für Excel-Anhänge korrekt ausführt, wenn eine entsprechende Anfrage gestellt wird.
</file>

<file path="app/package.json">
{
  "name": "app",
  "version": "0.0.1",
  "description": "SAP Stammtisch",
  "keywords": [
    "ui5",
    "openui5",
    "sapui5"
  ],
  "main": "webapp/index.html",
  "dependencies": {},
  "devDependencies": {
    "@ui5/cli": "^3.0.0",
    "@sap/ux-ui5-tooling": "1"
  },
  "scripts": {
    "deploy-config": "npx -p @sap/ux-ui5-tooling fiori add deploy-config cf"
  }
}
</file>

<file path="app/README.md">
## Application Details
|               |
| ------------- |
|**Generation Date and Time**<br>Sun May 18 2025 13:33:29 GMT+0200 (Mitteleuropäische Sommerzeit)|
|**App Generator**<br>SAP Fiori Application Generator|
|**App Generator Version**<br>1.17.5|
|**Generation Platform**<br>CLI|
|**Template Used**<br>List Report Page V4|
|**Service Type**<br>Local Cap|
|**Service URL**<br>http://localhost:4004/service/stammtisch/|
|**Module Name**<br>app|
|**Application Title**<br>Stammtisch Verwaltung|
|**Namespace**<br>sap.stammtisch.ui|
|**UI5 Theme**<br>sap_horizon|
|**UI5 Version**<br>1.136.0|
|**Enable Code Assist Libraries**<br>False|
|**Enable TypeScript**<br>False|
|**Add Eslint configuration**<br>False|
|**Main Entity**<br>Stammtische|
|**Navigation Entity**<br>teilnehmer|

## app

SAP Stammtisch

### Starting the generated app

-   This app has been generated using the SAP Fiori tools - App Generator, as part of the SAP Fiori tools suite.  In order to launch the generated app, simply start your CAP project and navigate to the following location in your browser:

http://localhost:4004/app/webapp/index.html

#### Pre-requisites:

1. Active NodeJS LTS (Long Term Support) version and associated supported NPM version.  (See https://nodejs.org)
</file>

<file path="app/webapp/Component.js">
sap.ui.define([
    "sap/fe/core/AppComponent"
    // JSONModel wird nicht mehr hier direkt benötigt, kommt von außen
], function (AppComponent) {
    "use strict";

    return AppComponent.extend("sap.stammtisch.ui.app.Component", {
        metadata: {
            manifest: "json"
        },

        _oChatModelExternal: null,
        _oDynamicSideContentExternal: null,
        _aiSendFunctionFromCustomAction: null, // Für den AI Call aus CustomAction

        init: function () {
            // Standard FE Initialisierung
            AppComponent.prototype.init.apply(this, arguments);
            console.log("Fiori Elements Component 'sap.stammtisch.ui.app' initialized.");
        },

        // Wird von main.js aufgerufen
        setExternalDependencies: function(oChatModel, oDynamicSideContent) {
            this._oChatModelExternal = oChatModel;
            this._oDynamicSideContentExternal = oDynamicSideContent;
        },

        getChatModel: function() {
            return this._oChatModelExternal;
        },

        getDynamicSideContent: function() {
            return this._oDynamicSideContentExternal;
        },

        // Wird von CustomActions.js aufgerufen, um die Sende-Logik zu registrieren
        registerAISendFunction: function(fnSend) {
            this._aiSendFunctionFromCustomAction = fnSend;
        },

        // Wird von main.js (ChatFragmentController) aufgerufen
        invokeAIActionOnCurrentPage: function(sPrompt, oChatModelToUpdate) {
            if (this._aiSendFunctionFromCustomAction) {
                // Ruft die in CustomActions.js definierte Funktion auf,
                // die den korrekten `this`-Kontext (ExtensionAPI) hat.
                this._aiSendFunctionFromCustomAction(sPrompt, oChatModelToUpdate);
            } else {
                console.error("AI Send function from CustomAction not registered on FE component.");
                var aHistory = oChatModelToUpdate.getProperty("/chatHistory");
                aHistory.pop(); // "Thinking..." entfernen
                aHistory.push({ type: "assistant", text: "Error: AI Call handler not registered." });
                oChatModelToUpdate.setProperty("/chatHistory", aHistory);
                oChatModelToUpdate.refresh(true);
                if (window.triggerChatScroll) window.triggerChatScroll();
            }
        }
    });
});
</file>

<file path="app/webapp/i18n/i18n.properties">
# This is the resource bundle for sap.stammtisch.ui.app

#Texts for manifest.json

#XTIT: Application name
appTitle=Stammtisch Verwaltung

#YDES: Application description
appDescription=SAP Stammtisch

#XBUT: Text for AI Chat button
btnTextAIChat=AI Chat
</file>

<file path="app/webapp/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Stammtisch Verwaltung</title>
    <style>
        html, body, #appHost { /* Wichtig: appHost soll die volle Höhe einnehmen */
            height: 100%;
            margin: 0;
            padding: 0;
        }
    </style>
    <script
        id="sap-ui-bootstrap"
        src="https://sapui5.hana.ondemand.com/1.136.0/resources/sap-ui-core.js"
        data-sap-ui-theme="sap_horizon"
        data-sap-ui-resourceroots='{
            "sap.stammtisch.ui.app": "./"
        }'
        data-sap-ui-oninit="module:sap/stammtisch/ui/app/main"
        data-sap-ui-compatVersion="edge"
        data-sap-ui-async="true"
        data-sap-ui-frameOptions="trusted"
    ></script>
</head>
<body class="sapUiBody sapUiSizeCompact">
    <!-- Platzhalter für unsere App-Struktur, die von main.js gefüllt wird -->
    <div id="appHost"></div>
</body>
</html>
</file>

<file path="app/webapp/test/flpSandbox.html">
<!DOCTYPE HTML>
<html lang="en">
<!-- Copyright (c) 2015 SAP AG, All Rights Reserved -->
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{appTitle}}</title>

    <!-- Bootstrap the unified shell in sandbox mode for standalone usage.

         The renderer is specified in the global Unified Shell configuration object "sap-ushell-config".

         The fiori2 renderer will render the shell header allowing, for instance,
         testing of additional application setting buttons.

         The navigation target resolution service is configured in a way that the empty URL hash is
         resolved to our own application.

         This example uses relative path references for the SAPUI5 resources and test-resources;
         it might be necessary to adapt them depending on the target runtime platform.
         The sandbox platform is restricted to development or demo use cases and must NOT be used
         for productive scenarios.
    -->
    <script type="text/javascript">
        window["sap-ushell-config"] = {
            defaultRenderer: "fiori2",
            bootstrapPlugins: {
                "RuntimeAuthoringPlugin": {
                    component: "sap.ushell.plugins.rta",
                    config: {
                        validateAppVersion: false
                    }
                }
            },
            renderers: {
                fiori2: {
                    componentData: {
                        config: {
                            search: "hidden",
                            enableSearch: false
                        }
                    }
                }
            },
            applications: {
                "sapstammtischuiapp-tile": {
                    title: "Stammtisch Verwaltung",
                    description: "SAP Stammtisch",
                    additionalInformation: "SAPUI5.Component=sap.stammtisch.ui.app",
                    applicationType: "URL",
                    url: "../"
                }
            }
        };
    </script>

    <script src="https://sapui5.hana.ondemand.com/1.136.0/test-resources/sap/ushell/bootstrap/sandbox.js" id="sap-ushell-bootstrap"></script>
    <!-- Bootstrap the UI5 core library. 'data-sap-ui-frameOptions="allow"'' is a NON-SECURE setting for test environments -->
    <script id="sap-ui-bootstrap"
        src="https://sapui5.hana.ondemand.com/1.136.0/resources/sap-ui-core.js"
        data-sap-ui-libs=""
        data-sap-ui-async="true"
        data-sap-ui-preload="async"
        data-sap-ui-theme="sap_horizon"
        data-sap-ui-compatVersion="edge"
        data-sap-ui-language="en"
        data-sap-ui-resourceroots='{"sap.stammtisch.ui.app": "../"}'
        data-sap-ui-frameOptions="allow"
        data-sap-ui-flexibilityServices='[{"connector": "LocalStorageConnector"}]'>
    </script>
    <script>
        sap.ui.getCore().attachInit(function () {
            sap.ushell.Container.createRenderer().placeAt("content");
        });
    </script>
</head>

<!-- UI Content -->

<body class="sapUiBody" id="content">
</body>

</html>
</file>

<file path="app/webapp/test/integration/FirstJourney.js">
sap.ui.define([
    "sap/ui/test/opaQunit"
], function (opaTest) {
    "use strict";

    var Journey = {
        run: function() {
            QUnit.module("First journey");

            opaTest("Start application", function (Given, When, Then) {
                Given.iStartMyApp();

                Then.onTheStammtischeList.iSeeThisPage();

            });


            opaTest("Navigate to ObjectPage", function (Given, When, Then) {
                // Note: this test will fail if the ListReport page doesn't show any data
                
                When.onTheStammtischeList.onFilterBar().iExecuteSearch();
                
                Then.onTheStammtischeList.onTable().iCheckRows();

                When.onTheStammtischeList.onTable().iPressRow(0);
                Then.onTheStammtischeObjectPage.iSeeThisPage();

            });

            opaTest("Teardown", function (Given, When, Then) { 
                // Cleanup
                Given.iTearDownMyApp();
            });
        }
    }

    return Journey;
});
</file>

<file path="app/webapp/test/integration/opaTests.qunit.html">
<!DOCTYPE html>
<html>
<head>
    <title>Integration tests</title>
    <meta charset="utf-8">

    <script id="sap-ui-bootstrap"
            src="/resources/sap-ui-core.js"
            data-sap-ui-theme='sap_fiori_3'
            data-sap-ui-resourceroots='{
                "sap.stammtisch.ui.app": "../../"
            }'
            data-sap-ui-animation="false"
            data-sap-ui-compatVersion="edge"
            data-sap-ui-async="true">
    </script>

    <link rel="stylesheet" type="text/css" href="/resources/sap/ui/thirdparty/qunit-2.css">

    <script src="/resources/sap/ui/thirdparty/qunit-2.js"></script>
    <script src="/resources/sap/ui/qunit/qunit-junit.js"></script>

    <script src="opaTests.qunit.js"></script>

</head>
<body>
    <div id="qunit"></div>
    <div id="qunit-fixture"></div>
</body>
</html>
</file>

<file path="app/webapp/test/integration/opaTests.qunit.js">
sap.ui.require(
    [
        'sap/fe/test/JourneyRunner',
        'sap/stammtisch/ui/app/test/integration/FirstJourney',
		'sap/stammtisch/ui/app/test/integration/pages/StammtischeList',
		'sap/stammtisch/ui/app/test/integration/pages/StammtischeObjectPage',
		'sap/stammtisch/ui/app/test/integration/pages/TeilnehmerObjectPage'
    ],
    function(JourneyRunner, opaJourney, StammtischeList, StammtischeObjectPage, TeilnehmerObjectPage) {
        'use strict';
        var JourneyRunner = new JourneyRunner({
            // start index.html in web folder
            launchUrl: sap.ui.require.toUrl('sap/stammtisch/ui/app') + '/index.html'
        });

       
        JourneyRunner.run(
            {
                pages: { 
					onTheStammtischeList: StammtischeList,
					onTheStammtischeObjectPage: StammtischeObjectPage,
					onTheTeilnehmerObjectPage: TeilnehmerObjectPage
                }
            },
            opaJourney.run
        );
    }
);
</file>

<file path="app/webapp/test/integration/pages/StammtischeList.js">
sap.ui.define(['sap/fe/test/ListReport'], function(ListReport) {
    'use strict';

    var CustomPageDefinitions = {
        actions: {},
        assertions: {}
    };

    return new ListReport(
        {
            appId: 'sap.stammtisch.ui.app',
            componentId: 'StammtischeList',
            contextPath: '/Stammtische'
        },
        CustomPageDefinitions
    );
});
</file>

<file path="app/webapp/test/integration/pages/StammtischeObjectPage.js">
sap.ui.define(['sap/fe/test/ObjectPage'], function(ObjectPage) {
    'use strict';

    var CustomPageDefinitions = {
        actions: {},
        assertions: {}
    };

    return new ObjectPage(
        {
            appId: 'sap.stammtisch.ui.app',
            componentId: 'StammtischeObjectPage',
            contextPath: '/Stammtische'
        },
        CustomPageDefinitions
    );
});
</file>

<file path="app/webapp/test/integration/pages/TeilnehmerObjectPage.js">
sap.ui.define(['sap/fe/test/ObjectPage'], function(ObjectPage) {
    'use strict';

    var CustomPageDefinitions = {
        actions: {},
        assertions: {}
    };

    return new ObjectPage(
        {
            appId: 'sap.stammtisch.ui.app',
            componentId: 'TeilnehmerObjectPage',
            contextPath: '/Stammtische/teilnehmer'
        },
        CustomPageDefinitions
    );
});
</file>

<file path="app/webapp/test/testsuite.qunit.html">
<!DOCTYPE html>
<html>
  <head>
    <title>QUnit test suite</title>
    <script src="../resources/sap/ui/qunit/qunit-redirect.js"></script>
    <script src="testsuite.qunit.js" data-sap-ui-testsuite></script>
  </head>
  <body></body>
</html>
</file>

<file path="app/webapp/test/testsuite.qunit.js">
window.suite = function() {
    'use strict';

    // eslint-disable-next-line
    var oSuite = new parent.jsUnitTestSuite(),
    
    sContextPath = location.pathname.substring(0, location.pathname.lastIndexOf('/') + 1);
    oSuite.addTestPage(sContextPath + 'integration/opaTests.qunit.html');

    return oSuite;
};
</file>

<file path="eslint.config.mjs">
import cds from '@sap/cds/eslint.config.mjs'
export default [ ...cds.recommended ]
</file>

<file path="srv/m365-mcp/helpers/logging.js">
// srv/m365-mcp/helpers/logging.js
// Provides defensive JSON serialization for logging without crashing on circular structures.

export function safeJson(value, max = 4000) {
  try {
    const serialized = typeof value === 'string' ? value : JSON.stringify(value);
    const output = typeof serialized === 'string' ? serialized : String(serialized);
    return output.length > max ? `${output.slice(0, max)} ...[truncated]` : output;
  } catch (error) {
    try {
      return String(value);
    } catch {
      return '[unprintable]';
    }
  }
}
</file>

<file path="srv/m365-mcp/index.js">
// srv/m365-mcp/index.js
// Entry point for the Microsoft 365 in-process MCP client.

import { createM365ToolManifest, toolDefinitions } from './mcp-tool-manifest.js';
import { GraphClient } from './graph-client.js';
import { getToolHandler, listSupportedTools } from './tools/index.js';
import { safeJson } from './helpers/logging.js';

export async function initM365InProcessClient(options = {}) {
  const {
    logger = console,
    bootstrapScopes = ['Mail.Read']
  } = options;

  const graphClient = new GraphClient({ ...options, logger });
  await graphClient.bootstrap(bootstrapScopes);

  async function listTools() {
    return createM365ToolManifest();
  }

  async function callTool({ name, arguments: args = {} }) {
    if (!name) {
      throw new Error('Tool name is required');
    }
    const handler = getToolHandler(name);
    if (!handler) {
      throw new Error(`Unknown Microsoft 365 tool: ${name}. Supported tools: ${listSupportedTools().join(', ')}`);
    }
    const input = args && typeof args === 'object' ? args : {};
    try {
      const result = await handler({ input, graphClient, logger });
      return result;
    } catch (error) {
      logger.error?.(`Error while executing Microsoft 365 tool ${name}:`, safeJson(error.message || error));
      throw error;
    }
  }

  async function close() {
    await graphClient.close();
  }

  return {
    listTools,
    callTool,
    close,
    toolDefinitions
  };
}
</file>

<file path="srv/m365-mcp/mcp-jsonschema.js">
// srv/m365-mcp/mcp-jsonschema.js
// Minimal JSON Schema to Zod converter tailored to the MCP tool definitions.

function applyCommonMetadata(zodSchema, schema) {
  let result = zodSchema;
  if (schema && typeof schema.description === 'string') {
    result = result.describe(schema.description);
  }
  if (schema && Object.prototype.hasOwnProperty.call(schema, 'default')) {
    result = result.default(schema.default);
  }
  return result;
}

function convertEnum(schema, z) {
  if (!Array.isArray(schema.enum) || schema.enum.length === 0) {
    return null;
  }
  if (schema.enum.every((value) => typeof value === 'string')) {
    return applyCommonMetadata(z.enum([...schema.enum]), schema);
  }
  return applyCommonMetadata(z.union(schema.enum.map((value) => z.literal(value))), schema);
}

function convertArray(schema, z) {
  const itemSchema = schema.items ? jsonSchemaToZod(schema.items, z) : z.any();
  let arraySchema = z.array(itemSchema);
  if (typeof schema.minItems === 'number') {
    arraySchema = arraySchema.min(schema.minItems);
  }
  if (typeof schema.maxItems === 'number') {
    arraySchema = arraySchema.max(schema.maxItems);
  }
  return applyCommonMetadata(arraySchema, schema);
}

function convertObject(schema, z) {
  const properties = schema.properties || {};
  const requiredProps = new Set(schema.required || []);
  const shape = {};

  for (const [key, propertySchema] of Object.entries(properties)) {
    let prop = jsonSchemaToZod(propertySchema, z);
    if (!requiredProps.has(key)) {
      prop = prop.optional();
    }
    shape[key] = prop;
  }

  let objectSchema = z.object(shape);
  if (schema.additionalProperties) {
    const additional = jsonSchemaToZod(schema.additionalProperties, z);
    objectSchema = objectSchema.catchall(additional);
  } else {
    objectSchema = objectSchema.strict();
  }

  if (schema.minProperties) {
    objectSchema = objectSchema.min(schema.minProperties);
  }
  if (schema.maxProperties) {
    objectSchema = objectSchema.max(schema.maxProperties);
  }

  return applyCommonMetadata(objectSchema, schema);
}

export function jsonSchemaToZod(schema, z) {
  if (!schema) {
    return z.any();
  }

  if (schema.enum) {
    const enumSchema = convertEnum(schema, z);
    if (enumSchema) {
      return enumSchema;
    }
  }

  switch (schema.type) {
    case 'string': {
      let stringSchema = z.string();
      if (schema.format === 'date-time') {
        stringSchema = stringSchema.regex(/^[^\s]+$/, 'Expected ISO-8601 datetime string');
      }
      if (schema.minLength) {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (schema.maxLength) {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      return applyCommonMetadata(stringSchema, schema);
    }
    case 'number':
    case 'integer': {
      let numberSchema = schema.type === 'integer' ? z.number().int() : z.number();
      if (typeof schema.minimum === 'number') {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === 'number') {
        numberSchema = numberSchema.max(schema.maximum);
      }
      return applyCommonMetadata(numberSchema, schema);
    }
    case 'boolean': {
      return applyCommonMetadata(z.boolean(), schema);
    }
    case 'array': {
      return convertArray(schema, z);
    }
    case 'object': {
      return convertObject(schema, z);
    }
    default:
      return applyCommonMetadata(z.any(), schema);
  }
}
</file>

<file path=".gitignore">
# CAP StammtischAI
_out
*.db
*.sqlite
connection.properties
default-*.json
.cdsrc-private.json
gen/
node_modules/
target/

# Web IDE, App Studio
.che/
.gen/
.env

# MTA
*_mta_build_tmp
*.mtar
mta_archives/

# Other
.DS_Store
*.orig
*.log

*.iml
*.flattened-pom.xml

# IDEs
# .vscode
# .idea

# @cap-js/cds-typer
@cds-models
</file>

<file path="app/ui5.yaml">
# yaml-language-server: $schema=https://sap.github.io/ui5-tooling/schema/ui5.yaml.json

specVersion: "3.1"
metadata:
  name: sap.stammtisch.ui.app
type: application
server:
  customMiddleware:
    - name: fiori-tools-proxy
      afterMiddleware: compression
      configuration:
        ignoreCertError: false # If set to true, certificate errors will be ignored. E.g. self-signed certificates will be accepted
        ui5:
          path:
            - /resources
            - /test-resources
          url: https://sapui5.hana.ondemand.com
    # - name: fiori-tools-appreload
    #   afterMiddleware: compression
    #   configuration:
    #     port: 35729
    #     path: webapp
    #     delay: 300
</file>

<file path="srv/m365-mcp/tools/calendar.js">
// srv/m365-mcp/tools/calendar.js
// Tool handlers for Microsoft 365 calendar interactions.

import { safeJson } from '../helpers/logging.js';

function getInfoLogger(logger) {
  if (!logger) return () => {};
  if (typeof logger.info === 'function') return logger.info.bind(logger);
  if (typeof logger.log === 'function') return logger.log.bind(logger);
  return () => {};
}

export async function handleCalendarEventsList({ input, graphClient, logger }) {
  const info = getInfoLogger(logger);
  info('M365 calendar.events.list invoked with input:', safeJson(input));

  const events = await graphClient.listCalendarEvents({
    startDateTime: input.startDateTime,
    endDateTime: input.endDateTime
  });

  return {
    startDateTime: input.startDateTime,
    endDateTime: input.endDateTime,
    count: events.length,
    events
  };
}

export async function handleCalendarEventCreate({ input, graphClient, logger }) {
  const info = getInfoLogger(logger);
  const masked = {
    ...input,
    body: input.body ? '[provided]' : undefined
  };
  info('M365 calendar.event.create invoked with input:', safeJson(masked));

  const result = await graphClient.createCalendarEvent({
    subject: input.subject,
    body: input.body,
    contentType: input.contentType,
    startDateTime: input.startDateTime,
    endDateTime: input.endDateTime,
    timezone: input.timezone,
    attendees: input.attendees,
    teams: input.teams,
    location: input.location,
    reminderMinutesBeforeStart: input.reminderMinutesBeforeStart,
    allowNewTimeProposals: input.allowNewTimeProposals,
    isOnlineMeeting: input.isOnlineMeeting,
    onlineMeetingProvider: input.onlineMeetingProvider
  });

  return result;
}
</file>

<file path="db/data/sap.stammtisch-Praesentatoren.csv">
ID;name;email;linkedin
p1;Max Mustermann;max@example.com;linkedin.com/in/maxmustermann
p2;Erika Beispiel;erika@example.com;linkedin.com/in/erikabeispiel
p3;Lukas Neuer;lukas.neuer@example.com;linkedin.com/in/lukasneuer
p4;Sabine Vogel;sabine.vogel@example.com;linkedin.com/in/sabinevogel
</file>

<file path="db/data/sap.stammtisch-Stammtische.csv">
ID;thema;datum;ort;praesentator_ID
a1b2c3d4-e5f6-7890-1234-567890abcdef;Einführung in CAP;2023-10-26T19:00:00Z;SAP Walldorf WDF01;p1
b2c3d4e5-f6a7-8901-2345-67890abcdef0;AI mit SAP BTP;2023-11-15T18:30:00Z;Online;p2
c3d4e5f6-a7b8-9012-3456-7890abcdef01;SAP Fiori Deep Dive;2024-01-20T18:00:00Z;SAP München MUC02;p3
d4e5f6a7-b8c9-0123-4567-890abcdef012;Integration mit CPI;2024-02-15T17:30:00Z;Online;p4
</file>

<file path="db/data/sap.stammtisch-Teilnehmer.csv">
name;email;stammtisch_ID
Anna Schmidt;anna.schmidt@example.com;a1b2c3d4-e5f6-7890-1234-567890abcdef
Ben Müller;ben.mueller@example.com;a1b2c3d4-e5f6-7890-1234-567890abcdef
Carla Lehmann;carla.lehmann@example.com;a1b2c3d4-e5f6-7890-1234-567890abcdef
David Weber;david.weber@example.com;b2c3d4e5-f6a7-8901-2345-67890abcdef0
Eva Schulz;eva.schulz@example.com;b2c3d4e5-f6a7-8901-2345-67890abcdef0
Finn Wagner;finn.wagner@example.com;a1b2c3d4-e5f6-7890-1234-567890abcdef
Greta Hoffmann;greta.hoffmann@example.com;b2c3d4e5-f6a7-8901-2345-67890abcdef0
Hans Zimmer;hans.zimmer@example.com;b2c3d4e5-f6a7-8901-2345-67890abcdef0
Ida Bauer;ida.bauer@example.com;a1b2c3d4-e5f6-7890-1234-567890abcdef
Jan Klein;jan.klein@example.com;b2c3d4e5-f6a7-8901-2345-67890abcdef0
Katharina Meier;katharina.meier@example.com;c3d4e5f6-a7b8-9012-3456-7890abcdef01
Thomas Richter;thomas.richter@example.com;c3d4e5f6-a7b8-9012-3456-7890abcdef01
Ulrike Braun;ulrike.braun@example.com;d4e5f6a7-b8c9-0123-4567-890abcdef012
Martin Klein;martin.klein@example.com;d4e5f6a7-b8c9-0123-4567-890abcdef012
</file>

<file path="db/schema.cds">
namespace sap.stammtisch;

using { cuid, managed, temporal } from '@sap/cds/common';

entity Praesentatoren : cuid, managed {
    @Common.Label : 'Name'
    @Common.Text : {
        $value : name,
        textArrangement : #TextFirst // oder #TextOnly
    }
    name          : String(100) not null;

    @Common.Label : 'E-Mail'
    email         : String;

    @Common.Label : 'LinkedIn'
    linkedin      : String;

    // Diese Komposition erlaubt es, auf der Präsentator-Objektseite eine Tabelle
    // mit den Stammtischen dieses Präsentators anzuzeigen.
    stammtische   : Composition of many Stammtische
                      on stammtische.praesentator = $self;
}

entity Stammtische : cuid, managed {
    key ID        : UUID @(Core.Computed : true);

    @Common.Label : 'Thema'
    thema         : String(255) not null;

    @Common.Label : 'Datum'
    datum         : DateTime not null;

    @Common.Label : 'Ort'
    ort           : String(100);

    @Common.Label : 'Notizen'
    notizen       : LargeString;

    @Common.Label : 'Präsentator'
    praesentator  : Association to Praesentatoren;

    teilnehmer    : Composition of many Teilnehmer
                      on teilnehmer.stammtisch = $self;
}

entity Teilnehmer : cuid, managed {
    key ID        : UUID @(Core.Computed : true);

    @Common.Label : 'Name des Teilnehmers'
    name          : String(100) not null;

    @Common.Label : 'E-Mail des Teilnehmers'
    email         : String;
    stammtisch    : Association to Stammtische;
}
</file>

<file path="srv/m365-mcp/tools/mail.js">
// srv/m365-mcp/tools/mail.js
// Tool handlers for Microsoft 365 mail interactions.

import { safeJson } from '../helpers/logging.js';

function getInfoLogger(logger) {
  if (!logger) return () => {};
  if (typeof logger.info === 'function') return logger.info.bind(logger);
  if (typeof logger.log === 'function') return logger.log.bind(logger);
  return () => {};
}

export async function handleMailLatestMessage({ input, graphClient, logger }) {
  const info = getInfoLogger(logger);
  info('M365 mail.latestMessage.get invoked with input:', safeJson(input));
  const folderId = input.folderId || 'inbox';
  const message = await graphClient.getLatestMessage({ folderId });
  if (!message) {
    return {
      message: `No messages found in folder "${folderId}"`,
      folderId
    };
  }
  return {
    folderId,
    message
  };
}

export async function handleMailAttachmentDownload({ input, graphClient, logger }) {
  const info = getInfoLogger(logger);
  info('M365 mail.attachment.download invoked with input:', safeJson({
    ...input,
    targetPath: '[redacted]'
  }));

  const result = await graphClient.downloadAttachment({
    messageId: input.messageId,
    attachmentId: input.attachmentId,
    targetPath: input.targetPath
  });
  return {
    status: 'downloaded',
    details: result
  };
}

export async function handleMailMessagesList({ input, graphClient, logger }) {
  const info = getInfoLogger(logger);
  info('M365 mail.messages.list invoked with input:', safeJson(input));

  const messages = await graphClient.listMessages({
    folderId: input.folderId,
    startDateTime: input.startDateTime,
    endDateTime: input.endDateTime,
    maxResults: input.maxResults
  });

  return {
    folderId: input.folderId || 'inbox',
    count: messages.length,
    messages
  };
}

export async function handleMailMessageReply({ input, graphClient, logger }) {
  const info = getInfoLogger(logger);
  const masked = {
    ...input,
    body: input.body ? '[redacted]' : undefined,
    comment: input.comment ? '[provided]' : undefined
  };
  info('M365 mail.message.reply invoked with input:', safeJson(masked));

  if (!input.messageId) {
    throw new Error('messageId is required');
  }

  const result = await graphClient.replyToMessage({
    messageId: input.messageId,
    comment: input.comment,
    body: input.body,
    contentType: input.contentType,
    replyAll: input.replyAll
  });

  return result;
}
</file>

<file path="srv/utils/markdown-converter.js">
// srv/utils/markdown-converter.js
/**
 * Einfacher Markdown-zu-HTML Konverter für AI-Antworten
 * Speziell optimiert für SAP UI5 FormattedText Component
 */

class MarkdownConverter {
  
  /**
   * Konvertiert Markdown zu HTML für SAP UI5 FormattedText
   * @param {string} markdown - Markdown Text
   * @returns {string} HTML String
   */
  static convertToHTML(markdown) {
    if (!markdown || typeof markdown !== 'string') {
      return '';
    }

    let html = markdown;

    // 1. Code-Blöcke (müssen zuerst verarbeitet werden)
    html = this.convertCodeBlocks(html);

    // 2. Inline Code
    html = this.convertInlineCode(html);

    // 3. Headers (H1-H4)
    html = this.convertHeaders(html);

    // 4. Bold und Italic
    html = this.convertTextFormatting(html);

    // 5. Listen
    html = this.convertLists(html);

    // 6. Links (falls vorhanden)
    html = this.convertLinks(html);

    // 7. Emojis und Sonderzeichen beibehalten
    html = this.preserveEmojis(html);

    // 8. Zeilenumbrüche
    html = this.convertLineBreaks(html);

    // 9. SAP UI5 spezifische Optimierungen
    html = this.optimizeForSAPUI5(html);

    return html.trim();
  }

  /**
   * Konvertiert Code-Blöcke
   */
  static convertCodeBlocks(text) {
    // ```language \n code \n ```
    return text.replace(/```(\w*)\n([\s\S]*?)\n```/g, (match, language, code) => {
      const cleanCode = this.escapeHTML(code.trim());
      return `<div class="ai-code-block">
        <div class="ai-code-header">${language || 'Code'}</div>
        <pre class="ai-code-content"><code>${cleanCode}</code></pre>
      </div>`;
    });
  }

  /**
   * Konvertiert Inline-Code
   */
  static convertInlineCode(text) {
    return text.replace(/`([^`]+)`/g, '<code class="ai-inline-code">$1</code>');
  }

  /**
   * Konvertiert Headers
   */
  static convertHeaders(text) {
    // ### Header 3
    text = text.replace(/^### (.+)$/gm, '<h3 class="ai-header-3">$1</h3>');
    // ## Header 2  
    text = text.replace(/^## (.+)$/gm, '<h2 class="ai-header-2">$1</h2>');
    // # Header 1
    text = text.replace(/^# (.+)$/gm, '<h1 class="ai-header-1">$1</h1>');
    
    return text;
  }

  /**
   * Konvertiert Bold und Italic
   */
  static convertTextFormatting(text) {
    // **Bold**
    text = text.replace(/\*\*([^*]+)\*\*/g, '<strong class="ai-bold">$1</strong>');
    // *Italic*
    text = text.replace(/\*([^*]+)\*/g, '<em class="ai-italic">$1</em>');
    
    return text;
  }

  /**
   * Konvertiert Listen
   */
  static convertLists(text) {
    // Unordered Lists
    text = text.replace(/^- (.+)$/gm, '<li class="ai-list-item">$1</li>');
    
    // Wrap consecutive list items in <ul>
    text = text.replace(/(<li class="ai-list-item">.*<\/li>\s*)+/gs, (match) => {
      return `<ul class="ai-unordered-list">${match}</ul>`;
    });

    // Numbered Lists (vereinfacht)
    text = text.replace(/^\d+\. (.+)$/gm, '<li class="ai-numbered-item">$1</li>');
    
    // Wrap consecutive numbered items in <ol>
    text = text.replace(/(<li class="ai-numbered-item">.*<\/li>\s*)+/gs, (match) => {
      return `<ol class="ai-ordered-list">${match}</ol>`;
    });

    return text;
  }

  /**
   * Konvertiert Links
   */
  static convertLinks(text) {
    // [Text](URL)
    return text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="#" class="ai-link" data-url="$2" title="$2">$1</a>');
  }

  /**
   * Behält Emojis bei
   */
  static preserveEmojis(text) {
    // Emojis sind bereits Unicode, keine Konvertierung nötig
    return text;
  }

  /**
   * Konvertiert Zeilenumbrüche
   */
  static convertLineBreaks(text) {
    // Doppelte Zeilenumbrüche zu Paragraphen
    text = text.replace(/\n\n+/g, '</p><p class="ai-paragraph">');
    
    // Einzelne Zeilenumbrüche zu <br>
    text = text.replace(/\n/g, '<br/>');
    
    // Wrap in paragraph wenn nicht schon in anderen Tags
    if (!text.startsWith('<') && text.length > 0) {
      text = `<p class="ai-paragraph">${text}</p>`;
    }

    return text;
  }

  /**
   * SAP UI5 spezifische Optimierungen
   */
  static optimizeForSAPUI5(text) {
    // Bereinige leere Paragraphen
    text = text.replace(/<p class="ai-paragraph"><\/p>/g, '');
    
    // Stelle sicher, dass alle Tags geschlossen sind
    text = this.closeOpenTags(text);
    
    return text;
  }

  /**
   * HTML Escaping für Sicherheit
   */
  static escapeHTML(text) {
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    return text.replace(/[&<>"']/g, (m) => map[m]);
  }

  /**
   * Schließt offene Tags (vereinfacht)
   */
  static closeOpenTags(html) {
    // Einfache Implementation - für Produktionsumgebung sollte ein richtiger HTML-Parser verwendet werden
    const openTags = [];
    const tagRegex = /<\/?([a-zA-Z][a-zA-Z0-9]*)[^>]*>/g;
    
    let match;
    while ((match = tagRegex.exec(html)) !== null) {
      if (match[0].startsWith('</')) {
        // Closing tag
        const tag = match[1].toLowerCase();
        const index = openTags.lastIndexOf(tag);
        if (index !== -1) {
          openTags.splice(index, 1);
        }
      } else if (!match[0].endsWith('/>')) {
        // Opening tag (not self-closing)
        openTags.push(match[1].toLowerCase());
      }
    }

    // Schließe offene Tags
    for (let i = openTags.length - 1; i >= 0; i--) {
      html += `</${openTags[i]}>`;
    }

    return html;
  }

  /**
   * Spezielle Konvertierung für SAP-spezifische Inhalte
   */
  static convertSAPContent(text) {
    // SAP UI5 Komponenten-Namen hervorheben
    text = text.replace(/\b(List Report|Object Page|Draft|Value Help|Smart Filter Bar)\b/g, 
      '<span class="ai-sap-term">$1</span>');
    
    // Schritt-für-Schritt Anleitungen
    text = text.replace(/^\*\*Schritt (\d+)\*\*:?/gm, 
      '<div class="ai-step-header">📋 <strong>Schritt $1</strong></div>');
    
    return text;
  }

  /**
   * Hauptmethode für die Konvertierung mit SAP-spezifischen Verbesserungen
   */
  static convertForStammtischAI(markdown) {
    let html = this.convertToHTML(markdown);
    html = this.convertSAPContent(html);
    return html;
  }
}

export default MarkdownConverter;
</file>

<file path=".cdsrc.json">
{
  "requires": {
    "db": {
      "kind": "postgres",
      "credentials": {
        "database": "stammtisch_ai_db",
        "user": "duh",
        "password": "test123",
        "host": "localhost", 
        "port": 5432        
      }
    }
  }
}
</file>

<file path="app/annotations.cds">
using StammtischService as service from '../srv/service';
using { sap.stammtisch as model }   from '../db/schema';


/* =========================================================
 * Stammtische (Service-Entität)
 * =======================================================*/
annotate service.Stammtische with @(
    UI.HeaderInfo : {
        TypeName        : 'Stammtisch',
        TypeNamePlural  : 'Stammtische',
        Title           : { Value : thema },
        Description     : { Value : ort }
    },

    UI.FieldGroup #GeneratedGroup : {
        $Type : 'UI.FieldGroupType',
        Data  : [
            { Value : thema },
            { Value : datum },
            { Value : ort  },
            {
            $Type  : 'UI.DataFieldWithNavigationPath',   // V4-konform
            Label  : 'Präsentator',
            Value  : praesentator,          // Navigation Property, nicht _ID
            Target : 'praesentator'         // erzeugt Link zur Presenter-OP
            },
            { Value : notizen }
        ]
    },

    UI.Facets : [
        {
            $Type : 'UI.ReferenceFacet',
            ID    : 'StammtischGeneralInfoFacet',
            Label : 'Allgemeine Informationen',
            Target: '@UI.FieldGroup#GeneratedGroup'
        },
        {
            $Type : 'UI.ReferenceFacet',
            ID    : 'TeilnehmerFacet',
            Label : 'Teilnehmer',
            Target: 'teilnehmer/@UI.LineItem'
        }
    ],

    UI.LineItem : [
        { Value : thema },
        { Value : datum },
        { Value : ort  },
        {
            Value : praesentator.name,
            Label : 'Präsentator'
        },
        { Value : notizen, ![@UI.Importance] : #Low }
    ]
) {
    /* -------- Value Help & Semantik für Präsentator -------- */
    praesentator @Common.ValueList : {
        $Type          : 'Common.ValueListType',
        CollectionPath : 'Praesentatoren',
        Parameters     : [
            {
                $Type              : 'Common.ValueListParameterInOut',
                LocalDataProperty  : praesentator_ID,
                ValueListProperty  : 'ID'
            },
            {
                $Type             : 'Common.ValueListParameterDisplayOnly',
                ValueListProperty : 'name'
            },
            {
                $Type             : 'Common.ValueListParameterDisplayOnly',
                ValueListProperty : 'email'
            }
        ]
    };
    praesentator @Common.SemanticObject : 'Praesentator';

    /* -------- Fix: Line-Item auf Navigation Property -------- */
    teilnehmer @(
        UI.LineItem : [
            { Value : name,  Label : 'Name'  },
            { Value : email, Label : 'E-Mail'}
        ],
        UI.Identification : [
            { Value : name }
        ]
    );
};   /* <<———— Semikolon */


/* =========================================================
 * Präsentatoren (Service-Entität)
 * =======================================================*/
annotate service.Praesentatoren with @(
    UI.HeaderInfo : {
        TypeName       : 'Präsentator',
        TypeNamePlural : 'Präsentatoren',
        Title          : { Value : name },
        Description    : { Value : email }
    },

    UI.LineItem : [
        { Value : name },
        { Value : email },
        { Value : linkedin, ![@UI.Importance] : #Low }
    ],

    UI.Facets : [
        {
            $Type  : 'UI.ReferenceFacet',
            Label  : 'Allgemeine Informationen',
            Target : '@UI.FieldGroup#PraesentatorGeneralInfo'
        },
        {
            $Type  : 'UI.ReferenceFacet',
            Label  : 'Gehaltene Stammtische',
            Target : 'stammtische/@UI.LineItem'
        }
    ],

    UI.FieldGroup #PraesentatorGeneralInfo : {
        Data : [
            { Value : name     },
            { Value : email    },
            { Value : linkedin }
        ]
    }
);   /* <<———— Semikolon */


/* =========================================================
 * Teilnehmer (Service-Entität)
 * =======================================================*/
annotate service.Teilnehmer with @(
    UI.HeaderInfo : {
        TypeName       : 'Teilnehmer',
        TypeNamePlural : 'Teilnehmer',
        Title          : { Value : name  },
        Description    : { Value : email }
    },

    UI.LineItem : [
        { Value : name,  Label : 'Name'  },
        { Value : email, Label : 'E-Mail'}
    ],

    UI.Facets : [
        {
            $Type  : 'UI.ReferenceFacet',
            Label  : 'Details zum Teilnehmer',
            Target : '@UI.FieldGroup#TeilnehmerDetails'
        }
    ],

    UI.FieldGroup #TeilnehmerDetails : {
        Data : [
            { Value : name  },
            { Value : email }
        ]
    }
);   /* <<———— Semikolon */


/* =========================================================
 * Modell-Annotationen (optional)
 * =======================================================*/
annotate model.Praesentatoren with {
    stammtische @(
        UI.LineItem : [
            { Value : thema },
            { Value : datum },
            { Value : ort   }
        ],
        UI.Identification : [
            { Value : thema }
        ]
    );
};  /* <<———— Semikolon */

annotate model.Stammtische with {
    teilnehmer @(
        UI.LineItem : [
            { Value : name,  Label : 'Name'  },
            { Value : email, Label : 'E-Mail'}
        ],
        UI.Identification : [
            { Value : name }
        ]
    );
};  /* <<———— Semikolon */
</file>

<file path="app/webapp/css/customStyles.css">
/* SAP Horizon Theme Chat Interface - Vereinfacht */

/* SAP Horizon Design Tokens */
:root {
  /* Primary Colors */
  --sapHorizon-Blue-Primary: #0070F2;
  --sapHorizon-Blue-Secondary: #E7F3FF;
  --sapHorizon-Blue-Accent: #004B9E;

  /* Neutral Colors */
  --sapHorizon-Neutral-100: #FFFFFF;
  --sapHorizon-Neutral-200: #F5F6F7;
  --sapHorizon-Neutral-300: #EAECEF;
  --sapHorizon-Neutral-400: #D5D9DD;
  --sapHorizon-Neutral-500: #8396A8;
  --sapHorizon-Neutral-600: #556B82;
  --sapHorizon-Neutral-700: #354A5F;
  --sapHorizon-Neutral-800: #1D2D3E;

  /* Semantic Colors */
  --sapHorizon-Success: #30914C;
  --sapHorizon-Warning: #E76B00;
  --sapHorizon-Error: #BB0000;
  --sapHorizon-Information: #0070F2;

  /* SAP Horizon Spacing */
  --sapHorizon-Space-Tiny: 0.25rem;
  --sapHorizon-Space-Small: 0.5rem;
  --sapHorizon-Space-Medium: 1rem;
  --sapHorizon-Space-Large: 1.5rem;
  --sapHorizon-Space-XLarge: 2rem;

  /* SAP Horizon Typography */
  --sapHorizon-FontFamily: "72", "72full", Arial, Helvetica, sans-serif;
  --sapHorizon-FontSize-Small: 0.75rem;
  --sapHorizon-FontSize-Medium: 0.875rem;
  --sapHorizon-FontSize-Large: 1rem;
  --sapHorizon-FontSize-XLarge: 1.25rem;

  /* SAP Horizon Shadows */
  --sapHorizon-Shadow-Level1: 0 0.125rem 0.5rem 0 rgba(29, 45, 62, 0.1);
  --sapHorizon-Shadow-Level2: 0 0.25rem 1rem 0 rgba(29, 45, 62, 0.15);
  --sapHorizon-Shadow-Level3: 0 0.5rem 1.5rem 0 rgba(29, 45, 62, 0.2);

  /* SAP Horizon Border Radius */
  --sapHorizon-BorderRadius-Small: 0.25rem;
  --sapHorizon-BorderRadius-Medium: 0.5rem;
  --sapHorizon-BorderRadius-Large: 0.75rem;
}

/* Container Styles */
.modernChatContainer {
  background: var(--sapHorizon-Neutral-200);
  font-family: var(--sapHorizon-FontFamily);
  height: 100vh;
  display: flex;
  flex-direction: column;
}

/* Header Styles */
.modernChatHeader {
  background: var(--sapHorizon-Neutral-100);
  border-bottom: 1px solid var(--sapHorizon-Neutral-300);
  padding: var(--sapHorizon-Space-Large) var(--sapHorizon-Space-XLarge);
  box-shadow: var(--sapHorizon-Shadow-Level1);
  position: sticky;
  top: 0;
  z-index: 10;
}

.modernHeaderIcon {
  font-size: 1.5rem;
  color: var(--sapHorizon-Blue-Primary);
}

.modernHeaderTitle {
  font-weight: 600;
  color: var(--sapHorizon-Neutral-800);
  margin: 0;
  line-height: 1.25;
  font-size: var(--sapHorizon-FontSize-Large);
}

.modernHeaderStatus {
  font-size: var(--sapHorizon-FontSize-Small);
  color: var(--sapHorizon-Success);
  font-weight: 500;
}

.modernHeaderButton {
  min-width: 2.25rem;
  height: 2.25rem;
  border-radius: var(--sapHorizon-BorderRadius-Medium);
  margin-left: var(--sapHorizon-Space-Tiny);
  color: var(--sapHorizon-Neutral-600);
}

.modernHeaderButton:hover {
  background-color: var(--sapHorizon-Blue-Secondary);
  color: var(--sapHorizon-Blue-Primary);
}

/* Messages Container */
.modernChatMessagesContainer {
  flex: 1;
  background: transparent;
}

.modernMessagesWrapper {
  max-width: 768px;
  margin: 0 auto;
  padding: var(--sapHorizon-Space-XLarge);
  min-height: 100%;
}

.modernMessagesList {
  background: transparent;
}

.modernMessageItem {
  background: transparent;
  margin-bottom: var(--sapHorizon-Space-Large);
  border: none;
}

.modernMessageRow {
  align-items: flex-start;
  gap: var(--sapHorizon-Space-Medium);
}

/* User Messages */
.modernUserMessageContainer {
  margin-bottom: var(--sapHorizon-Space-Large);
}

.modernUserMessage {
  background: var(--sapHorizon-Blue-Primary);
  color: var(--sapHorizon-Neutral-100);
  padding: var(--sapHorizon-Space-Medium) var(--sapHorizon-Space-Large);
  border-radius: var(--sapHorizon-BorderRadius-Large) var(--sapHorizon-BorderRadius-Large) var(--sapHorizon-BorderRadius-Small) var(--sapHorizon-BorderRadius-Large);
  max-width: 70%;
  box-shadow: var(--sapHorizon-Shadow-Level1);
}

.modernUserMessage:hover {
  box-shadow: var(--sapHorizon-Shadow-Level2);
}

.modernUserText {
  font-size: var(--sapHorizon-FontSize-Medium);
  line-height: 1.5;
  color: var(--sapHorizon-Neutral-100) !important;
  word-wrap: break-word;
}

.modernUserTimestamp {
  font-size: var(--sapHorizon-FontSize-Small);
  color: rgba(255, 255, 255, 0.8);
  margin-top: var(--sapHorizon-Space-Tiny);
  text-align: right;
}

.modernUserAvatar {
  margin-top: 2px;
}

/* Assistant Messages */
.modernAssistantMessageContainer {
  margin-bottom: var(--sapHorizon-Space-Large);
}

.modernAssistantMessage {
  background: var(--sapHorizon-Neutral-100);
  border: 1px solid var(--sapHorizon-Neutral-300);
  padding: var(--sapHorizon-Space-Large);
  border-radius: var(--sapHorizon-BorderRadius-Large) var(--sapHorizon-BorderRadius-Large) var(--sapHorizon-BorderRadius-Large) var(--sapHorizon-BorderRadius-Small);
  max-width: 75%;
  box-shadow: var(--sapHorizon-Shadow-Level1);
  position: relative;
}

.modernAssistantMessage:hover {
  border-color: var(--sapHorizon-Blue-Primary);
  box-shadow: var(--sapHorizon-Shadow-Level2);
}

.modernAssistantMessage:hover .modernMessageActions {
  opacity: 1;
}

.modernAssistantText {
  font-size: var(--sapHorizon-FontSize-Medium);
  line-height: 1.6;
  color: var(--sapHorizon-Neutral-800) !important;
  word-wrap: break-word;
}

.modernMessageFooter {
  margin-top: var(--sapHorizon-Space-Small);
}

.modernAssistantTimestamp {
  font-size: var(--sapHorizon-FontSize-Small);
  color: var(--sapHorizon-Neutral-500);
}

.modernMessageActions {
  opacity: 0;
  transition: opacity 0.2s ease;
  gap: var(--sapHorizon-Space-Tiny);
}

.modernActionButton {
  min-width: 1.75rem;
  height: 1.75rem;
  border-radius: var(--sapHorizon-BorderRadius-Small);
  font-size: var(--sapHorizon-FontSize-Small);
  color: var(--sapHorizon-Neutral-600);
}

.modernActionButton:hover {
  background-color: var(--sapHorizon-Blue-Secondary);
  color: var(--sapHorizon-Blue-Primary);
}

.modernAssistantAvatar {
  margin-top: 2px;
}

/* System Messages */
.modernSystemMessageContainer {
  margin-bottom: var(--sapHorizon-Space-Medium);
}

.modernSystemMessage {
  background: var(--sapHorizon-Blue-Secondary);
  border: 1px solid var(--sapHorizon-Blue-Primary);
  padding: var(--sapHorizon-Space-Small) var(--sapHorizon-Space-Large);
  border-radius: var(--sapHorizon-BorderRadius-Large);
  max-width: 80%;
}

.modernSystemText {
  font-size: var(--sapHorizon-FontSize-Small);
  color: var(--sapHorizon-Blue-Accent);
  text-align: center;
  font-style: italic;
}

/* Typing Indicator */
.modernTypingContainer {
  margin-bottom: var(--sapHorizon-Space-Large);
}

.modernTypingMessage {
  background: var(--sapHorizon-Neutral-100);
  border: 1px solid var(--sapHorizon-Neutral-300);
  padding: var(--sapHorizon-Space-Large);
  border-radius: var(--sapHorizon-BorderRadius-Large) var(--sapHorizon-BorderRadius-Large) var(--sapHorizon-BorderRadius-Large) var(--sapHorizon-BorderRadius-Small);
  box-shadow: var(--sapHorizon-Shadow-Level1);
}

.modernTypingIndicator {
  display: flex;
  align-items: center;
  gap: var(--sapHorizon-Space-Tiny);
}

.modernTypingDot {
  width: 0.5rem !important;
  height: 0.5rem !important;
  border-radius: 50%;
  background-color: var(--sapHorizon-Blue-Primary);
  font-size: 0 !important;
  /* Hide any icon content */
  min-width: 0.5rem;
  min-height: 0.5rem;
}

.modernTypingDot1 {
  animation: horizonTypingBounce 1.4s infinite ease-in-out both;
  animation-delay: -0.32s;
}

.modernTypingDot2 {
  animation: horizonTypingBounce 1.4s infinite ease-in-out both;
  animation-delay: -0.16s;
}

.modernTypingDot3 {
  animation: horizonTypingBounce 1.4s infinite ease-in-out both;
}

@keyframes horizonTypingBounce {

  0%,
  80%,
  100% {
    transform: scale(0.8);
    opacity: 0.5;
  }

  40% {
    transform: scale(1);
    opacity: 1;
  }
}

.modernTypingText {
  font-size: var(--sapHorizon-FontSize-Small);
  color: var(--sapHorizon-Neutral-600);
  margin-left: var(--sapHorizon-Space-Small);
  font-style: italic;
}

/* Input Area */
.modernInputContainer {
  background: var(--sapHorizon-Neutral-100);
  border-top: 1px solid var(--sapHorizon-Neutral-300);
  padding: var(--sapHorizon-Space-Large) var(--sapHorizon-Space-XLarge);
  box-shadow: var(--sapHorizon-Shadow-Level1);
}

.modernInputRow {
  gap: var(--sapHorizon-Space-Medium);
  align-items: flex-end;
}

.modernInputWrapper {
  flex: 1;
}

.modernInputField {
  border: 1px solid var(--sapHorizon-Neutral-400);
  border-radius: var(--sapHorizon-BorderRadius-Large);
  background: var(--sapHorizon-Neutral-100);
  transition: all 0.2s ease;
  resize: none;
}

.modernInputField:focus {
  border-color: var(--sapHorizon-Blue-Primary);
  box-shadow: 0 0 0 2px var(--sapHorizon-Blue-Secondary);
}

.modernInputField:focus-within {
  border-color: var(--sapHorizon-Blue-Primary);
  box-shadow: 0 0 0 2px var(--sapHorizon-Blue-Secondary);
}

.modernInputField textarea {
  padding: var(--sapHorizon-Space-Medium) var(--sapHorizon-Space-Large) !important;
  border: none !important;
  outline: none !important;
  font-size: var(--sapHorizon-FontSize-Medium);
  line-height: 1.5;
  font-family: var(--sapHorizon-FontFamily);
  color: var(--sapHorizon-Neutral-800);
}

.modernSendButton {
  min-width: 2.5rem;
  height: 2.5rem;
  border-radius: var(--sapHorizon-BorderRadius-Large);
  background: var(--sapHorizon-Blue-Primary);
  color: var(--sapHorizon-Neutral-100);
  transition: all 0.2s ease;
}

.modernSendButton:hover {
  background: var(--sapHorizon-Blue-Accent);
  transform: scale(1.02);
}

.modernSendButton:active {
  transform: scale(0.98);
}

/* Input Footer - Minimal Design */
.modernInputFooter {
  margin-top: var(--sapHorizon-Space-Small);
  padding: var(--sapHorizon-Space-Tiny) var(--sapHorizon-Space-Small);
  background: transparent;
  border: none;
  min-height: 1.2rem;
}

.modernCharCounter {
  font-size: var(--sapHorizon-FontSize-Small);
  color: var(--sapHorizon-Warning);
  font-weight: 500;
  margin-right: var(--sapHorizon-Space-Small);
}

.modernStatusMessage {
  font-size: var(--sapHorizon-FontSize-Small);
  color: var(--sapHorizon-Neutral-500);
  font-weight: 400;
  font-style: italic;
}

/* Scrollbar Styling - SAP Horizon */
.modernChatMessagesContainer .sapMScrollCont {
  scrollbar-width: thin;
  scrollbar-color: var(--sapHorizon-Neutral-400) transparent;
}

.modernChatMessagesContainer .sapMScrollCont::-webkit-scrollbar {
  width: 6px;
}

.modernChatMessagesContainer .sapMScrollCont::-webkit-scrollbar-track {
  background: transparent;
}

.modernChatMessagesContainer .sapMScrollCont::-webkit-scrollbar-thumb {
  background-color: var(--sapHorizon-Neutral-400);
  border-radius: var(--sapHorizon-BorderRadius-Small);
}

.modernChatMessagesContainer .sapMScrollCont::-webkit-scrollbar-thumb:hover {
  background-color: var(--sapHorizon-Neutral-500);
}

/* Animations */
.modernMessageItem {
  animation: horizonFadeInUp 0.3s ease-out;
}

@keyframes horizonFadeInUp {
  from {
    opacity: 0;
    transform: translateY(10px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Focus Management for Accessibility */
.modernHeaderButton:focus,
.modernActionButton:focus,
.modernSendButton:focus {
  outline: 2px solid var(--sapHorizon-Blue-Primary);
  outline-offset: 2px;
}

/* Responsive Design */
@media (max-width: 768px) {
  .modernMessagesWrapper {
    padding: var(--sapHorizon-Space-Large);
  }

  .modernUserMessage,
  .modernAssistantMessage {
    max-width: 85%;
  }

  .modernInputContainer {
    padding: var(--sapHorizon-Space-Medium) var(--sapHorizon-Space-Large);
  }

  .modernChatHeader {
    padding: var(--sapHorizon-Space-Medium) var(--sapHorizon-Space-Large);
  }
}

/* Additional SAP Horizon Message Types */
.modernInfoMessageContainer,
.modernWarningMessageContainer {
  margin-bottom: var(--sapHorizon-Space-Medium);
}

.modernInfoMessage {
  background: var(--sapHorizon-Blue-Secondary);
  border: 1px solid var(--sapHorizon-Blue-Primary);
  padding: var(--sapHorizon-Space-Small) var(--sapHorizon-Space-Large);
  border-radius: var(--sapHorizon-BorderRadius-Medium);
  gap: var(--sapHorizon-Space-Small);
}

.modernInfoIcon {
  font-size: var(--sapHorizon-FontSize-Medium);
  color: var(--sapHorizon-Information);
}

.modernInfoText {
  font-size: var(--sapHorizon-FontSize-Small);
  color: var(--sapHorizon-Blue-Accent);
  font-weight: 500;
}

.modernWarningMessage {
  background: #FFF4E6;
  border: 1px solid var(--sapHorizon-Warning);
  padding: var(--sapHorizon-Space-Small) var(--sapHorizon-Space-Large);
  border-radius: var(--sapHorizon-BorderRadius-Medium);
  gap: var(--sapHorizon-Space-Small);
}

.modernWarningIcon {
  font-size: var(--sapHorizon-FontSize-Medium);
  color: var(--sapHorizon-Warning);
}

.modernWarningText {
  font-size: var(--sapHorizon-FontSize-Small);
  color: #8B4000;
  font-weight: 500;
}

/* =====================================================
   AI CHAT MESSAGE FORMATTING - Zusätzliche CSS Regeln
   Fügen Sie diese Regeln zu Ihrer customStyles.css hinzu
   ===================================================== */

/* AI Message Content Wrapper */
.modernAssistantText {
  font-size: var(--sapHorizon-FontSize-Medium);
  line-height: 1.6;
  color: var(--sapHorizon-Neutral-800) !important;
  word-wrap: break-word;
}

/* AI Content Typography */
.ai-paragraph {
  margin: 0 0 var(--sapHorizon-Space-Medium) 0;
  line-height: 1.6;
}

.ai-paragraph:last-child {
  margin-bottom: 0;
}

/* AI Headers */
.ai-header-1 {
  font-size: var(--sapHorizon-FontSize-XLarge);
  font-weight: 600;
  color: var(--sapHorizon-Blue-Primary);
  margin: var(--sapHorizon-Space-Large) 0 var(--sapHorizon-Space-Medium) 0;
  border-bottom: 2px solid var(--sapHorizon-Blue-Secondary);
  padding-bottom: var(--sapHorizon-Space-Tiny);
}

.ai-header-2 {
  font-size: var(--sapHorizon-FontSize-Large);
  font-weight: 600;
  color: var(--sapHorizon-Neutral-800);
  margin: var(--sapHorizon-Space-Large) 0 var(--sapHorizon-Space-Medium) 0;
}

.ai-header-3 {
  font-size: var(--sapHorizon-FontSize-Medium);
  font-weight: 600;
  color: var(--sapHorizon-Neutral-700);
  margin: var(--sapHorizon-Space-Medium) 0 var(--sapHorizon-Space-Small) 0;
}

/* AI Text Formatting */
.ai-bold {
  font-weight: 600;
  color: var(--sapHorizon-Neutral-800);
}

.ai-italic {
  font-style: italic;
  color: var(--sapHorizon-Neutral-700);
}

/* AI Code Styling */
.ai-code-block {
  background: var(--sapHorizon-Neutral-200);
  border: 1px solid var(--sapHorizon-Neutral-300);
  border-radius: var(--sapHorizon-BorderRadius-Medium);
  margin: var(--sapHorizon-Space-Medium) 0;
  overflow: hidden;
  box-shadow: var(--sapHorizon-Shadow-Level1);
}

.ai-code-header {
  background: var(--sapHorizon-Neutral-300);
  padding: var(--sapHorizon-Space-Tiny) var(--sapHorizon-Space-Medium);
  font-size: var(--sapHorizon-FontSize-Small);
  font-weight: 600;
  color: var(--sapHorizon-Neutral-700);
  border-bottom: 1px solid var(--sapHorizon-Neutral-400);
  position: relative;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.ai-copy-button {
  background: var(--sapHorizon-Blue-Primary);
  color: var(--sapHorizon-Neutral-100);
  border: none;
  padding: 4px 8px;
  border-radius: var(--sapHorizon-BorderRadius-Small);
  font-size: var(--sapHorizon-FontSize-Small);
  cursor: pointer;
  transition: all 0.2s ease;
  font-family: var(--sapHorizon-FontFamily);
}

.ai-copy-button:hover {
  background: var(--sapHorizon-Blue-Accent);
  transform: scale(1.05);
}

.ai-copy-button:active {
  transform: scale(0.95);
}

.ai-code-content {
  padding: var(--sapHorizon-Space-Medium);
  margin: 0;
  font-family: 'Courier New', Monaco, 'Lucida Console', monospace;
  font-size: var(--sapHorizon-FontSize-Small);
  line-height: 1.4;
  color: var(--sapHorizon-Neutral-800);
  background: transparent;
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow-x: auto;
}

.ai-inline-code {
  background: var(--sapHorizon-Neutral-200);
  color: var(--sapHorizon-Blue-Accent);
  padding: 2px 6px;
  border-radius: var(--sapHorizon-BorderRadius-Small);
  font-family: 'Courier New', Monaco, 'Lucida Console', monospace;
  font-size: 0.9em;
  font-weight: 500;
  border: 1px solid var(--sapHorizon-Neutral-300);
}

/* AI Lists */
.ai-unordered-list,
.ai-ordered-list {
  margin: var(--sapHorizon-Space-Medium) 0;
  padding-left: var(--sapHorizon-Space-Large);
}

.ai-unordered-list {
  list-style-type: none;
}

.ai-ordered-list {
  list-style-type: decimal;
}

.ai-list-item,
.ai-numbered-item {
  margin: var(--sapHorizon-Space-Tiny) 0;
  line-height: 1.5;
  position: relative;
}

.ai-unordered-list .ai-list-item::before {
  content: "▪";
  /* color: var(--sapHorizon-Blue-Primary); */
  font-weight: bold;
  position: absolute;
/* left: calc(-1 * var(--sapHorizon-Space-Large)); */
  left: 10px;
  font-size: 1.2em;
}

/* AI Links */
.ai-link {
  color: var(--sapHorizon-Blue-Primary);
  text-decoration: none;
  border-bottom: 1px solid transparent;
  transition: all 0.2s ease;
  cursor: pointer;
}

.ai-link:hover {
  color: var(--sapHorizon-Blue-Accent);
  border-bottom-color: var(--sapHorizon-Blue-Primary);
}

/* AI Step-by-Step Instructions */
.ai-step-header {
  background: var(--sapHorizon-Blue-Secondary);
  color: var(--sapHorizon-Blue-Accent);
  padding: var(--sapHorizon-Space-Small) var(--sapHorizon-Space-Medium);
  border-radius: var(--sapHorizon-BorderRadius-Medium);
  margin: var(--sapHorizon-Space-Medium) 0 var(--sapHorizon-Space-Small) 0;
  border-left: 4px solid var(--sapHorizon-Blue-Primary);
  font-weight: 600;
}

/* SAP-specific Terms Highlighting */
.ai-sap-term {
  background: linear-gradient(120deg, var(--sapHorizon-Blue-Secondary) 0%, var(--sapHorizon-Blue-Secondary) 100%);
  color: var(--sapHorizon-Blue-Accent);
  padding: 1px 4px;
  border-radius: var(--sapHorizon-BorderRadius-Small);
  font-weight: 500;
  border: 1px solid var(--sapHorizon-Blue-Primary);
}

/* AI Message Improvements */
.modernAssistantMessage .ai-paragraph:first-child {
  margin-top: 0;
}

.modernAssistantMessage .ai-code-block:first-child {
  margin-top: 0;
}

.modernAssistantMessage .ai-code-block:last-child {
  margin-bottom: 0;
}

/* Special AI Message Types */
.ai-info-box {
  background: var(--sapHorizon-Blue-Secondary);
  border: 1px solid var(--sapHorizon-Blue-Primary);
  border-radius: var(--sapHorizon-BorderRadius-Medium);
  padding: var(--sapHorizon-Space-Medium);
  margin: var(--sapHorizon-Space-Medium) 0;
  border-left: 4px solid var(--sapHorizon-Information);
}

.ai-warning-box {
  background: #FFF4E6;
  border: 1px solid var(--sapHorizon-Warning);
  border-radius: var(--sapHorizon-BorderRadius-Medium);
  padding: var(--sapHorizon-Space-Medium);
  margin: var(--sapHorizon-Space-Medium) 0;
  border-left: 4px solid var(--sapHorizon-Warning);
}

.ai-success-box {
  background: #F1F8E9;
  border: 1px solid var(--sapHorizon-Success);
  border-radius: var(--sapHorizon-BorderRadius-Medium);
  padding: var(--sapHorizon-Space-Medium);
  margin: var(--sapHorizon-Space-Medium) 0;
  border-left: 4px solid var(--sapHorizon-Success);
}

/* AI Message Animation Improvements */
.modernAssistantMessage .ai-code-block,
.modernAssistantMessage .ai-step-header,
.modernAssistantMessage .ai-info-box {
  animation: aiContentFadeIn 0.4s ease-out;
}

@keyframes aiContentFadeIn {
  from {
    opacity: 0;
    transform: translateY(5px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Better Scrolling for Code Blocks */
.ai-code-content::-webkit-scrollbar {
  height: 6px;
}

.ai-code-content::-webkit-scrollbar-track {
  background: var(--sapHorizon-Neutral-300);
  border-radius: var(--sapHorizon-BorderRadius-Small);
}

.ai-code-content::-webkit-scrollbar-thumb {
  background: var(--sapHorizon-Neutral-500);
  border-radius: var(--sapHorizon-BorderRadius-Small);
}

.ai-code-content::-webkit-scrollbar-thumb:hover {
  background: var(--sapHorizon-Neutral-600);
}

/* Responsive Improvements for AI Content */
@media (max-width: 768px) {
  .ai-code-block {
    margin-left: calc(-1 * var(--sapHorizon-Space-Medium));
    margin-right: calc(-1 * var(--sapHorizon-Space-Medium));
    border-radius: 0;
  }

  .ai-code-content {
    font-size: var(--sapHorizon-FontSize-Small);
  }

  .ai-step-header {
    margin-left: calc(-1 * var(--sapHorizon-Space-Small));
    margin-right: calc(-1 * var(--sapHorizon-Space-Small));
  }
}

/* Focus States for Accessibility */
.ai-link:focus {
  outline: 2px solid var(--sapHorizon-Blue-Primary);
  outline-offset: 2px;
  border-radius: var(--sapHorizon-BorderRadius-Small);
}

/* Print Styles for AI Content */
@media print {
  .ai-code-block {
    border: 1px solid #000;
    background: #f5f5f5;
  }

  .ai-code-header {
    background: #e0e0e0;
    border-bottom: 1px solid #000;
  }

  .ai-link {
    color: #000;
    text-decoration: underline;
  }

  .ai-link::after {
    content: " (" attr(data-url) ")";
    font-size: 0.8em;
    color: #666;
  }
}

/* Mention Popover */
.cpMentionPopover {
  max-width: 28rem;
  padding: 0;
}

.cpMentionPopover .sapMList {
  max-height: 16rem;
  overflow-y: auto;
}

.cpMentionPopover .sapMLIB {
  padding: 0.6rem 0.85rem;
  align-items: flex-start;
}

.cpMentionPopover .cpMentionItem {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.cpMentionPopover .cpMentionItemText {
  white-space: normal;
  display: block;
  font-size: 0.95rem;
  line-height: 1.35;
}

.cpMentionPopover .sapMLIB.sapMLIBSelected {
  background-color: var(--sapList_SelectionBackgroundColor);
}
</file>

<file path="app/webapp/manifest.json">
{
  "_version": "1.65.0",
  "sap.app": {
    "id": "sap.stammtisch.ui.app",
    "type": "application",
    "i18n": "i18n/i18n.properties",
    "applicationVersion": { "version": "0.0.1" },
    "title": "{{appTitle}}",
    "description": "{{appDescription}}",
    "resources": "resources.json",
    "sourceTemplate": {
      "id": "@sap/generator-fiori:lrop",
      "version": "1.17.5",
      "toolsId": "2418c640-e786-47b9-ad94-903960b6e258"
    },
    "dataSources": {
      "mainService": {
        "uri": "/service/stammtisch/",
        "type": "OData",
        "settings": {
          "annotations": [],
          "odataVersion": "4.0"
        }
      }
    }
  },
  "sap.ui": {
    "technology": "UI5",
    "icons": { "icon": "", "favIcon": "", "phone": "", "phone@2": "", "tablet": "", "tablet@2": "" },
    "deviceTypes": { "desktop": true, "tablet": true, "phone": true }
  },
  "sap.ui5": {
    "flexEnabled": true,
    "dependencies": {
      "minUI5Version": "1.120.0",
      "libs": { "sap.m": {}, "sap.ui.core": {}, "sap.ui.layout": {}, "sap.fe.templates": {} }
    },
    "contentDensities": { "compact": true, "cozy": true },
    "models": {
      "i18n": {
        "type": "sap.ui.model.resource.ResourceModel",
        "settings": { "bundleName": "sap.stammtisch.ui.app.i18n.i18n" }
      },
      "": {
        "dataSource": "mainService",
        "preload": true,
        "settings": {
          "operationMode": "Server",
          "autoExpandSelect": true,
          "earlyRequests": true
        }
      },
      "@i18n": {
        "type": "sap.ui.model.resource.ResourceModel",
        "uri": "i18n/i18n.properties"
      }
    },
    "resources": { "css": [{ "uri": "css/customStyles.css" }] },
    "routing": {
      "config": {},
      "routes": [
        {
          "pattern": ":?query:",
          "name": "StammtischeList",
          "target": "StammtischeList",
          "level": 1
        },
        {
          "pattern": "Stammtische({key}):?query:",
          "name": "StammtischeObjectPage",
          "target": "StammtischeObjectPage",
          "level": 1
        },
        {
          "pattern": "Stammtische({key})/teilnehmer({key2}):?query:",
          "name": "TeilnehmerObjectPage",
          "target": "TeilnehmerObjectPage",
          "level": 1
        },
        {
          "pattern": "Praesentatoren:?query:",
          "name": "PraesentatorenList",
          "target": "PraesentatorenList",
          "level": 1
        },
        {
          "pattern": "Praesentatoren({key}):?query:",
          "name": "PraesentatorenObjectPage",
          "target": "PraesentatorenObjectPage",
          "level": 1
        },
        {
          "pattern": "Praesentatoren({key})/stammtische({stammtischKey}):?query:",
          "name": "PraesentatorToStammtischObjectPage",
          "target": "StammtischeObjectPage",
          "level": 1
        }
      ],
      "targets": {
        "StammtischeList": {
          "type": "Component",
          "id": "StammtischeList",
          "name": "sap.fe.templates.ListReport",
          "options": {
            "settings": {
              "contextPath": "/Stammtische",
              "variantManagement": "Page",
              "navigation": {
                "Stammtische": { "detail": { "route": "StammtischeObjectPage" } }
              },
              "controlConfiguration": {
                "@com.sap.vocabularies.UI.v1.LineItem": {
                  "tableSettings": { "type": "ResponsiveTable" }
                }
              }
            }
          },
          "extends": {
            "controller": {
              "name": "sap.stammtisch.ui.app.ext.CustomActions",
              "namespace": "sap.stammtisch.ui.app.ext"
            }
          }
        },
        "StammtischeObjectPage": {
          "type": "Component",
          "id": "StammtischeObjectPage",
          "name": "sap.fe.templates.ObjectPage",
          "options": {
            "settings": {
              "editableHeaderContent": false,
              "contextPath": "/Stammtische",
              "navigation": {
                "teilnehmer": { "detail": { "route": "TeilnehmerObjectPage" } }
              },
              "actions": {
                "AIChatActionStammtischOP": {
                  "press": "sap.stammtisch.ui.app.ext.CustomActions.onToggleChatSidePanel",
                  "text": "{{btnTextAIChat}}",
                  "visible": true,
                  "enabled": true,
                  "requiresSelection": false
                }
              }
            }
          },
          "extends": {
            "controller": {
              "name": "sap.stammtisch.ui.app.ext.CustomActions",
              "namespace": "sap.stammtisch.ui.app.ext"
            }
          }
        },
        "TeilnehmerObjectPage": {
          "type": "Component",
          "id": "TeilnehmerObjectPage",
          "name": "sap.fe.templates.ObjectPage",
          "options": {
            "settings": {
              "editableHeaderContent": false,
              "contextPath": "/Stammtische/teilnehmer",
              "actions": {
                "AIChatActionTeilnehmerOP": {
                  "press": "sap.stammtisch.ui.app.ext.CustomActions.onOpenAIChatDialog",
                  "text": "{{btnTextAIChat}}",
                  "visible": true,
                  "enabled": true,
                  "requiresSelection": false
                }
              }
            }
          },
          "extends": {
            "controller": {
              "name": "sap.stammtisch.ui.app.ext.CustomActions",
              "namespace": "sap.stammtisch.ui.app.ext"
            }
          }
        },
        "PraesentatorenList": {
          "type": "Component",
          "id": "PraesentatorenList",
          "name": "sap.fe.templates.ListReport",
          "options": {
            "settings": {
              "contextPath": "/Praesentatoren",
              "variantManagement": "Page",
              "navigation": {
                "Praesentatoren": { "detail": { "route": "PraesentatorenObjectPage" } }
              },
              "controlConfiguration": {
                "@com.sap.vocabularies.UI.v1.LineItem": {
                  "tableSettings": { "type": "ResponsiveTable" }
                }
              }
            }
          }
        },
        "PraesentatorenObjectPage": {
          "type": "Component",
          "id": "PraesentatorenObjectPage",
          "name": "sap.fe.templates.ObjectPage",
          "options": {
            "settings": {
              "editableHeaderContent": false,
              "contextPath": "/Praesentatoren",
              "navigation": {
                "stammtische": { "detail": { "route": "StammtischeObjectPage" } }
              }
            }
          }
        }
      }
    }
  },
  "sap.fiori": { "registrationIds": [], "archeType": "transactional" }
}
</file>

<file path="srv/m365-mcp/tools/index.js">
// srv/m365-mcp/tools/index.js
// Registry of tool handlers exposed by the Microsoft 365 MCP client.

import { handleMailLatestMessage, handleMailAttachmentDownload, handleMailMessagesList, handleMailMessageReply } from './mail.js';
import { handleCalendarEventsList, handleCalendarEventCreate } from './calendar.js';

const handlers = {
  'mail.latestMessage.get': handleMailLatestMessage,
  'mail.attachment.download': handleMailAttachmentDownload,
  'mail.messages.list': handleMailMessagesList,
  'mail.message.reply': handleMailMessageReply,
  'calendar.events.list': handleCalendarEventsList,
  'calendar.event.create': handleCalendarEventCreate
};

export function getToolHandler(name) {
  return handlers[name] || null;
}

export function listSupportedTools() {
  return Object.keys(handlers);
}
</file>

<file path="srv/service.cds">
using { sap.stammtisch as StammtischModel } from '../db/schema';
using from '../app/annotations'; 

service StammtischService @(path: '/service/stammtisch') { 

    @odata.draft.enabled // Aktiviere Draft-Modus für diese Entität
    entity Stammtische as projection on StammtischModel.Stammtische {
        *,
        // Navigation Properties explizit exponieren
        praesentator : redirected to Praesentatoren,
        teilnehmer : redirected to Teilnehmer
    };

    entity Praesentatoren as projection on StammtischModel.Praesentatoren {
        *,
        stammtische : redirected to Stammtische
    };
    
    entity Teilnehmer as projection on StammtischModel.Teilnehmer {
        *,
        stammtisch : redirected to Stammtische
    };

    action callLLM (prompt: String) returns { response: String };

}
</file>

<file path="srv/m365-mcp/graph-client.js">
// srv/m365-mcp/graph-client.js
// Thin wrapper around the Microsoft Graph API using the m365 CLI for authentication.

import { execFile } from 'node:child_process';
import { promisify } from 'node:util';
import { setTimeout as delay } from 'node:timers/promises';
import { existsSync } from 'node:fs';
import { mkdir, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { safeJson } from './helpers/logging.js';

const execFileAsync = promisify(execFile);
const GRAPH_RESOURCE = 'https://graph.microsoft.com';
const GRAPH_BASE_URL = `${GRAPH_RESOURCE}/v1.0`;
const DEFAULT_TOKEN_TTL_MS = 5 * 60 * 1000;

export class GraphClient {
  constructor(options = {}) {
    const {
      authMethod = process.env.M365_AUTH_METHOD || 'cli',
      cliCommand = process.env.M365_CLI_COMMAND || 'm365',
      logger = console,
      tokenTtlMs = DEFAULT_TOKEN_TTL_MS
    } = options;

    this.authMethod = authMethod;
    this.cliCommand = cliCommand;
    this.logger = logger;
    this.tokenTtlMs = tokenTtlMs;
    this.tokenCache = new Map();
    this.closed = false;
    this.scopesOptionSupported = true;
  }

  async bootstrap(scopes = ['Mail.Read']) {
    this.logger.log('Initializing Microsoft 365 in-process MCP client...');
    try {
      await this.getAccessToken(scopes);
      this.logger.log('✅ Microsoft 365 MCP client initialized successfully.');
    } catch (error) {
      this.logger.error('❌ Failed to initialize Microsoft 365 MCP client:', error.message);
      throw error;
    }
  }

  async getAccessToken(scopes = []) {
    if (this.closed) {
      throw new Error('GraphClient is closed');
    }
    if (this.authMethod !== 'cli') {
      throw new Error(`Unsupported M365 auth method: ${this.authMethod}`);
    }

    const normalizedScopes = Array.isArray(scopes) ? [...scopes].sort() : [];
    const cacheKey = normalizedScopes.join(' ');
    const cached = this.tokenCache.get(cacheKey);
    if (cached && cached.expiresAt > Date.now()) {
      return cached.token;
    }

    const cliArgs = ['util', 'accesstoken', 'get', '--resource', GRAPH_RESOURCE];
    if (normalizedScopes.length && this.scopesOptionSupported) {
      cliArgs.push('--scope', normalizedScopes.join(','));
    }

    try {
      const execOptions = {
        env: process.env,
        maxBuffer: 1024 * 1024
      };

      // Windows: .cmd/.bat require a shell wrapper, otherwise spawn() raises EINVAL.
      if (process.platform === 'win32') {
        const lower = this.cliCommand.toLowerCase();
        if (lower.endsWith('.cmd') || lower.endsWith('.bat')) {
          execOptions.shell = process.env.ComSpec || 'cmd.exe';
        }
      }

      const { stdout } = await execFileAsync(this.cliCommand, cliArgs, execOptions);
      const token = stdout.trim();
      if (!token) {
        throw new Error('m365 CLI returned an empty access token. Ensure you are logged in with "m365 login".');
      }
      this.tokenCache.set(cacheKey, {
        token,
        expiresAt: Date.now() + this.tokenTtlMs
      });
      return token;
    } catch (error) {
      const errorMessage = String(error.stderr || error.message || error);
      if (normalizedScopes.length && this.scopesOptionSupported && /Invalid option: 'scopes?'/.test(errorMessage)) {
        this.logger.warn?.('m365 CLI does not support the --scope option. Falling back to default Graph scopes.');
        this.scopesOptionSupported = false;
        return this.getAccessToken([]);
      }
      if (error.code === 'ENOENT') {
        throw new Error(`Could not find the m365 CLI (${this.cliCommand}). Install it via "npm i -g @pnp/cli-microsoft365".`);
      }
      throw new Error(`Failed to acquire Microsoft Graph token via m365 CLI: ${error.message}`);
    }
  }

  async request(method, relativePath, { query = {}, headers = {}, body, scopes = [] } = {}) {
    if (this.closed) {
      throw new Error('GraphClient is closed');
    }

    const url = new URL(relativePath.replace(/^\//, ''), `${GRAPH_BASE_URL}/`);
    Object.entries(query)
      .filter(([, value]) => value !== undefined && value !== null && value !== '')
      .forEach(([key, value]) => {
        url.searchParams.append(key, value);
      });

    const accessToken = await this.getAccessToken(scopes);
    const baseHeaders = {
      Authorization: `Bearer ${accessToken}`,
      Accept: 'application/json'
    };

    const options = {
      method,
      headers: { ...baseHeaders, ...headers }
    };

    if (body !== undefined) {
      options.body = typeof body === 'string' ? body : JSON.stringify(body);
      options.headers['Content-Type'] = 'application/json';
    }

    // this.logger.debug?.(`Graph request ${method} ${url} with body ${safeJson(body)}`);

    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`Graph request failed (${response.status} ${response.statusText}): ${errorBody}`);
    }
    const contentType = response.headers.get('content-type') || '';
    if (contentType.includes('application/json')) {
      return await response.json();
    }
    return Buffer.from(await response.arrayBuffer());
  }

  async getLatestMessage({ folderId = 'inbox' } = {}) {
    const data = await this.request(
      'GET',
      `/me/mailFolders/${encodeURIComponent(folderId)}/messages`,
      {
        query: {
          '$top': '1',
          '$orderby': 'receivedDateTime desc',
          '$select': 'id,subject,from,toRecipients,receivedDateTime,hasAttachments,bodyPreview,body,isRead,webLink',
          '$expand': 'attachments($select=id,name,contentType,size,isInline)'
        },
        scopes: ['Mail.Read']
      }
    );
    const message = Array.isArray(data.value) && data.value.length ? data.value[0] : null;
    if (!message) {
      return null;
    }
    return {
      id: message.id,
      subject: message.subject,
      from: message.from?.emailAddress || null,
      toRecipients: (message.toRecipients || []).map((entry) => entry.emailAddress),
      receivedDateTime: message.receivedDateTime,
      isRead: Boolean(message.isRead),
      webLink: message.webLink,
      hasAttachments: Boolean(message.hasAttachments),
      bodyPreview: message.bodyPreview || null,
      body: message.body
        ? {
            contentType: message.body.contentType,
            content: message.body.content
          }
        : null,
      attachments: Array.isArray(message.attachments)
        ? message.attachments.map((attachment) => ({
            id: attachment.id,
            name: attachment.name,
            contentType: attachment.contentType,
            size: attachment.size,
            isInline: attachment.isInline
          }))
        : []
    };
  }

  async replyToMessage({
    messageId,
    comment = '',
    body,
    contentType = 'Text',
    replyAll = false
  } = {}) {
    if (!messageId) {
      throw new Error('messageId is required to reply to a mail.');
    }

    const normalizedType = (contentType || 'Text').toUpperCase() === 'HTML' ? 'HTML' : 'Text';
    const payload = {
      comment: comment ?? ''
    };

    if (body) {
      payload.message = {
        body: {
          contentType: normalizedType,
          content: body
        }
      };
    }

    const endpoint = replyAll
      ? `/me/messages/${encodeURIComponent(messageId)}/replyAll`
      : `/me/messages/${encodeURIComponent(messageId)}/reply`;

    await this.request('POST', endpoint, {
      body: payload,
      scopes: ['Mail.Send']
    });

    return {
      status: 'sent',
      replyAll: Boolean(replyAll)
    };
  }

  async downloadAttachment({ messageId, attachmentId, targetPath }) {
    if (!messageId || !attachmentId || !targetPath) {
      throw new Error('messageId, attachmentId and targetPath are required for attachment download.');
    }

    let resolvedTargetPath = targetPath;
    const baseDirectory = process.env.M365_ATTACHMENT_BASE_PATH;
    if (!path.isAbsolute(resolvedTargetPath)) {
      if (baseDirectory) {
        resolvedTargetPath = path.resolve(baseDirectory, resolvedTargetPath);
      } else {
        resolvedTargetPath = path.resolve(resolvedTargetPath);
      }
    }

    const attachmentBinary = await this.request(
      'GET',
      `/me/messages/${encodeURIComponent(messageId)}/attachments/${encodeURIComponent(attachmentId)}/$value`,
      {
        scopes: ['Mail.Read'],
        headers: {
          Accept: 'application/octet-stream'
        }
      }
    );

    const directory = path.dirname(resolvedTargetPath);
    if (!existsSync(directory)) {
      await mkdir(directory, { recursive: true });
    }

    await writeFile(resolvedTargetPath, attachmentBinary);

    const bytesWritten = typeof attachmentBinary.length === 'number'
      ? attachmentBinary.length
      : (attachmentBinary.byteLength || 0);

    return {
      messageId,
      attachmentId,
      targetPath: resolvedTargetPath,
      bytesWritten
    };
  }

  async listMessages({ folderId = 'inbox', startDateTime, endDateTime, maxResults = 20, onlyUnread = false } = {}) {
    const safeTop = Number.isInteger(maxResults)
      ? Math.min(Math.max(maxResults, 1), 200)
      : 20;

    const filterParts = [];
    if (startDateTime) {
      filterParts.push(`receivedDateTime ge ${startDateTime}`);
    }
    if (endDateTime) {
      filterParts.push(`receivedDateTime le ${endDateTime}`);
    }
    if (onlyUnread) {
      filterParts.push('isRead eq false');
    }

    const query = {
      '$orderby': 'receivedDateTime desc',
      '$top': String(safeTop),
      '$select': 'id,subject,from,toRecipients,receivedDateTime,hasAttachments,bodyPreview,body,isRead,webLink',
      '$expand': 'attachments($select=id,name,contentType,size,isInline)'
    };

    if (filterParts.length) {
      query['$filter'] = filterParts.join(' and ');
    }

    const data = await this.request(
      'GET',
      `/me/mailFolders/${encodeURIComponent(folderId)}/messages`,
      {
        query,
        scopes: ['Mail.Read']
      }
    );

    return (data.value || []).map((message) => ({
      id: message.id,
      subject: message.subject,
      from: message.from?.emailAddress || null,
      toRecipients: (message.toRecipients || []).map((entry) => entry.emailAddress),
      receivedDateTime: message.receivedDateTime,
      isRead: Boolean(message.isRead),
      webLink: message.webLink,
      hasAttachments: Boolean(message.hasAttachments),
      bodyPreview: message.bodyPreview || null,
      attachments: Array.isArray(message.attachments)
        ? message.attachments.map((attachment) => ({
            id: attachment.id,
            name: attachment.name,
            contentType: attachment.contentType,
            size: attachment.size,
            isInline: attachment.isInline
          }))
        : []
    }));
  }

  async listUnreadMessages({ folderId = 'inbox', maxResults = 20 } = {}) {
    return this.listMessages({ folderId, maxResults, onlyUnread: true });
  }

  async markMessageRead(messageId, isRead = true) {
    if (!messageId) throw new Error('messageId is required');
    const body = { isRead: Boolean(isRead) };
    await this.request(
      'PATCH',
      `/me/messages/${encodeURIComponent(messageId)}`,
      { body, scopes: ['Mail.ReadWrite'] }
    );
    return { id: messageId, isRead: Boolean(isRead) };
  }

  async listCalendarEvents({ startDateTime, endDateTime }) {
    if (!startDateTime || !endDateTime) {
      throw new Error('startDateTime and endDateTime are required to list events.');
    }

    const data = await this.request(
      'GET',
      '/me/calendarView',
      {
        query: {
          startDateTime,
          endDateTime,
          '$orderby': 'start/dateTime asc'
        },
        scopes: ['Calendars.Read']
      }
    );

    return (data.value || []).map((event) => ({
      id: event.id,
      subject: event.subject,
      start: event.start,
      end: event.end,
      location: event.location,
      organizer: event.organizer
    }));
  }

  async close() {
    this.closed = true;
    this.tokenCache.clear();
    // Give pending CLI processes a moment to settle; mainly relevant for unit tests.
    await delay(10);
  }

  async createCalendarEvent({
    subject,
    body,
    contentType = 'Text',
    startDateTime,
    endDateTime,
    timezone = 'UTC',
    attendees = [],
    teams = false,
    location,
    reminderMinutesBeforeStart,
    allowNewTimeProposals,
    isOnlineMeeting,
    onlineMeetingProvider
  } = {}) {
    if (!subject) {
      throw new Error('subject is required to create an event.');
    }
    if (!startDateTime || !endDateTime) {
      throw new Error('startDateTime and endDateTime are required.');
    }

    const normalizedContentType = (contentType || 'Text').toUpperCase() === 'HTML' ? 'HTML' : 'Text';
    const attendeeArray = Array.isArray(attendees) ? attendees : [];

    const eventPayload = {
      subject,
      start: {
        dateTime: startDateTime,
        timeZone: timezone || 'UTC'
      },
      end: {
        dateTime: endDateTime,
        timeZone: timezone || 'UTC'
      },
      attendees: attendeeArray
        .map((entry) => {
          if (!entry) return null;
          if (typeof entry === 'string') {
            return {
              emailAddress: {
                address: entry
              },
              type: 'required'
            };
          }
          const address = entry.address || entry.email || entry.mail || entry.emailAddress;
          if (!address) return null;
          return {
            emailAddress: {
              address,
              name: entry.name || entry.displayName || undefined
            },
            type: entry.type || 'required'
          };
        })
        .filter(Boolean)
    };

    if (body) {
      eventPayload.body = {
        contentType: normalizedContentType,
        content: body
      };
    }

    if (location) {
      eventPayload.location = typeof location === 'string'
        ? { displayName: location }
        : location;
    }

    if (typeof reminderMinutesBeforeStart === 'number') {
      eventPayload.reminderMinutesBeforeStart = reminderMinutesBeforeStart;
    }

    if (typeof allowNewTimeProposals === 'boolean') {
      eventPayload.allowNewTimeProposals = allowNewTimeProposals;
    }

    if (typeof isOnlineMeeting === 'boolean') {
      eventPayload.isOnlineMeeting = isOnlineMeeting;
    }

    if (onlineMeetingProvider) {
      eventPayload.onlineMeetingProvider = onlineMeetingProvider;
    }

    if (teams) {
      eventPayload.isOnlineMeeting = true;
      eventPayload.onlineMeetingProvider = 'teamsForBusiness';
    }

    const response = await this.request('POST', '/me/events', {
      body: eventPayload,
      scopes: ['Calendars.ReadWrite']
    });

    return response;
  }
}
</file>

<file path="srv/m365-mcp/mcp-tool-manifest.js">
// srv/m365-mcp/mcp-tool-manifest.js
// Describes the tool surface exposed by the Microsoft 365 in-process MCP client.

const manifestVersion = '0.1.0';

function clone(value) {
  return JSON.parse(JSON.stringify(value));
}

export const toolDefinitions = [
  {
    name: 'mail.latestMessage.get',
    description: 'Liest deterministisch die neueste Nachricht aus einem Mailordner und liefert Metadaten.',
    inputSchema: {
      type: 'object',
      properties: {
        folderId: {
          type: 'string',
          description: 'ID oder bekannter Name des Zielordners, z. B. inbox.',
          default: 'inbox'
        }
      }
    },
    metadata: { scopes: ['Mail.Read'] }
  },
  {
    name: 'mail.messages.list',
    description: 'Listet eingegangene Nachrichten eines Ordners, optional gefiltert nach Zeitraum und Limit.',
    inputSchema: {
      type: 'object',
      properties: {
        folderId: {
          type: 'string',
          description: 'ID oder bekannter Name des Mailordners (z. B. inbox).',
          default: 'inbox'
        },
        startDateTime: {
          type: 'string',
          description: 'ISO-8601 Zeitpunkt. Filtert Nachrichten mit Empfangszeit >= startDateTime.'
        },
        endDateTime: {
          type: 'string',
          description: 'ISO-8601 Zeitpunkt. Filtert Nachrichten mit Empfangszeit <= endDateTime.'
        },
        maxResults: {
          type: 'integer',
          minimum: 1,
          maximum: 200,
          default: 20,
          description: 'Begrenzt die Anzahl der zurückgegebenen Nachrichten (1-200). Standard: 20.'
        }
      }
    },
    metadata: { scopes: ['Mail.Read'] }
  },
  {
    name: 'mail.attachment.download',
    description: 'Lädt einen bestimmten Anhang einer Nachricht und speichert ihn deterministisch im Zielpfad.',
    inputSchema: {
      type: 'object',
      required: ['messageId', 'attachmentId', 'targetPath'],
      properties: {
        messageId: { type: 'string', description: 'ID der Nachricht.' },
        attachmentId: { type: 'string', description: 'ID des Anhangs.' },
        targetPath: {
          type: 'string',
          description: 'Absoluter Ablageort für den heruntergeladenen Anhang.'
        }
    }
    },
    metadata: { scopes: ['Mail.Read'] }
  },
  {
    name: 'mail.message.reply',
    description: 'Antwortet auf eine vorhandene Nachricht (wahlweise Reply-All) mit Text oder HTML-Inhalt.',
    inputSchema: {
      type: 'object',
      required: ['messageId'],
      properties: {
        messageId: {
          type: 'string',
          description: 'ID der Nachricht, auf die geantwortet werden soll.'
        },
        comment: {
          type: 'string',
          description: 'Optionaler Kommentar, der oberhalb des Antworttexts eingefügt wird (Plain Text).'
        },
        body: {
          type: 'string',
          description: 'Optionaler kompletter Antworttext. Wird entsprechend contentType als Text oder HTML interpretiert.'
        },
        contentType: {
          type: 'string',
          description: 'Legt fest, ob der Body als Text oder HTML interpretiert wird.',
          enum: ['Text', 'HTML'],
          default: 'Text'
        },
        replyAll: {
          type: 'boolean',
          description: 'true, um „Allen antworten“ zu verwenden. Standard: false.'
        }
      }
    },
    metadata: { scopes: ['Mail.Send'] }
  },
  {
    name: 'calendar.events.list',
    description: 'Listet Kalenderereignisse in einem Zeitraum mit deterministischer Filterung.',
    inputSchema: {
      type: 'object',
      required: ['startDateTime', 'endDateTime'],
      properties: {
        startDateTime: { type: 'string', description: 'ISO-8601 Startzeitpunkt.' },
        endDateTime: { type: 'string', description: 'ISO-8601 Endzeitpunkt.' }
      }
    },
    metadata: { scopes: ['Calendars.Read'] }
  },
  {
    name: 'calendar.event.create',
    description: 'Erstellt einen neuen Kalendereintrag und kann optional ein Microsoft Teams Online-Meeting anlegen.',
    inputSchema: {
      type: 'object',
      required: ['subject', 'startDateTime', 'endDateTime'],
      properties: {
        subject: {
          type: 'string',
          description: 'Betreff des Termins.'
        },
        body: {
          type: 'string',
          description: 'Beschreibung des Termins. Wird gemäß contentType interpretiert.'
        },
        contentType: {
          type: 'string',
          enum: ['Text', 'HTML'],
          default: 'Text',
          description: 'Legt fest, ob die Beschreibung als Text oder HTML versendet wird.'
        },
        startDateTime: {
          type: 'string',
          description: 'Startzeit im ISO-8601 Format (z. B. 2024-09-01T09:00:00).'
        },
        endDateTime: {
          type: 'string',
          description: 'Endzeit im ISO-8601 Format.'
        },
        timezone: {
          type: 'string',
          description: 'Zeitzone für Start/Ende, z. B. Europe/Berlin. Standard: UTC.'
        },
        attendees: {
          type: 'array',
          description: 'Liste von Empfängern (E-Mail-Adressen als Strings).',
          items: {
            type: 'string'
          }
        },
        location: {
          description: 'Optionaler Ort (String oder Graph Location Objekt).',
          anyOf: [
            { type: 'string' },
            { type: 'object' }
          ]
        },
        reminderMinutesBeforeStart: {
          type: 'integer',
          description: 'Reminder in Minuten vor dem Start.'
        },
        allowNewTimeProposals: {
          type: 'boolean',
          description: 'Ob Teilnehmer neue Zeiten vorschlagen dürfen.'
        },
        isOnlineMeeting: {
          type: 'boolean',
          description: 'Setzt ein Online-Meeting ohne Provider-Auswahl.'
        },
        onlineMeetingProvider: {
          type: 'string',
          description: 'Optionaler Provider (z. B. teamsForBusiness).'
        },
        teams: {
          type: 'boolean',
          description: 'true, um automatisch ein Teams-Meeting zu erzeugen.'
        }
      }
    },
    metadata: { scopes: ['Calendars.ReadWrite'] }
  }
  // Weitere Tools aus dem PoC können hier ergänzt werden.
];

export function createM365ToolManifest() {
  return {
    namespace: 'm365',
    version: manifestVersion,
    tools: toolDefinitions.map(clone)
  };
}
</file>

<file path="app/webapp/ext/ChatSidePanelContent.fragment.xml">
<core:FragmentDefinition
    xmlns="sap.m"
    xmlns:core="sap.ui.core"
    xmlns:l="sap.ui.layout"
    xmlns:f="sap.f">
    
    <VBox height="100%" class="modernChatContainer">
        <!-- SAP Horizon Chat Header -->
        <dependents>
            <Popover
                id="mentionPopover"
                class="cpMentionPopover"
                placement="Auto"
                showHeader="false"
                showArrow="false"
                contentWidth="28rem"
                horizontalScrolling="false"
                afterClose="onMentionPopoverClosed">
                <List
                    id="mentionList"
                    mode="SingleSelectMaster"
                    includeItemInSelection="true"
                    showSeparators="None"
                    itemPress="onMentionListItemPress"
                    items="{chat>/suggestions}">
                    <items>
                        <CustomListItem type="Active" press="onMentionItemPress">
                            <VBox width="100%" class="cpMentionItem">
                                <Text text="{chat>text}" wrapping="true" class="cpMentionItemText"/>
                            </VBox>
                        </CustomListItem>
                    </items>
                </List>
            </Popover>
        </dependents>

        <HBox class="modernChatHeader" justifyContent="SpaceBetween" alignItems="Center">
            <HBox alignItems="Center">
                <core:Icon src="sap-icon://discussion-2" class="modernHeaderIcon"/>
                <VBox class="sapUiTinyMarginBegin">
                    <Title text="PureAI Agent" level="H5" class="modernHeaderTitle"/>
                </VBox>
            </HBox>
            <HBox>
                <Button
                    id="notificationsButton"
                    icon="{= ${notifications>/hasNew} ? 'sap-icon://email' : 'sap-icon://email-read' }"
                    type="{= ${notifications>/hasNew} ? 'Emphasized' : 'Transparent' }"
                    tooltip="Ungelesene Mails"
                    text="{= ${notifications>/unreadCount} ? ${notifications>/unreadCount} : '' }"
                    press="onToggleNotifications"
                    ariaLabel="Ungelesene Mails anzeigen"/>
                <Button 
                    icon="sap-icon://restart" 
                    type="Transparent" 
                    tooltip="Neuer Chat"
                    press="onClearChatHistory"
                    class="modernHeaderButton"
                    ariaLabel="Neuen Chat starten"/>
                <Button 
                    icon="sap-icon://action-settings" 
                    type="Transparent" 
                    tooltip="Einstellungen"
                    class="modernHeaderButton"
                    ariaLabel="Einstellungen öffnen"/>
            </HBox>
        </HBox>

        <!-- Notifications Popover -->
        <Popover id="notificationsPopover" placement="Bottom" contentWidth="420px" title="Neue E-Mails">
            <List id="notificationsList" items="{notifications>/items}" showSeparators="Inner">
                <CustomListItem>
                    <content>
                        <VBox class="sapUiSmallMargin">
                            <HBox justifyContent="SpaceBetween" alignItems="Center">
                                <Link text="{notifications>subject}" press="onOpenNotificationLink" wrapping="true"/>
                                <Text text="{notifications>receivedLabel}"/>
                            </HBox>
                            <ObjectStatus text="{notifications>category}" state="{notifications>categoryState}" visible="{= !!${notifications>category} }" class="sapUiTinyMarginTop"/>
                            <HBox alignItems="Center" justifyContent="SpaceBetween">
                                <Text text="{notifications>summary}" wrapping="true" renderWhitespace="true">
                                    <layoutData>
                                        <FlexItemData growFactor="1"/>
                                    </layoutData>
                                </Text>
                                <core:Icon src="sap-icon://attachment" visible="{notifications>hasAttachments}" class="sapUiTinyMarginBegin" tooltip="Anhang vorhanden"/>
                            </HBox>
                            <Text text="{notifications>fromDisplay}"/>
                            <HBox justifyContent="End" class="sapUiTinyMarginTop">
                                <Button text="An Agent senden" type="Emphasized" press="onSendNotificationToAgent"/>
                                <Button text="Schließen" type="Transparent" press="onCloseNotification"/>
                                <!--
                                    Button für künftiges „Als gelesen“ vorerst deaktiviert.
                                    <Button text="Als gelesen" type="Transparent" press="onMarkNotificationRead"/>
                                -->
                            </HBox>
                        </VBox>
                    </content>
                </CustomListItem>
            </List>
        </Popover>

        <!-- Chat Messages Area -->
        <ScrollContainer 
            id="chatHistoryScrollContainerInSidePanel"
            height="100%" 
            vertical="true" 
            horizontal="false"
            class="modernChatMessagesContainer">
            
            <VBox class="modernMessagesWrapper">
                <!-- Chat Messages List -->
                <List 
                    id="chatMessagesList"
                    items="{chat>/chatHistory}"
                    showSeparators="None"
                    mode="None"
                    showNoData="false"
                    class="modernMessagesList">
                    
                    <CustomListItem class="modernMessageItem">
                        <content>
                            <!-- User Message -->
                            <VBox visible="{= ${chat>type} === 'user' }" class="modernUserMessageContainer">
                                <HBox justifyContent="End" class="modernMessageRow">
                                    <VBox class="modernUserMessage">
                                        <FormattedText htmlText="{chat>text}" class="modernMessageText modernUserText"/>
                                        <Text text="{chat>timestamp}" class="modernTimestamp modernUserTimestamp"/>
                                    </VBox>
                                </HBox>
                            </VBox>
                            
                            <!-- Assistant Message -->
                            <VBox visible="{= ${chat>type} === 'assistant' }" class="modernAssistantMessageContainer">
                                <HBox justifyContent="Start" class="modernMessageRow">
                                    <VBox class="modernAssistantMessage">
                                        <FormattedText htmlText="{chat>text}" class="modernMessageText modernAssistantText"/>
                                        <HBox justifyContent="SpaceBetween" alignItems="Center" class="modernMessageFooter">
                                            <Text text="{chat>timestamp}" class="modernTimestamp modernAssistantTimestamp"/>
                                            <HBox class="modernMessageActions" visible="{= ${chat>text} !== 'Thinking...' }">
                                                <Button 
                                                    icon="sap-icon://copy" 
                                                    type="Transparent" 
                                                    tooltip="Kopieren"
                                                    press="onCopyMessage"
                                                    class="modernActionButton"
                                                    ariaLabel="Nachricht kopieren"/>
                                                <Button 
                                                    icon="sap-icon://thumb-up" 
                                                    type="Transparent" 
                                                    tooltip="Gefällt mir"
                                                    class="modernActionButton"
                                                    ariaLabel="Positive Bewertung"/>
                                                <Button 
                                                    icon="sap-icon://thumb-down" 
                                                    type="Transparent" 
                                                    tooltip="Gefällt mir nicht"
                                                    class="modernActionButton"
                                                    ariaLabel="Negative Bewertung"/>
                                            </HBox>
                                        </HBox>
                                    </VBox>
                                </HBox>
                            </VBox>
                            
                            <!-- System Message -->
                            <VBox visible="{= ${chat>type} === 'system' }" class="modernSystemMessageContainer">
                                <HBox justifyContent="Center" class="modernMessageRow">
                                    <VBox class="modernSystemMessage">
                                        <Text text="{chat>text}" class="modernSystemText"/>
                                    </VBox>
                                </HBox>
                            </VBox>
                            
                            <!-- Info Message -->
                            <VBox visible="{= ${chat>type} === 'info' }" class="modernInfoMessageContainer">
                                <HBox justifyContent="Center" class="modernMessageRow">
                                    <HBox class="modernInfoMessage" alignItems="Center">
                                        <core:Icon src="sap-icon://information" class="modernInfoIcon"/>
                                        <Text text="{chat>text}" class="modernInfoText"/>
                                    </HBox>
                                </HBox>
                            </VBox>
                            
                            <!-- Warning Message -->
                            <VBox visible="{= ${chat>type} === 'warning' }" class="modernWarningMessageContainer">
                                <HBox justifyContent="Center" class="modernMessageRow">
                                    <HBox class="modernWarningMessage" alignItems="Center">
                                        <core:Icon src="sap-icon://warning" class="modernWarningIcon"/>
                                        <Text text="{chat>text}" class="modernWarningText"/>
                                    </HBox>
                                </HBox>
                            </VBox>
                        </content>
                    </CustomListItem>
                </List>
                
                <!-- Typing Indicator -->
                <HBox 
                    visible="{chat>/isTyping}" 
                    justifyContent="Start" 
                    class="modernTypingContainer modernMessageRow">
                    <VBox class="modernTypingMessage">
                        <HBox alignItems="Center">
                            <VBox class="modernTypingIndicator">
                                <core:Icon src="" class="modernTypingDot modernTypingDot1"/>
                                <core:Icon src="" class="modernTypingDot modernTypingDot2"/>
                                <core:Icon src="" class="modernTypingDot modernTypingDot3"/>
                            </VBox>
                            <Text text="AI Assistant schreibt..." class="modernTypingText"/>
                        </HBox>
                    </VBox>
                </HBox>
            </VBox>
        </ScrollContainer>

        <!-- Simple Input Area -->
        <VBox class="modernInputContainer">
            <!-- Input Row -->
            <HBox class="modernInputRow" alignItems="End">
                <VBox class="modernInputWrapper" width="100%">
                    <TextArea
                        id="chatInputField"
                        value="{chat>/userInput}"
                        liveChange="onInputLiveChange"
                        placeholder="Nachricht an PureAI Agent..."
                        rows="3"
                        maxLength="4000"
                        width="100%"
                        growing="true"
                        growingMaxLines="6"
                        submit="onSendChatMessageInSidePanel"
                        class=""
                        ariaLabel="Chat Eingabe"/>
                </VBox>
                
                <Button
                    id="sendButton"
                    icon="sap-icon://paper-plane"
                    type="Transparent"
                    press="onSendChatMessageInSidePanel"
                    class=""
                    ariaLabel="Nachricht senden"/>
            </HBox>
            
            <!-- Minimaler Input Footer -->
            <HBox justifyContent="End" alignItems="Center" class="modernInputFooter">
                <Text text="{= ${chat>/userInput}.length}/4000" class="modernCharCounter" visible="{= ${chat>/userInput}.length > 3800 }"/>
                <Text text="{chat>/statusMessage}" class="modernStatusMessage"/>
            </HBox>
        </VBox>
    </VBox>
</core:FragmentDefinition>
</file>

<file path="package.json">
{
  "name": "StammtischAI",
  "version": "1.0.0",
  "type": "module",
  "description": "A simple CAP project.",
  "repository": "<Add your repository here>",
  "license": "ISC",
  "dependencies": {
    "@cap-js/postgres": "^1",
    "@langchain/core": "^0.3.58",
    "@langchain/langgraph": "^0.3.2",
    "@langchain/mcp-adapters": "^0.5.2",
    "@modelcontextprotocol/sdk": "^1.11.0",
    "@modelcontextprotocol/server-postgres": "^0.6.2",
    "@sap-ai-sdk/langchain": "^1.15.0",
    "@sap-ai-sdk/orchestration": "^1.13.0",
    "@sap-cloud-sdk/connectivity": "^4.0.2",
    "@sap-cloud-sdk/http-client": "^4.0.2",
    "@sap-cloud-sdk/resilience": "^4.0.2",
    "@sap/cds": "^8.9.4",
    "cds-pg": "^0.1.36",
    "dotenv": "^16.5.0",
    "express": "^4",
    "langchain": "^0.3.28",
    "zod": "^3.23.8",
    "pg": "^8"
  },
  "devDependencies": {
    "@cap-js/cds-typer": "^0.34.0",
    "@cap-js/cds-types": "^0.10.0",
    "@cap-js/sqlite": "^1"
  },
  "scripts": {
    "start": "cds-serve",
    "watch-app": "cds watch --open app/webapp/index.html?sap-ui-xx-viewCache=false"
  },
  "cds": {
    "requires": {
      "db": {
        "kind": "postgres",
        "impl": "@cap-js/postgres",
        "[development]": {
          "credentials": {
            "host": "localhost",
            "port": 5432,
            "database": "stammtisch_ai_db",
            "user": "duh",
            "password": "test123"
          }
        },
        "[hybrid]": {
          "kind": "postgres",
          "credentials": {
            "host": "localhost",
            "port": 5432,
            "database": "stammtisch_ai_db",
            "user": "duh",
            "password": "test123"
          }
        }
      },
      "auth": {
        "kind": "mocked"
      },
      "destinations": true,
      "gen-ai-hub": {
        "claude-3.5": {
          "destinationName": "GenAIHubDestination",
          "deploymentUrl": "/v2/inference/deployments/dfddf56cb9d349b0",
          "resourceGroup": "default",
          "apiVersion": "2024-08-06",
          "modelName": "anthropic--claude-3.5-sonnet"
        }
      },
      "GenAIHubDestination": {
        "kind": "rest",
        "credentials": {
          "destination": "aicore-destination",
          "requestTimeout": "300000"
        }
      }
    },
    "features": {
      "fetch_csrf": true
    },
    "serve": {
      "host": "localhost",
      "port": 9999
    }
  },
  "sapux": [
    "app"
  ]
}
</file>

<file path="srv/lib/mcp-client.js">
// srv/lib/mcp-client.js

import cds from '@sap/cds';
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import { initM365InProcessClient as createInProcessM365Client } from '../m365-mcp/index.js';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const dbConfig = cds.env.requires.db;
let postgresClient = null;
let braveSearchClient = null;
let playwrightClient = null;
let filesystemClient = null;
let excelClient = null; // +++ NEU: Excel Client Variable
let m365Client = null;
let timeClient = null;

function getPostgresUri() {
  const creds = dbConfig.credentials;
  return `postgresql://${creds.user}:${creds.password}@${creds.host}:${creds.port}/${creds.database}`;
}

export async function initPostgresMCPClient() {
  if (postgresClient) return postgresClient;
  console.log(`Initializing PostgreSQL MCP client...`);
  const postgresUri = getPostgresUri();
  const transport = new StdioClientTransport({
    command: "npx",
    args: ["-y", "mcp-postgres-full-access", postgresUri],
  });
  postgresClient = new Client({ name: "postgres-client", version: "1.0.0" }, {});
  await postgresClient.connect(transport);
  console.log("✅ PostgreSQL MCP Client initialized successfully.");
  return postgresClient;
}

export async function initBraveSearchMCPClient() {
  if (braveSearchClient) return braveSearchClient;
  const braveApiKey = process.env.BRAVE_API_KEY || cds.env.BRAVE_API_KEY;
  if (!braveApiKey) throw new Error("BRAVE_API_KEY is required but not provided");
  console.log(`Initializing Brave Search MCP client...`);
  const transport = new StdioClientTransport({
    command: "npx",
    args: ["-y", "@modelcontextprotocol/server-brave-search"],
    env: { ...process.env, BRAVE_API_KEY: braveApiKey }
  });
  braveSearchClient = new Client({ name: "brave-search-client", version: "1.0.0" }, {});
  await braveSearchClient.connect(transport);
  console.log("✅ Brave Search MCP Client initialized successfully.");
  return braveSearchClient;
}

export async function initPlaywrightMCPClient() {
  console.log('⏸️ Playwright MCP client initialization is temporarily disabled.');
  return null;
}

export async function initFilesystemMCPClient() {
  if (filesystemClient) return filesystemClient;
  console.log(`Initializing Filesystem MCP client...`);
  const allowedDirectory = process.env.M365_ATTACHMENT_BASE_PATH || process.cwd();
  console.log(`Filesystem access is sandboxed to: ${allowedDirectory}`);
  const transport = new StdioClientTransport({
    command: "npx",
    args: ["-y", "@modelcontextprotocol/server-filesystem", allowedDirectory]
  });
  filesystemClient = new Client({ name: "filesystem-client", version: "1.0.0" }, {});
  await filesystemClient.connect(transport);
  console.log("✅ Filesystem MCP Client initialized successfully.");
  return filesystemClient;
}

// +++ NEUE FUNKTION: Excel MCP Client initialisieren +++
export async function initExcelMCPClient() {
  if (excelClient) return excelClient;

  console.log(`Initializing Excel MCP client...`);

  // Konfiguration basierend auf der README des Excel MCP Servers.
  // Diese Konfiguration ist für Windows. Für andere Plattformen (macOS/Linux)
  // wäre der Befehl: { command: "npx", args: ["--yes", "@negokaz/excel-mcp-server"] }
  const transport = new StdioClientTransport({
    command: "cmd",
    args: ["/c", "npx", "--yes", "@negokaz/excel-mcp-server"],
    env: {
      ...process.env,
      EXCEL_MCP_PAGING_CELLS_LIMIT: "4000" // Wie im Beispiel der README
    }
  });

  excelClient = new Client({ name: "excel-client", version: "1.0.0" }, {});
  await excelClient.connect(transport);
  console.log("✅ Excel MCP Client initialized successfully.");
  return excelClient;
}


export async function initM365Client() {
  if (m365Client) return m365Client;

  m365Client = await createInProcessM365Client({ logger: console });
  return m365Client;
}


export async function initTimeMCPClient() {
  if (timeClient) return timeClient;

  const command = process.env.TIME_MCP_COMMAND || 'python';
  let args;
  try {
    args = process.env.TIME_MCP_ARGS ? JSON.parse(process.env.TIME_MCP_ARGS) : ['-m', 'mcp_server_time'];
  } catch (error) {
    throw new Error(`Failed to parse TIME_MCP_ARGS. Provide a JSON array string, e.g. ["-m","mcp_server_time"]. Original error: ${error.message}`);
  }

  if (!Array.isArray(args)) {
    throw new Error('TIME_MCP_ARGS must be a JSON array string when provided.');
  }

  console.log('Initializing Time MCP client...');
  const transport = new StdioClientTransport({
    command,
    args,
    env: process.env
  });

  timeClient = new Client({ name: 'time-client', version: '1.0.0' }, {});
  await timeClient.connect(transport);
  console.log('✅ Time MCP Client initialized successfully.');

  return timeClient;
}


export async function initAllMCPClients() {
  console.log("Initializing all MCP clients...");
  
  // +++ ERWEITERT: Excel Client wird mit initialisiert +++
  const [pgClient, braveClient, fsClient, xlsxClient, microsoft365Client, timeMcpClient] = await Promise.all([
    initPostgresMCPClient(),
    initBraveSearchMCPClient(),
    initFilesystemMCPClient(),
    initExcelMCPClient(), // Neuer Client
    initM365Client(),
    initTimeMCPClient()
  ]);

  return {
    postgres: pgClient,
    braveSearch: braveClient,
    playwright: null,
    filesystem: fsClient,
    excel: xlsxClient, // Neuer Client im Rückgabeobjekt
    m365: microsoft365Client,
    time: timeMcpClient
  };
}

export async function closeMCPClients() {
  const closePromises = [];
  
  if (postgresClient) {
    console.log("Closing PostgreSQL MCP client connection");
    closePromises.push(postgresClient.close());
    postgresClient = null;
  }
  if (braveSearchClient) {
    console.log("Closing Brave Search MCP client connection");
    closePromises.push(braveSearchClient.close());
    braveSearchClient = null;
  }
  if (filesystemClient) {
    console.log("Closing Filesystem MCP client connection");
    closePromises.push(filesystemClient.close());
    filesystemClient = null;
  }
  // +++ ERWEITERT: Excel Client wird geschlossen +++
  if (excelClient) {
    console.log("Closing Excel MCP client connection");
    closePromises.push(excelClient.close());
    excelClient = null;
  }
  if (m365Client) {
    console.log("Closing Microsoft 365 MCP client connection");
    closePromises.push(m365Client.close());
    m365Client = null;
  }
  if (timeClient) {
    console.log("Closing Time MCP client connection");
    closePromises.push(timeClient.close());
    timeClient = null;
  }

  await Promise.all(closePromises);
  console.log("✅ All MCP clients closed");
}

// Backward compatibility
export const initMCPClient = initPostgresMCPClient;
export const closeMCPClient = closeMCPClients;
</file>

<file path="app/webapp/main.js">
sap.ui.define([
    "sap/ui/core/Component",
    "sap/ui/core/ComponentContainer",
    "sap/ui/core/Fragment",
    "sap/ui/layout/Splitter",
    "sap/ui/layout/SplitterLayoutData",
    "sap/m/Panel",
    "sap/ui/model/json/JSONModel",
    "sap/m/App",
    "sap/m/Page",
    "sap/m/Bar",
    "sap/m/Title",
    "sap/m/MessageToast",
    "sap/ui/model/Filter"
], (Component, ComponentContainer, Fragment, Splitter, SplitterLayoutData, Panel, JSONModel, App, Page, Bar, Title, MessageToast, Filter) => {
    "use strict";

    // Modern class-based approach for Chat functionality
    class ChatManager {
        constructor() {
            this.chatModel = null;
            this.notificationsModel = null;
            this.mainSplitter = null;
            this.chatPanel = null;
            this.feAppComponentInstance = null;
            this.currentRecognition = null;
            this.serviceUrl = "/service/stammtisch"; // Service URL from manifest.json
            this.notificationsEventSource = null;
            this.topicsCache = [];
            this.topicsCacheTimestamp = 0;
            this.topicsLoadingPromise = null;
            this.TOPIC_CACHE_MAX_AGE_MS = 30000;
            this.isMentionOpen = false;
            this._mentionTokenStart = null;
            this._mentionFilter = "";
            this._mentionCursor = null;
            this._mentionValue = "";
            this._mentionSelectionIndex = 0;
            this.announcedMailIds = new Set();
            this.autoAnalyzedMailIds = new Set();
        }

        // Initialize chat model with welcome message
        initializeChatModel() {
            this.isMentionOpen = false;
            this._mentionTokenStart = null;
            this._mentionFilter = '';
            this._mentionCursor = null;
            this._mentionValue = '';
            this._mentionSelectionIndex = 0;

            this.chatModel = new JSONModel({
                chatHistory: [],
                userInput: "",
                isTyping: false,
                statusMessage: "",
                showSuggestions: false,
                suggestions: [
                    { text: 'Fasse den Excel‑Anhang mit Terminen, Themen und Kerndaten kurz zusammen.' },
                    { text: 'Liste alle Events mit Datum, Themen und Referenten tabellarisch auf.' },
                    { text: 'Importiere bitte die Excel Zeile mit dem Datum 30.09.2025 in unsere passende DB.' },
                    { text: 'Importiere bitte die Excel Zeile mit dem Datum 30.09.2025 und 18.11.2025 in unsere passende DB.' },
                    { text: 'Nur „Integration Suite“ importieren' },
                    { text: 'Nur die ohne Duplikate importieren' },
                    { text: 'Füge als Präsentator in "Integration Suite" {Name} hinzu' },
                    { text: 'Füge als Präsentator in "Integration Suite" und "Business Event und openSource Generator" den passenden Präsentator hinnzu'},
                    { text: 'Schaue in der Excel nach welche passen' },
                    { text: 'Erstelle einen Termin zur Duplikatklärung (übermorgen 10–11 Uhr).' },
                    { text: 'Formuliere Email Antwort was wir bisher alles gemacht haben.' },
                    { text: 'Habe ich in meinem File System eine Teilnehmer Datei?' },
                    { text: 'Zeige mir den Inhalt von Teilnehmer.txt an.' },
                    { text: 'Ordne alle Personen aus „Teilnehmer.txt“ dem aktuellen neuem Event „Integration Suite“ zu und bereite Commit vor.' },
                    { text: "Erzeuge eine Teilnehmeranalyse (Häufigkeit) und hebe die Top 3 hervor." }
                ]
            });

        }

        initializeNotificationsModel() {
            this.notificationsModel = new JSONModel({
                items: [],
                unreadCount: 0,
                hasNew: false
            });
        }

        formatNotificationForDisplay(item) {
            if (!item) return item;
            const formatted = { ...item };
            const fromEntry = item.from || {};
            const nameCandidate = fromEntry.name || fromEntry.displayName;
            const addressCandidate = fromEntry.address || fromEntry.emailAddress;
            formatted.fromDisplay = nameCandidate || addressCandidate || 'Unbekannter Absender';

            if (item.agentContext) {
                formatted.agentContext = item.agentContext;
            }

            formatted.hasAttachments = Boolean(item.hasAttachments);

            const categoryRaw = typeof item.category === 'string' ? item.category.trim() : '';
            const category = categoryRaw || 'Notification';
            formatted.category = category;
            formatted.categoryState = this.mapCategoryToState(category);

            const rawSummary = typeof item.summary === 'string'
                ? item.summary
                : (item.bodyPreview || '');

            let preparedSummary = String(rawSummary || '')
                .replace(/\r\n/g, '\n')
                .trim();

            if (preparedSummary) {
                // Normalize whitespace around explicit line breaks
                preparedSummary = preparedSummary
                    .split('\n')
                    .map((line) => line.trim().replace(/\s{2,}/g, ' '))
                    .filter(Boolean)
                    .join('\n');

                // If no line breaks provided, insert one after sentence endings for readability
                if (!preparedSummary.includes('\n')) {
                    preparedSummary = preparedSummary.replace(/\.\s+/g, '.\n');
                }
            } else {
                preparedSummary = 'Keine Zusammenfassung verfügbar.';
            }

            formatted.summary = preparedSummary;

            if (item.receivedDateTime) {
                const date = new Date(item.receivedDateTime);
                if (!Number.isNaN(date.getTime())) {
                    const now = new Date();
                    const todayKey = now.toDateString();
                    const yesterday = new Date(now);
                    yesterday.setDate(now.getDate() - 1);
                    const targetKey = date.toDateString();
                    const timeFormatter = new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit' });
                    const dateFormatter = new Intl.DateTimeFormat(undefined, { year: 'numeric', month: 'short', day: '2-digit' });
                    if (targetKey === todayKey) {
                        formatted.receivedLabel = `Heute ${timeFormatter.format(date)}`;
                    } else if (targetKey === yesterday.toDateString()) {
                        formatted.receivedLabel = `Gestern ${timeFormatter.format(date)}`;
                    } else {
                        formatted.receivedLabel = `${dateFormatter.format(date)} ${timeFormatter.format(date)}`;
                    }
                } else {
                    formatted.receivedLabel = '';
                }
            } else {
                formatted.receivedLabel = '';
            }

            if (!formatted.subject) {
                formatted.subject = 'Ohne Betreff';
            }

            return formatted;
        }

        buildMailActionPrompt(mailItem) {
            const rawAgentContext = mailItem?.agentContext;
            const contextObject = this.ensureAgentContextObject(rawAgentContext)
                || (rawAgentContext && typeof rawAgentContext === 'object' ? rawAgentContext : null)
                || (typeof rawAgentContext === 'string' ? { context: rawAgentContext } : null);
            const contextJson = contextObject ? JSON.stringify(contextObject, null, 2) : null;
            const subject = mailItem?.subject || 'Ohne Betreff';
            const baseSummary = mailItem?.summary || '';
            const category = mailItem?.category || 'Notification';
            const sender = contextObject?.sender;
            const senderDisplay = sender?.formatted || sender?.email || sender?.name || 'Unbekannt';
            const defaultRecipients = Array.isArray(contextObject?.replyGuidelines?.defaultEmailRecipients)
                ? contextObject.replyGuidelines.defaultEmailRecipients.filter(Boolean)
                : [];
            const defaultRecipientLine = defaultRecipients.length
                ? `Standard-Empfänger (laut Kontext): ${defaultRecipients.join(', ')}`
                : null;

            return [
                'Du bist ein KI-Assistent, der Anwendern hilft, sinnvolle Folgeaktionen für eingehende E-Mails zu planen.',
                'Analysiere den untenstehenden JSON-Kontext und schlage drei konkrete nächste Schritte vor.',
                'Formatiere die Ausgabe als nummerierte Liste. Für jede Aktion: kurze Beschreibung, warum sie sinnvoll ist, und falls nötig welche Informationen fehlen.',
                'Die Felder "bodyText" (bereinigter Volltext) und "bodyHtml" (sanitisierte HTML-Struktur) enthalten den vollständigen Inhalt.',
                'Antworte auf Deutsch und fasse dich prägnant.',
                `Bei Antworten oder Kalendereinladungen: Nutze standardmäßig den ursprünglichen Absender (${senderDisplay}) als Empfänger, sofern der Nutzer keine weiteren Personen nennt.`,
                defaultRecipientLine,
                '',
                `Betreff: ${subject}`,
                `Kategorie (Vorhersage): ${category}`,
                baseSummary ? `Zusammenfassung: ${baseSummary}` : '',
                '',
                'E-Mail-Kontext (JSON):',
                contextJson || 'Kein Kontext verfügbar'
            ].filter(Boolean).join('\n');
        }

        ensureAgentContextObject(rawAgentContext) {
            if (!rawAgentContext) {
                return null;
            }

            if (typeof rawAgentContext === 'string') {
                const trimmed = rawAgentContext.trim();
                if (!trimmed) {
                    return null;
                }
                try {
                    return JSON.parse(trimmed);
                } catch (error) {
                    return { bodyText: trimmed };
                }
            }

            return rawAgentContext;
        }

        convertHtmlToPlainText(html) {
            return html
                .replace(/<style[\s\S]*?<\/style>/gi, '')
                .replace(/<script[\s\S]*?<\/script>/gi, '')
                .replace(/<br\s*\/?>(\n)?/gi, '\n')
                .replace(/<\/p>/gi, '\n\n')
                .replace(/<\/h[1-6]>/gi, '\n\n')
                .replace(/<li>/gi, '- ')
                .replace(/<\/li>/gi, '\n')
                .replace(/<[^>]+>/g, '')
                .replace(/\r\n/g, '\n');
        }

        getMailBodyString(mailItem) {
            const agentContext = this.ensureAgentContextObject(mailItem?.agentContext);
            if (!agentContext) {
                return '';
            }

            const rawBodyText = typeof agentContext.bodyText === 'string' ? agentContext.bodyText.trim() : '';
            if (rawBodyText) {
                return rawBodyText;
            }

            const rawBodyHtml = typeof agentContext.bodyHtml === 'string' ? agentContext.bodyHtml.trim() : '';
            if (rawBodyHtml) {
                return this.convertHtmlToPlainText(rawBodyHtml).trim();
            }

            const rawBody = typeof agentContext.body === 'string' ? agentContext.body.trim() : '';
            return rawBody || '';
        }

        truncateTextForDisplay(text, maxChars = 1200, maxLines = 25) {
            if (!text) {
                return '';
            }

            const normalizedLines = text
                .replace(/\r\n/g, '\n')
                .split('\n')
                .map((line) => line.replace(/\s+$/g, ''));

            let truncatedLines = normalizedLines;
            let truncatedByLines = false;
            if (normalizedLines.length > maxLines) {
                truncatedLines = normalizedLines.slice(0, maxLines);
                truncatedByLines = true;
            }

            let result = truncatedLines.join('\n').replace(/\n{3,}/g, '\n\n').trim();

            if (truncatedByLines) {
                result = `${result}\n...`;
            }

            if (result.length > maxChars) {
                const trimmedResult = result.slice(0, maxChars - 3).trimEnd();
                result = trimmedResult.endsWith('...') ? trimmedResult : `${trimmedResult}...`;
            }

            return result;
        }

        buildEmailTextForDisplay(mailItem) {
            const primaryText = this.getMailBodyString(mailItem);
            const summary = typeof mailItem?.summary === 'string' ? mailItem.summary.trim() : '';
            const preview = typeof mailItem?.bodyPreview === 'string' ? mailItem.bodyPreview.trim() : '';
            const candidate = primaryText || summary || preview || '';
            return this.truncateTextForDisplay(candidate);
        }

        buildQuickActionSuggestions(mailItem) {
            const suggestions = [];

            suggestions.push('Nutze den Button "An Agent senden", um eine detaillierte Analyse zu starten.');

            if (mailItem.hasAttachments) {
                suggestions.push('Öffne die Anhänge und prüfe sie auf wichtige Informationen.');
            }

            const category = typeof mailItem.category === 'string' ? mailItem.category.toLowerCase() : '';
            if (category === 'to respond' || category === 'action needed') {
                suggestions.push('Formuliere eine zeitnahe Antwort oder plane konkrete Folgeaktionen.');
            } else if (category === 'meeting update') {
                suggestions.push('Aktualisiere deinen Kalender und bestätige den Termin bei Bedarf.');
            } else if (category === 'fyi') {
                suggestions.push('Teile die wichtigsten Punkte mit den relevanten Personen oder notiere sie.');
            }

            const sender = mailItem.fromDisplay || 'dem Absender';
            if (suggestions.length < 3) {
                suggestions.push(`Notiere wichtige Punkte und stimme dich bei Bedarf mit ${sender} ab.`);
            }

            if (suggestions.length < 3) {
                suggestions.push('Lege eine Aufgabe oder Erinnerung für die nächsten Schritte an.');
            }

            // Entferne Duplikate und reduziere auf drei Einträge
            const unique = [];
            suggestions.forEach((entry) => {
                if (!unique.includes(entry)) {
                    unique.push(entry);
                }
            });

            return unique.slice(0, 3);
        }

        escapeHtml(text) {
            if (!text) {
                return '';
            }
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        renderParagraphs(text) {
            if (!text) {
                return '';
            }
            const escaped = this.escapeHtml(text)
                .replace(/\r\n/g, '\n')
                .split(/\n{2,}/)
                .map((block) => block.split('\n').map((line) => line.trim()).filter(Boolean).join('<br/>'))
                .filter(Boolean);

            return escaped
                .map((paragraph) => `<p style="margin: 0 0 8px 0;">${paragraph}</p>`)
                .join('');
        }

        highlightKeywords(text) {
            if (!text) {
                return '';
            }

            const keywordPatterns = [
                'Agent',
                'Analyse',
                'Anhänge',
                'Antwort',
                'Aufgabe',
                'Folgeaktionen',
                'Kalender'
            ];

            let highlighted = text;
            keywordPatterns.forEach((keyword) => {
                const pattern = new RegExp(`(\\b${keyword}\\b)`, 'gi');
                highlighted = highlighted.replace(pattern, '<strong>$1</strong>');
            });

            return highlighted;
        }

        buildMailAnnouncementHtml(mailItem) {
            const displayMail = this.formatNotificationForDisplay(mailItem);
            const bodyExcerpt = this.buildEmailTextForDisplay(displayMail);
            const subject = displayMail.subject || 'Ohne Betreff';
            const sender = displayMail.fromDisplay || 'Unbekannter Absender';
            const received = displayMail.receivedLabel || null;
            const category = displayMail.category || null;
            const attachments = displayMail.hasAttachments ? 'vorhanden' : null;
            const suggestions = this.buildQuickActionSuggestions(displayMail);

            const metaEntries = [
                { label: 'Von', value: sender },
                { label: 'Betreff', value: subject },
                { label: 'Empfangen', value: received },
                { label: 'Kategorie', value: category },
                { label: 'Anhänge', value: attachments }
            ].filter((entry) => entry.value);

            const metaHtml = metaEntries.map((entry) => {
                const safeValue = this.escapeHtml(entry.value);
                return `<p style="margin: 0 0 6px 0; font-size: 14px;">
                    <strong>${entry.label}:</strong>
                    <span style="margin-left: 4px; font-weight: 600; color: #1f2933;">${safeValue}</span>
                </p>`;
            }).join('');

            const bodyHtml = this.renderParagraphs(bodyExcerpt || 'Kein E-Mail-Text verfügbar.');

            const suggestionsHtml = suggestions.length
                ? `<ul style="margin: 0; padding-left: 18px;">
                        ${suggestions.map((entry) => {
                            const safeText = this.escapeHtml(entry);
                            const highlighted = this.highlightKeywords(safeText);
                            return `<li style="margin-bottom: 6px; line-height: 1.45;">${highlighted}</li>`;
                        }).join('')}
                   </ul>`
                : '<ul style="margin: 0; padding-left: 18px;"><li>Keine Vorschläge verfügbar.</li></ul>';

            return `
                <p style="margin: 0 0 6px 0; font-size: 16px; font-weight: 700;">Hallo Hoang 👋 neue E-Mail eingetroffen</p>
                ${metaHtml}
                <p style="margin: 12px 0 4px 0; font-weight: 700; color: #1a2a3b;">Inhalt (Auszug)</p>
                ${bodyHtml || '<p style="margin: 0;">Kein E-Mail-Text verfügbar.</p>'}
                <p style="margin: 12px 0 4px 0; font-weight: 700; color: #1a2a3b;">Mögliche nächste Schritte</p>
                ${suggestionsHtml}
            `;
        }

        isExcelLikeAttachment(attachment) {
            if (!attachment) {
                return false;
            }

            const name = typeof attachment.name === 'string' ? attachment.name.toLowerCase() : '';
            const contentType = typeof attachment.contentType === 'string' ? attachment.contentType.toLowerCase() : '';

            const extensionMatch = name.endsWith('.xlsx')
                || name.endsWith('.xls')
                || name.endsWith('.xlsm')
                || name.endsWith('.xlsb')
                || name.endsWith('.csv');

            const contentTypeMatch = contentType.includes('spreadsheet')
                || contentType.includes('excel')
                || contentType.includes('csv');

            return extensionMatch || contentTypeMatch;
        }

        hasExcelAttachment(mailItem) {
            if (!mailItem) {
                return false;
            }

            const agentContext = this.ensureAgentContextObject(mailItem.agentContext);
            const contextAttachments = Array.isArray(agentContext?.attachments) ? agentContext.attachments : [];
            const rawAttachments = Array.isArray(mailItem.attachments) ? mailItem.attachments : [];
            const combined = [...contextAttachments, ...rawAttachments];

            if (!combined.length) {
                return false;
            }

            return combined.some((attachment) => this.isExcelLikeAttachment(attachment));
        }

        autoAnalyzeExcelMail(mailItem) {
            const identifier = mailItem?.id || mailItem?.itemId;
            if (identifier && this.autoAnalyzedMailIds.has(identifier)) {
                return;
            }

            if (identifier) {
                this.autoAnalyzedMailIds.add(identifier);
                if (this.autoAnalyzedMailIds.size > 100) {
                    const first = this.autoAnalyzedMailIds.values().next();
                    if (!first.done) {
                        this.autoAnalyzedMailIds.delete(first.value);
                    }
                }
            }

            this.sendMailContextToAgent(mailItem, { auto: true });
        }

        announceNewMail(mailItem) {
            if (!mailItem || !this.chatModel) {
                return;
            }

            const identifier = mailItem.id || mailItem.itemId;
            if (identifier && this.announcedMailIds.has(identifier)) {
                return;
            }

            const messageHtml = this.buildMailAnnouncementHtml(mailItem);
            this.addMessageEnhanced('assistant', messageHtml);
            this.setStatusMessage('Neue E-Mail eingetroffen', 2000);

            if (this.hasExcelAttachment(mailItem)) {
                this.autoAnalyzeExcelMail(mailItem);
            }

            if (identifier) {
                this.announcedMailIds.add(identifier);
                if (this.announcedMailIds.size > 100) {
                    const first = this.announcedMailIds.values().next();
                    if (!first.done) {
                        this.announcedMailIds.delete(first.value);
                    }
                }
            }
        }

        async sendMailContextToAgent(mailItem, options = {}) {
            if (!mailItem) {
                this.setStatusMessage('Keine Mail ausgewählt', 2000);
                return;
            }

            if (!mailItem.agentContext) {
                this.setStatusMessage('Kein Kontext für diese Mail verfügbar', 3000);
                return;
            }

            const { auto = false } = options;
            const subject = mailItem.subject || 'Ohne Betreff';
            const emailText = this.buildEmailTextForDisplay(mailItem);
            if (auto) {
                this.addMessage('system', `Automatische Analyse für "${subject}" gestartet.`);
            } else {
                const userMessageParts = [
                    `Welche Aktionen empfiehlst du für die E-Mail "${subject}"?`,
                    '',
                    'E-Mail-Text:',
                    emailText || 'Kein E-Mail-Text verfügbar.'
                ];
                this.addMessage('user', userMessageParts.join('\n'));
            }

            this.chatModel.setProperty('/isTyping', true);
            this.setStatusMessage(auto ? 'Agent analysiert neue E-Mail...' : 'Agent analysiert die E-Mail...', 0);

            const prompt = this.buildMailActionPrompt(mailItem);

            if (!auto) {
                const pop = sap.ui.core.Fragment.byId('chatSidePanelFragmentGlobal', 'notificationsPopover');
                if (pop && pop.isOpen && pop.isOpen()) {
                    pop.close();
                    this.setHasNew(false);
                }
            }

            try {
                const response = await this.callLLMViaOperationBinding(prompt);
                this.handleAIResponse(response);
                this.setStatusMessage(auto ? 'Automatische Agent-Antwort erhalten' : 'Agent-Antwort erhalten', 2000);
            } catch (error) {
                console.error('Error while sending mail to agent:', error);
                this.handleAIError(error.message || 'Analyse fehlgeschlagen');
            }
        }

        setNotifications(items) {
            const arr = Array.isArray(items) ? items : [];
            const formatted = arr.map((entry) => this.formatNotificationForDisplay(entry));
            this.notificationsModel.setProperty('/items', formatted);
            this.notificationsModel.setProperty('/unreadCount', formatted.length);
            if (formatted.length === 0) {
                this.notificationsModel.setProperty('/hasNew', false);
            }
            this.notificationsModel.refresh(true);
        }

        mapCategoryToState(category) {
            switch (category) {
                case 'Action needed':
                case 'To Respond':
                    return 'Warning';
                case 'Completed':
                    return 'Success';
                case 'Notification':
                case 'FYI':
                case 'Meeting Update':
                    return 'Information';
                default:
                    return 'None';
            }
        }

        addNotification(item) {
            const items = this.notificationsModel.getProperty('/items') || [];
            if (!items.find(x => x.id === item.id)) {
                const formatted = this.formatNotificationForDisplay(item);
                items.unshift(formatted);
                if (items.length > 20) items.length = 20;
                this.setNotifications(items);
                return true;
            }
            return false;
        }

        removeNotificationById(id) {
            const items = this.notificationsModel.getProperty('/items') || [];
            const filtered = items.filter(x => x.id !== id);
            this.setNotifications(filtered);
        }

        setHasNew(flag) {
            const next = Boolean(flag);
            const current = Boolean(this.notificationsModel.getProperty('/hasNew'));
            if (current === next) {
                return;
            }
            this.notificationsModel.setProperty('/hasNew', next);
            this.notificationsModel.refresh(true);
        }

        setupNotificationsSSE() {
            try {
                if (this.notificationsEventSource) {
                    try { this.notificationsEventSource.close(); } catch (e) {}
                }
                const url = `${this.serviceUrl}/notifications/stream`;
                const es = new EventSource(url);
                this.notificationsEventSource = es;

                es.onmessage = (ev) => {
                    try {
                        const msg = JSON.parse(ev.data || '{}');
                        if (msg.type === 'init' && Array.isArray(msg.items)) {
                            this.setNotifications(msg.items);
                            this.setHasNew(false);
                        } else if (msg.type === 'new' && msg.item) {
                            const added = this.addNotification(msg.item);
                            if (added) {
                                const pop = sap.ui.core.Fragment.byId('chatSidePanelFragmentGlobal', 'notificationsPopover');
                                const isOpen = pop?.isOpen && pop.isOpen();
                                this.setHasNew(!isOpen);
                                this.announceNewMail(msg.item);
                            }
                        } else if (msg.type === 'read' && msg.id) {
                            this.removeNotificationById(msg.id);
                        } else if (msg.type === 'error' && msg.message) {
                            console.warn('Notifications error:', msg.message);
                        }
                    } catch (e) {
                        console.warn('Failed to parse notifications message', e);
                    }
                };

                es.onerror = () => {
                    // Let browser retry automatically; show a subtle status
                    this.setStatusMessage('Verbindung zu Benachrichtigungen gestört. Versuche erneut...', 2000);
                };
            } catch (e) {
                console.warn('Failed to setup notifications SSE:', e);
            }
        }

        // Get current timestamp in HH:MM format
        getCurrentTimestamp() {
            return new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        // Smooth scroll to bottom of chat
        scrollToBottom() {
            if (!this.chatPanel) return;

            const scrollContainer = sap.ui.core.Fragment.byId(
                "chatSidePanelFragmentGlobal",
                "chatHistoryScrollContainerInSidePanel"
            );

            if (scrollContainer) {
                setTimeout(() => scrollContainer.scrollTo(0, 99999, 300), 100);
            }
        }

        async callLLMViaOperationBinding(prompt) {
            try {
                if (!this.feAppComponentInstance) {
                    throw new Error("FE Component not available");
                }

                const oDataModel = this.feAppComponentInstance.getModel();

                if (!oDataModel) {
                    throw new Error("OData Model not found");
                }

                const finalPrompt = await this.addTopicContextToPrompt(prompt);

                // Erstelle Operation Binding für unbound Action
                const oOperationBinding = oDataModel.bindContext("/callLLM(...)");

                // Setze Parameter
                oOperationBinding.setParameter("prompt", finalPrompt);

                // Führe Action aus
                await oOperationBinding.execute();

                // Hole Ergebnis
                const oContext = oOperationBinding.getBoundContext();
                const result = oContext.getObject();

                console.log("Claude operation result:", result);

                this.refreshTopicsCache().catch((refreshError) => {
                    console.warn("Aktualisierung der Stammtisch-Themen nach Agent-Call fehlgeschlagen:", refreshError);
                });

                return result.response || "No response received";

            } catch (error) {
                console.error("Error in callLLMViaOperationBinding:", error);
                throw error;
            }
        }

        async addTopicContextToPrompt(prompt) {
            const topics = await this.getTopicsSnapshot().catch((error) => {
                console.warn("Konnte Themenliste nicht ermitteln:", error);
                return [];
            });

            if (!Array.isArray(topics) || topics.length === 0) {
                return prompt;
            }

            const listForPrompt = topics.map((entry) => ({
                id: entry.id,
                thema: entry.thema,
                normalized: entry.normalized
            }));

            const instructions = [
                "Kontext: Verwende die folgende JSON-Liste, um neue Stammtisch-Themen auf Duplikate (case-insensitive, trim) zu prüfen, bevor du Einträge anlegst.",
                "Wenn bereits ein Thema existiert, informiere den Nutzer, frage nach dem gewünschten Vorgehen und führe kein INSERT ohne explizite Freigabe aus.",
                `BekannteThemenJSON=${JSON.stringify(listForPrompt)}`,
                "---",
                prompt
            ];

            return instructions.join("\n\n");
        }

        normalizeTopicName(thema) {
            return typeof thema === "string" ? thema.trim().toLowerCase() : "";
        }

        async getTopicsSnapshot(options = {}) {
            const { force = false } = options;
            const now = Date.now();
            const isStale = now - this.topicsCacheTimestamp > this.TOPIC_CACHE_MAX_AGE_MS;

            if (!force && this.topicsCache.length && !isStale) {
                return this.topicsCache;
            }

            if (this.topicsLoadingPromise) {
                return this.topicsLoadingPromise;
            }

            this.topicsLoadingPromise = this.refreshTopicsCache()
                .catch((error) => {
                    this.topicsLoadingPromise = null;
                    throw error;
                })
                .then((result) => {
                    this.topicsLoadingPromise = null;
                    return result;
                });

            return this.topicsLoadingPromise;
        }

        async refreshTopicsCache() {
            if (!this.feAppComponentInstance) {
                return this.topicsCache;
            }

            const model = this.feAppComponentInstance.getModel();
            if (!model) {
                return this.topicsCache;
            }

            const listBinding = model.bindList("/Stammtische");

            try {
                const contexts = await listBinding.requestContexts(0, 500);
                const snapshot = contexts
                    .map((ctx) => ctx?.getObject?.())
                    .filter((entry) => entry && typeof entry.thema === "string" && entry.thema.trim());

                this.topicsCache = snapshot.map((entry) => ({
                    id: entry.ID,
                    thema: entry.thema,
                    normalized: this.normalizeTopicName(entry.thema)
                }));
                this.topicsCacheTimestamp = Date.now();

                return this.topicsCache;
            } finally {
                listBinding.destroy();
            }
        }

        invalidateTopicsCache() {
            this.topicsCacheTimestamp = 0;
            this.topicsCache = [];
        }

        // Update status message with auto-clear
        setStatusMessage(message, duration = 3000) {
            this.chatModel.setProperty("/statusMessage", message);
            if (duration > 0) {
                setTimeout(() => this.chatModel.setProperty("/statusMessage", ""), duration);
            }
        }

        // Add message to chat history
        addMessage(type, text, timestamp = this.getCurrentTimestamp()) {
            const history = this.chatModel.getProperty("/chatHistory");
            history.push({ type, text, timestamp });
            this.chatModel.setProperty("/chatHistory", history);
            this.chatModel.refresh(true);
            this.scrollToBottom();
        }

        // Remove last "Thinking..." message
        removeThinkingMessage() {
            const history = this.chatModel.getProperty("/chatHistory");
            if (history.length > 0 && history[history.length - 1].text === "Thinking...") {
                history.pop();
                this.chatModel.setProperty("/chatHistory", history);
            }
        }

        // Handle AI response
        handleAIResponse(responseText) {
            this.removeThinkingMessage();
            this.addMessage("assistant", responseText);
            this.chatModel.setProperty("/isTyping", false);
            this.chatModel.setProperty("/statusMessage", "");
        }

        // Handle AI errors
        handleAIError(errorMessage) {
            this.removeThinkingMessage();
            this.addMessage("assistant", `I apologize, but I encountered an error: ${errorMessage}`);
            this.chatModel.setProperty("/isTyping", false);
            this.setStatusMessage("Error occurred", 5000);
        }

        // Call Claude service via HTTP
        async callLLMService(prompt) {
            try {
                // Get CSRF token first
                const csrfToken = await this.getCSRFToken();

                // Prepare the request
                const requestOptions = {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                        'X-CSRF-Token': csrfToken
                    },
                    body: JSON.stringify({
                        prompt: prompt
                    })
                };

                // Make the actual call to Claude service
                const response = await fetch(`${this.serviceUrl}/callLLM`, requestOptions);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                // Handle response from Claude
                if (data && data.response) {
                    return data.response;
                } else {
                    throw new Error("No valid response from Claude service");
                }

            } catch (error) {
                console.error("Error calling Claude service:", error);
                throw error;
            }
        }

        // Get CSRF token for OData service calls
        async getCSRFToken() {
            try {
                const response = await fetch(`${this.serviceUrl}/`, {
                    method: 'GET',
                    headers: {
                        'X-CSRF-Token': 'Fetch'
                    }
                });

                return response.headers.get('X-CSRF-Token') || '';
            } catch (error) {
                console.warn("Could not fetch CSRF token:", error);
                return '';
            }
        }

        // Modern clipboard copy with fallback
        async copyToClipboard(text) {
            try {
                if (navigator.clipboard?.writeText) {
                    await navigator.clipboard.writeText(text);
                    this.setStatusMessage("Copied to clipboard", 2000);
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement("textarea");
                    textArea.value = text;
                    textArea.style.position = "fixed";
                    textArea.style.opacity = "0";
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    this.setStatusMessage("Copied to clipboard", 2000);
                }
            } catch (error) {
                console.error('Copy failed:', error);
                this.setStatusMessage("Failed to copy", 2000);
            }
        }

        // Modern speech recognition
        startVoiceInput() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

            if (!SpeechRecognition) {
                this.setStatusMessage("Voice input not supported in this browser");
                return;
            }

            // Stop any existing recognition
            if (this.currentRecognition) {
                this.currentRecognition.stop();
            }

            this.currentRecognition = new SpeechRecognition();
            Object.assign(this.currentRecognition, {
                continuous: false,
                interimResults: false,
                lang: 'en-US'
            });

            this.setStatusMessage("Listening...", 0);

            this.currentRecognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                this.chatModel.setProperty("/userInput", transcript);
                this.setStatusMessage("Voice input received", 2000);
            };

            this.currentRecognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                this.setStatusMessage("Voice input failed");
            };

            this.currentRecognition.onend = () => {
                this.currentRecognition = null;
                this.setStatusMessage("");
            };

            this.currentRecognition.start();
        }

        scrollToBottomEnhanced() {
            if (!this.chatPanel) return;

            const scrollContainer = sap.ui.core.Fragment.byId(
                "chatSidePanelFragmentGlobal",
                "chatHistoryScrollContainerInSidePanel"
            );

            if (scrollContainer) {
                // Warte bis HTML-Content gerendert ist
                setTimeout(() => {
                    scrollContainer.scrollTo(0, 99999, 500);

                    // Trigger re-rendering für FormattedText mit HTML
                    const chatList = sap.ui.core.Fragment.byId(
                        "chatSidePanelFragmentGlobal",
                        "chatMessagesList"
                    );
                    if (chatList) {
                        chatList.getModel("chat").refresh(true);
                    }
                }, 150);
            }
        }

        // Erweiterte addMessage Methode mit HTML-Unterstützung
        addMessageEnhanced(type, text, timestamp = this.getCurrentTimestamp()) {
            const history = this.chatModel.getProperty("/chatHistory");

            // Spezielle Behandlung für HTML-Content
            let processedText = text;
            if (type === "assistant" && text.includes('<')) {
                // HTML-Content erkannt - stelle sicher, dass es sicher ist
                processedText = this.sanitizeHTMLContent(text);
            }

            history.push({
                type,
                text: processedText,
                timestamp,
                isHTML: text.includes('<') // Flag für HTML-Content
            });

            this.chatModel.setProperty("/chatHistory", history);
            this.chatModel.refresh(true);

            // Verwende enhanced scrolling für HTML-Content
            this.scrollToBottomEnhanced();
        }

        // HTML Content Sanitization (Basis-Sicherheit)
        sanitizeHTMLContent(html) {
            // Erlaubte Tags für AI-Antworten
            const allowedTags = [
                'p', 'br', 'strong', 'em', 'code', 'pre',
                'h1', 'h2', 'h3', 'ul', 'ol', 'li',
                'div', 'span', 'a'
            ];

            // Entferne potentiell gefährliche Attribute
            let sanitized = html.replace(/on\w+="[^"]*"/gi, ''); // onclick, onload, etc.
            sanitized = sanitized.replace(/javascript:/gi, ''); // javascript: URLs
            sanitized = sanitized.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, ''); // script tags

            return sanitized;
        }

        // Link-Handler für AI-Links
        handleAILink(event) {
            const link = event.getSource();
            const url = link.data("url");

            if (url) {
                sap.m.MessageBox.confirm(
                    `Möchten Sie diesen Link öffnen?\n\n${url}`,
                    {
                        title: "Externen Link öffnen",
                        onClose: (action) => {
                            if (action === sap.m.MessageBox.Action.OK) {
                                window.open(url, '_blank', 'noopener,noreferrer');
                            }
                        }
                    }
                );
            }
        }
    }


    // Create singleton instance
    const chatManager = new ChatManager();

    // Modern Chat Controller with arrow functions
    const chatController = {
        mentionEventsBound: false,

        onInputLiveChange(event) {
            const inputControl = event.getSource();
            const value = event.getParameter('value');

            chatManager.chatModel.setProperty('/userInput', value);
            this._refreshMentionSuggestions(inputControl);
        },

        onMentionListItemPress(event) {
            const listItem = event.getParameter('listItem');
            const ctx = listItem?.getBindingContext('chat');
            const text = ctx?.getProperty('text');
            if (text) {
                this._applyMentionSelection(text);
            }
        },

        onMentionItemPress(event) {
            const ctx = event.getSource()?.getBindingContext('chat');
            const text = ctx?.getProperty('text');
            if (text) {
                this._applyMentionSelection(text);
            }
        },

        onMentionPopoverClosed() {
            this._resetMentionState();
        },

        _getInputControl() {
            return sap.ui.core.Fragment.byId('chatSidePanelFragmentGlobal', 'chatInputField');
        },

        _getMentionPopover() {
            return sap.ui.core.Fragment.byId('chatSidePanelFragmentGlobal', 'mentionPopover');
        },

        _getMentionList() {
            return sap.ui.core.Fragment.byId('chatSidePanelFragmentGlobal', 'mentionList');
        },

        _isMentionPopoverOpen() {
            return Boolean(chatManager.isMentionOpen);
        },

        _ensureMentionBindings() {
            if (this.mentionEventsBound) {
                return;
            }

            const input = this._getInputControl();
            if (!input || typeof input.attachBrowserEvent !== 'function') {
                return;
            }

            input.attachBrowserEvent('keydown', (event) => {
                this._handleInputKeydown(event, input);
            });

            input.attachBrowserEvent('keyup', () => {
                this._refreshMentionSuggestions(input);
            });

            input.attachBrowserEvent('click', () => {
                this._refreshMentionSuggestions(input);
            });

            input.attachBrowserEvent('focusout', () => {
                setTimeout(() => {
                    const popover = this._getMentionPopover();
                    const popDom = popover?.getDomRef?.();
                    const active = document.activeElement;
                    if (popover && popover.isOpen && popover.isOpen() && popDom && active && popDom.contains(active)) {
                        return;
                    }
                    this._closeMentionPopover();
                }, 0);
            });

            this.mentionEventsBound = true;
        },

        _handleInputKeydown(event, inputControl) {
            const popover = this._getMentionPopover();
            const mentionOpen = popover && popover.isOpen && popover.isOpen();

            if (mentionOpen) {
                if (event.key === 'ArrowDown' || (event.key === 'Tab' && !event.shiftKey)) {
                    event.preventDefault();
                    this._moveMentionSelection(1);
                    return;
                }

                if (event.key === 'ArrowUp' || (event.key === 'Tab' && event.shiftKey)) {
                    event.preventDefault();
                    this._moveMentionSelection(-1);
                    return;
                }

                if (event.key === 'Enter' && !event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey) {
                    event.preventDefault();
                    const list = this._getMentionList();
                    const selected = list?.getSelectedItem?.();
                    const item = selected || (list?.getItems ? list.getItems()[0] : null);
                    const ctx = item?.getBindingContext('chat');
                    const text = ctx?.getProperty('text');
                    if (text) {
                        this._applyMentionSelection(text);
                    } else {
                        this._closeMentionPopover();
                    }
                    return;
                }

                if (event.key === 'Escape') {
                    event.preventDefault();
                    this._closeMentionPopover();
                    return;
                }
            }

            if (event.key === 'Enter' && !event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey) {
                event.preventDefault();
                const currentValue = inputControl.getValue ? inputControl.getValue() : chatManager.chatModel.getProperty('/userInput');
                chatManager.chatModel.setProperty('/userInput', currentValue);
                if (typeof inputControl.fireChange === 'function') {
                    inputControl.fireChange({ value: currentValue });
                }
                this.onSendChatMessageInSidePanel(currentValue);
                return;
            }

            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End'].includes(event.key)) {
                setTimeout(() => {
                    this._refreshMentionSuggestions(inputControl);
                }, 0);
            }
        },

        _moveMentionSelection(offset) {
            const list = this._getMentionList();
            if (!list || !list.getItems) {
                return;
            }

            const items = list.getItems();
            if (!items.length) {
                return;
            }

            let nextIndex = chatManager._mentionSelectionIndex || 0;
            nextIndex = (nextIndex + offset + items.length) % items.length;
            chatManager._mentionSelectionIndex = nextIndex;

            const item = items[nextIndex];
            if (item && list.setSelectedItem) {
                list.setSelectedItem(item);
            }
        },

        _refreshMentionSuggestions(inputControl) {
            if (!inputControl || typeof inputControl.getValue !== 'function') {
                this._closeMentionPopover();
                return;
            }

            const domRef = inputControl.getFocusDomRef && inputControl.getFocusDomRef();
            if (!domRef || domRef.selectionStart == null) {
                this._closeMentionPopover();
                return;
            }

            const value = inputControl.getValue() || '';
            const cursor = domRef.selectionStart;
            const tokenStart = this._locateMentionTokenStart(value, cursor);

            if (tokenStart === -1) {
                this._closeMentionPopover();
                return;
            }

            const rawFilter = value.slice(tokenStart + 1, cursor);
            if (/\s/.test(rawFilter)) {
                this._closeMentionPopover();
                return;
            }

            const filterValue = rawFilter.trim().toLowerCase();
            const popover = this._getMentionPopover();
            const list = this._getMentionList();

            if (!popover || !list) {
                return;
            }

            const binding = list.getBinding && list.getBinding('items');
            if (binding) {
                const filters = filterValue
                    ? [new Filter({ path: 'text', test: (text) => typeof text === 'string' && text.toLowerCase().includes(filterValue) })]
                    : [];
                binding.filter(filters);
            }

            const items = list.getItems ? list.getItems() : [];
            if (!items.length) {
                this._closeMentionPopover();
                return;
            }

            chatManager.isMentionOpen = true;
            chatManager._mentionTokenStart = tokenStart;
            chatManager._mentionCursor = cursor;
            chatManager._mentionValue = value;
            chatManager._mentionFilter = rawFilter;
            chatManager._mentionSelectionIndex = 0;
            chatManager.chatModel.setProperty('/showSuggestions', true);

            if (list.removeSelections) {
                list.removeSelections(true);
            }
            if (list.setSelectedItem) {
                list.setSelectedItem(items[0]);
            }

            if (popover.isOpen && popover.isOpen()) {
                if (popover.rerender) {
                    popover.rerender();
                }
            } else if (popover.openBy) {
                popover.openBy(inputControl);
            }
        },

        _locateMentionTokenStart(value, cursor) {
            if (!value || cursor == null) {
                return -1;
            }

            let index = cursor - 1;
            while (index >= 0) {
                const ch = value.charAt(index);
                if (ch === '@') {
                    const prev = index > 0 ? value.charAt(index - 1) : ' ';
                    if (/\s/.test(prev)) {
                        return index;
                    }
                    return -1;
                }
                if (/\s/.test(ch)) {
                    return -1;
                }
                index -= 1;
            }
            return -1;
        },

        _applyMentionSelection(selectedText) {
            if (!selectedText) {
                this._closeMentionPopover();
                return;
            }

            const inputControl = this._getInputControl();
            const domRef = inputControl?.getFocusDomRef?.();
            if (!inputControl || !domRef) {
                this._closeMentionPopover();
                return;
            }

            const currentValue = inputControl.getValue() || '';
            const cursor = domRef.selectionStart != null ? domRef.selectionStart : chatManager._mentionCursor || currentValue.length;
            let tokenStart = chatManager._mentionTokenStart;

            if (tokenStart == null || tokenStart < 0 || currentValue.charAt(tokenStart) !== '@') {
                tokenStart = this._locateMentionTokenStart(currentValue, cursor);
                if (tokenStart === -1) {
                    this._closeMentionPopover();
                    return;
                }
            }

            const tokenEnd = cursor;
            const before = currentValue.slice(0, tokenStart);
            const after = currentValue.slice(tokenEnd);
            const cleanText = String(selectedText).trim();
            const needsSpace = after.length === 0 ? true : !/^\s/.test(after);
            const insertion = needsSpace ? `${cleanText} ` : cleanText;
            const newValue = `${before}${insertion}${after}`;

            inputControl.setValue(newValue);
            chatManager.chatModel.setProperty('/userInput', newValue);

            this._closeMentionPopover();

            setTimeout(() => {
                const focusDom = inputControl.getFocusDomRef && inputControl.getFocusDomRef();
                if (focusDom && typeof focusDom.setSelectionRange === 'function') {
                    const pos = before.length + cleanText.length + (needsSpace ? 1 : 0);
                    focusDom.setSelectionRange(pos, pos);
                }
            }, 0);
        },

        _closeMentionPopover() {
            const popover = this._getMentionPopover();
            if (popover && popover.isOpen && popover.isOpen()) {
                popover.close();
            } else {
                this._resetMentionState();
            }
        },

        _resetMentionState() {
            chatManager.isMentionOpen = false;
            chatManager._mentionTokenStart = null;
            chatManager._mentionFilter = '';
            chatManager._mentionCursor = null;
            chatManager._mentionValue = '';
            chatManager._mentionSelectionIndex = 0;
            if (chatManager.chatModel) {
                chatManager.chatModel.setProperty('/showSuggestions', false);
            }

            const list = this._getMentionList();
            if (list) {
                if (list.removeSelections) {
                    list.removeSelections(true);
                }
                const binding = list.getBinding && list.getBinding('items');
                if (binding) {
                    binding.filter([]);
                }
            }
        },

        async onSendChatMessageInSidePanel() {
            this._closeMentionPopover();

            // Get the input field to ensure we have the latest value
            const inputField = sap.ui.core.Fragment.byId("chatSidePanelFragmentGlobal", "chatInputField");
            const currentValue = inputField?.getValue()?.trim() || "";
            
            // Update model with current input field value if needed
            if (currentValue !== chatManager.chatModel.getProperty("/userInput")) {
                chatManager.chatModel.setProperty("/userInput", currentValue);
            }
            
            const userInput = currentValue;

            if (!userInput) {
                chatManager.setStatusMessage("Please enter a message.");
                return;
            }

            // Add user message
            chatManager.addMessage("user", userInput);

            // Clear input and set loading state
            chatManager.chatModel.setProperty("/userInput", "");
            chatManager.chatModel.setProperty("/isTyping", true);
            chatManager.setStatusMessage("Sending...", 0);

            // Add thinking placeholder

            try {
                // Call Claude service directly
                const aiResponse = await chatManager.callLLMViaOperationBinding(userInput);

                // Handle successful response
                chatManager.handleAIResponse(aiResponse);
                chatManager.setStatusMessage("Response received", 2000);

            } catch (error) {
                console.error("Claude service call failed:", error);
                chatManager.handleAIError(error.message || "Failed to get response from AI service");
            }
        },

        onToggleNotifications(event) {
            const popover = sap.ui.core.Fragment.byId('chatSidePanelFragmentGlobal', 'notificationsPopover');
            if (!popover) {
                return;
            }

            const isOpen = popover.isOpen && popover.isOpen();
            if (isOpen) {
                popover.close();
                return;
            }

            const sourceButton = event?.getSource?.();
            const fallbackButton = sap.ui.core.Fragment.byId('chatSidePanelFragmentGlobal', 'notificationsButton');
            const target = sourceButton || fallbackButton;

            if (popover.openBy && target) {
                popover.openBy(target);
            } else if (popover.open) {
                popover.open();
            }

            chatManager.setHasNew(false);
        },

        onSendNotificationToAgent(event) {
            const control = event?.getSource?.();
            const context = control?.getBindingContext('notifications');
            const mailItem = context?.getObject();

            if (!mailItem) {
                chatManager.setStatusMessage('Keine Mail ausgewählt', 2000);
                return;
            }

            chatManager.sendMailContextToAgent(mailItem);
        },

        onCloseNotification(event) {
            const control = event?.getSource?.();
            const context = control?.getBindingContext('notifications');
            const mailItem = context?.getObject();

            if (!mailItem || !mailItem.id) {
                chatManager.setStatusMessage('Benachrichtigung nicht gefunden', 2000);
                return;
            }

            chatManager.removeNotificationById(mailItem.id);

            const remaining = chatManager.notificationsModel?.getProperty('/items') || [];
            if (!remaining.length) {
                const popover = sap.ui.core.Fragment.byId('chatSidePanelFragmentGlobal', 'notificationsPopover');
                if (popover?.isOpen && popover.isOpen()) {
                    popover.close();
                }
            }
        },

        onOpenNotificationLink(event) {
            const control = event?.getSource?.();
            const context = control?.getBindingContext('notifications');
            const mailItem = context?.getObject();

            if (!mailItem) {
                chatManager.setStatusMessage('Keine Mail ausgewählt', 2000);
                return;
            }

            const linkTarget = mailItem.webLink
                || mailItem.deepLink
                || mailItem.url
                || mailItem.link;

            if (linkTarget) {
                window.open(linkTarget, '_blank', 'noopener,noreferrer');
            } else {
                chatManager.setStatusMessage('Kein Link für diese Benachrichtigung vorhanden', 2000);
            }
        },


        onClearChatHistory() {
            sap.m.MessageBox.confirm(
                "Start a new chat? This will clear your current conversation.",
                {
                    title: "New Chat",
                    onClose: (action) => {
                        if (action === sap.m.MessageBox.Action.OK) {
                            // Reset chat state
                            Object.assign(chatManager.chatModel.getData(), {
                                chatHistory: [],
                                userInput: "",
                                isTyping: false,
                                statusMessage: "New chat started"
                            });

                            // Add welcome message
                            chatManager.addMessage(
                                "system",
                                "New conversation started. How can I help you today?"
                            );

                            chatManager.setStatusMessage("New chat started");
                        }
                    }
                }
            );
        },

        async onCopyMessage(event) {
            const context = event.getSource().getBindingContext("chat");
            const messageText = context.getProperty("text");
            await chatManager.copyToClipboard(messageText);
        },

        onAttachFile() {
            // Placeholder for future file upload functionality
            chatManager.setStatusMessage("File attachment coming soon...");
        },

        onVoiceInput() {
            chatManager.startVoiceInput();
        },

        // Code-Block Kopier-Funktion
        async onCopyCodeBlock(event) {
            const button = event.getSource();
            const codeBlock = button.getParent().getParent(); // Navigation zum Code-Block
            const codeContent = codeBlock.querySelector('.ai-code-content');

            if (codeContent) {
                const code = codeContent.textContent;
                await chatManager.copyToClipboard(code);
                button.setText("Kopiert!");
                setTimeout(() => button.setText("Kopieren"), 2000);
            }
        },

        // Erweiterte Nachrichtenbehandlung
        onSendChatMessageInSidePanelEnhanced: async function () {
            this._closeMentionPopover();

            const userInput = chatManager.chatModel.getProperty("/userInput")?.trim();

            if (!userInput) {
                chatManager.setStatusMessage("Bitte geben Sie eine Nachricht ein.");
                return;
            }

            // Add user message mit enhanced method
            chatManager.addMessageEnhanced("user", userInput);

            // Clear input and set loading state
            chatManager.chatModel.setProperty("/userInput", "");
            chatManager.chatModel.setProperty("/isTyping", true);
            chatManager.setStatusMessage("AI denkt nach...", 0);

            try {
                // Call Claude service
                const aiResponse = await chatManager.callLLMViaOperationBinding(userInput);

                // Handle successful HTML response
                chatManager.handleAIResponseEnhanced(aiResponse);
                chatManager.setStatusMessage("Antwort erhalten", 2000);

            } catch (error) {
                console.error("Claude service call failed:", error);
                chatManager.handleAIError(error.message || "Fehler beim Abrufen der AI-Antwort");
            }
        },

        // Erweiterte AI Response Handler
        handleAIResponseEnhanced(responseText) {
            this.removeThinkingMessage();

            // Verwende enhanced addMessage für HTML-Content
            this.addMessageEnhanced("assistant", responseText);

            this.chatModel.setProperty("/isTyping", false);
            this.chatModel.setProperty("/statusMessage", "");

            // Zusätzliche UI-Updates für HTML-Content
            this.enhanceRenderedHTMLContent();
        },

        // Post-Processing für gerenderten HTML-Content
        enhanceRenderedHTMLContent() {
            setTimeout(() => {
                // Füge Event-Listener für AI-Links hinzu
                const aiLinks = document.querySelectorAll('.ai-link');
                aiLinks.forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const url = link.getAttribute('data-url');
                        if (url) {
                            sap.m.MessageBox.confirm(
                                `Möchten Sie diesen Link öffnen?\n\n${url}`,
                                {
                                    title: "Externen Link öffnen",
                                    onClose: (action) => {
                                        if (action === sap.m.MessageBox.Action.OK) {
                                            window.open(url, '_blank', 'noopener,noreferrer');
                                        }
                                    }
                                }
                            );
                        }
                    });
                });

                // Füge Kopieren-Buttons zu Code-Blöcken hinzu
                const codeBlocks = document.querySelectorAll('.ai-code-block');
                codeBlocks.forEach(block => {
                    if (!block.querySelector('.ai-copy-button')) {
                        const copyButton = document.createElement('button');
                        copyButton.className = 'ai-copy-button';
                        copyButton.innerHTML = '📋 Kopieren';
                        copyButton.onclick = async () => {
                            const code = block.querySelector('.ai-code-content').textContent;
                            await chatManager.copyToClipboard(code);
                            copyButton.innerHTML = '✅ Kopiert!';
                            setTimeout(() => copyButton.innerHTML = '📋 Kopieren', 2000);
                        };

                        const header = block.querySelector('.ai-code-header');
                        if (header) {
                            header.appendChild(copyButton);
                        }
                    }
                });
            }, 100);
        }


    };

    // Enhanced global functions
    const globalFunctions = {
        addAIResponse: (responseText) => chatManager.handleAIResponse(responseText),
        addSystemMessage: (message) => chatManager.addMessage("system", message),
        handleAIError: (errorMessage) => chatManager.handleAIError(errorMessage),
        triggerChatScroll: () => chatManager.scrollToBottom()
    };

    // Assign to window for external access
    Object.assign(window, globalFunctions);

    // Modern keyboard shortcuts with better event handling
    const setupKeyboardShortcuts = () => {
        document.addEventListener('keydown', (event) => {
            if (event.defaultPrevented) {
                return;
            }

            const { key, ctrlKey, metaKey, shiftKey, altKey } = event;
            const inputField = sap.ui.core.Fragment.byId("chatSidePanelFragmentGlobal", "chatInputField");
            const inputDomRef = inputField?.getFocusDomRef();
            const isInputFocused = inputDomRef === document.activeElement;

            if (!isInputFocused) {
                return;
            }

            if (chatController._isMentionPopoverOpen()) {
                if (key === 'Escape' && !shiftKey && !ctrlKey && !metaKey && !altKey) {
                    event.preventDefault();
                    chatController._closeMentionPopover();
                }
                return;
            }

            if (key === 'Enter' && !shiftKey && !ctrlKey && !metaKey && !altKey) {
                event.preventDefault();
                chatController.onSendChatMessageInSidePanel();
                return;
            }

            if (key === 'Escape' && !ctrlKey && !metaKey && !altKey) {
                chatManager.chatModel.setProperty('/userInput', '');
            }
        });
    };

    // Modern app initialization with async/await
    const initializeApp = async () => {
        try {
            // Initialize chat model
            chatManager.initializeChatModel();
            chatManager.initializeNotificationsModel();

            // Load chat fragment
            const chatPanelContent = await Fragment.load({
                id: "chatSidePanelFragmentGlobal",
                name: "sap.stammtisch.ui.app.ext.ChatSidePanelContent",
                controller: chatController
            });

            chatManager.chatPanel = new Panel("chatRightPane", {
                height: "100%",
                width: "100%",
                content: [chatPanelContent]
            });
            chatManager.chatPanel.setModel(chatManager.chatModel, "chat");
            chatManager.chatPanel.setModel(chatManager.notificationsModel, "notifications");
            chatManager.chatPanel.setLayoutData(new SplitterLayoutData({
                size: "420px",
                resizable: true,
                minSize: 280
            }));

            chatController._ensureMentionBindings();

            // Create Fiori Elements component
            const feComponent = await Component.create({
                name: "sap.stammtisch.ui.app",
                id: "feAppComponentCore"
            });

            chatManager.feAppComponentInstance = feComponent;

            // Set external dependencies if available
            if (feComponent.setExternalDependencies) {
                feComponent.setExternalDependencies(
                    chatManager.chatModel,
                    chatManager.chatPanel
                );
            } else {
                console.warn(
                    "Method 'setExternalDependencies' not found on FE Component. " +
                    "Chat/SidePanel might not be fully functional from custom actions."
                );
            }

            // Create component container and app structure
            const componentContainer = new ComponentContainer({
                component: feComponent,
                height: "100%"
            });

            chatManager.mainSplitter = new Splitter("mainSplitter", {
                height: "100%",
                orientation: "Horizontal"
            });
            chatManager.mainSplitter.addContentArea(componentContainer);
            chatManager.mainSplitter.addContentArea(chatManager.chatPanel);

            const mainPage = new Page("mainAppPage", {
                showHeader: false,
                content: [chatManager.mainSplitter],
                height: "100%"
            });

            const appControl = new App({
                pages: [mainPage],
                height: "100%"
            });

            // Mount app
            appControl.placeAt("appHost");

            // Setup keyboard shortcuts
            setupKeyboardShortcuts();

            // Connect notifications stream
            chatManager.setupNotificationsSSE();

            try {
                await chatManager.getTopicsSnapshot({ force: true });
            } catch (topicError) {
                console.warn("Initiales Laden der Stammtisch-Themen fehlgeschlagen:", topicError);
            }

            console.log("Application initialized successfully");

        } catch (error) {
            console.error("Failed to initialize application:", error);

            const appHostDiv = document.getElementById("appHost");
            if (appHostDiv) {
                appHostDiv.innerHTML = `
                    <div style="padding: 20px; color: #d32f2f; font-family: Arial, sans-serif;">
                        <h2>Application Error</h2>
                        <p><strong>Error:</strong> ${error.message}</p>
                        <p>Please check the console for more details.</p>
                    </div>
                `;
            }
        }
    };



    // Initialize when SAP UI5 core is ready
    sap.ui.getCore().attachInit(initializeApp);
});
</file>

<file path="srv/service.js">
// srv/StammtischService.js

import cds from '@sap/cds';
import express from 'express';
import { loadMcpTools } from '@langchain/mcp-adapters';
import { createReactAgent } from "@langchain/langgraph/prebuilt";
import { AzureOpenAiChatClient } from "@sap-ai-sdk/langchain";
import { MemorySaver } from "@langchain/langgraph-checkpoint";
import { DynamicStructuredTool } from "@langchain/core/tools";
import { z } from "zod";
import path from 'node:path';
import { existsSync } from 'node:fs';
import { mkdir } from 'node:fs/promises';
import { initAllMCPClients, closeMCPClients } from './lib/mcp-client.js';
import { jsonSchemaToZod } from './m365-mcp/mcp-jsonschema.js';
import { GraphClient } from './m365-mcp/graph-client.js';
import MarkdownConverter from './utils/markdown-converter.js';

export default class StammtischService extends cds.ApplicationService {
  async init() {
    await super.init();
    let agentExecutor = null;
    let mcpClients = null;
    const app = cds.app;

    // Lightweight in-memory notification hub (per-user)
    const notificationSessions = new Map(); // userId -> { clients:Set<Response>, buffer:[], knownIds:Set<string>, timer:NodeJS.Timer|null }

    const getUserId = (req) => {
      try {
        return (req.user && (req.user.id || req.user.name)) || 'local';
      } catch {
        return 'local';
      }
    };

    const sseSend = (res, payload) => {
      res.write(`data: ${JSON.stringify(payload)}\n\n`);
    };

    const broadcastToUser = (userId, payload) => {
      const session = notificationSessions.get(userId);
      if (!session) return;
      for (const client of session.clients) {
        try { sseSend(client, payload); } catch { /* ignore */ }
      }
    };

    const ensureSession = (userId) => {
      if (!notificationSessions.has(userId)) {
        notificationSessions.set(userId, {
          clients: new Set(),
          buffer: [],
          knownIds: new Set(),
          summaries: new Map(),
          timer: null
        });
      }
      return notificationSessions.get(userId);
    };

    const summarizer = new AzureOpenAiChatClient({ modelName: 'gpt-4.1' });

    const SUMMARY_MAX_INPUT_CHARS = 6000;
    const SUMMARY_MAX_OUTPUT_CHARS = 280;
    const SUMMARY_FALLBACK = 'Keine Zusammenfassung verfügbar.';
    const SUMMARY_CATEGORIES = ['To Respond', 'Notification', 'FYI', 'Meeting Update', 'Action needed', 'Completed'];
    const DEFAULT_CATEGORY = 'Notification';
    const ATTACHMENTS_DIR = process.env.M365_ATTACHMENT_BASE_PATH
      ? path.resolve(process.env.M365_ATTACHMENT_BASE_PATH)
      : path.resolve(process.cwd(), 'tmp', 'attachments');
    const EXCEL_EXTENSIONS = new Set(['.xlsx', '.xls', '.xlsm', '.xlsb', '.csv']);
    const EXCEL_MIME_PREFIXES = [
      'application/vnd.openxmlformats-officedocument.spreadsheetml',
      'application/vnd.ms-excel',
      'text/csv',
      'application/vnd.ms-excel.sheet'
    ];

    let attachmentDirReadyPromise = null;

    const stripHtml = (html = '') => html
      .replace(/<style[\s\S]*?<\/style>/gi, ' ')
      .replace(/<script[\s\S]*?<\/script>/gi, ' ')
      .replace(/<[^>]+>/g, ' ');

    const normalizeWhitespace = (text = '') => text.replace(/\s+/g, ' ').trim();

    const truncate = (text = '', maxLength = SUMMARY_MAX_OUTPUT_CHARS) => {
      if (text.length <= maxLength) return text;
      return `${text.slice(0, Math.max(0, maxLength - 1)).trim()}…`;
    };

    const ensureAttachmentDir = async () => {
      if (!attachmentDirReadyPromise) {
        attachmentDirReadyPromise = mkdir(ATTACHMENTS_DIR, { recursive: true }).catch(() => {});
      }
      await attachmentDirReadyPromise;
    };

    const sanitizeFileName = (name = '') => {
      const safe = name.replace(/[^a-z0-9_.-]+/gi, '_').replace(/_+/g, '_').trim();
      if (safe) return safe;
      return `attachment_${Date.now()}`;
    };

    const isExcelAttachment = (attachment) => {
      if (!attachment) return false;
      const name = (attachment.name || '').toLowerCase();
      const ext = path.extname(name);
      if (ext && EXCEL_EXTENSIONS.has(ext)) return true;
      const type = (attachment.contentType || '').toLowerCase();
      return EXCEL_MIME_PREFIXES.some((prefix) => type.startsWith(prefix));
    };

    const parseMcpContent = (payload) => {
      if (!payload) return null;
      if (typeof payload === 'string') {
        try {
          return JSON.parse(payload);
        } catch {
          return payload;
        }
      }
      if (Array.isArray(payload)) {
        const parsed = payload
          .map((entry) => parseMcpContent(entry))
          .filter((entry) => entry !== null && entry !== undefined);
        if (parsed.length === 1) return parsed[0];
        return parsed;
      }
      if (typeof payload === 'object') {
        if (Array.isArray(payload.content)) {
          const parts = payload.content
            .map((part) => {
              if (!part) return null;
              if (typeof part === 'string') return parseMcpContent(part);
              if (typeof part.text === 'string') return parseMcpContent(part.text);
              if (part.json !== undefined) return part.json;
              if (part.data !== undefined) return part.data;
              return null;
            })
            .filter((entry) => entry !== null && entry !== undefined);
          if (parts.length === 1) return parts[0];
          return parts;
        }
        return payload;
      }
      return payload;
    };

    const callExcelTool = async (toolName, args) => {
      if (!mcpClients?.excel) return null;
      try {
        const result = await mcpClients.excel.callTool({ name: toolName, arguments: args });
        return parseMcpContent(result) ?? null;
      } catch (error) {
        console.warn(`Excel tool ${toolName} failed:`, error?.message || error);
        return null;
      }
    };

    const extractSheetNames = (describeResult) => {
      if (!describeResult) return [];
      if (Array.isArray(describeResult)) {
        return describeResult
          .map((entry) => {
            if (!entry) return null;
            if (typeof entry === 'string') return entry;
            if (entry.name) return entry.name;
            if (entry.sheetName) return entry.sheetName;
            return null;
          })
          .filter(Boolean);
      }
      if (Array.isArray(describeResult.sheets)) {
        return describeResult.sheets
          .map((sheet) => (sheet?.name || sheet?.sheetName || (typeof sheet === 'string' ? sheet : null)))
          .filter(Boolean);
      }
      if (Array.isArray(describeResult.sheetNames)) {
        return describeResult.sheetNames.filter(Boolean);
      }
      if (typeof describeResult.sheetName === 'string') {
        return [describeResult.sheetName];
      }
      return [];
    };

    const loadExcelAttachmentContext = async (filePath) => {
      const describeResult = await callExcelTool('excel_describe_sheets', { fileAbsolutePath: filePath });
      const sheetNames = extractSheetNames(describeResult);

      const sheets = [];
      for (const sheetName of sheetNames) {
        try {
          const sheetData = await callExcelTool('excel_read_sheet', {
            fileAbsolutePath: filePath,
            sheetName
          });
          sheets.push({ sheetName, data: sheetData });
        } catch (error) {
          console.warn('Failed to read Excel sheet', sheetName, error?.message || error);
          sheets.push({ sheetName, error: String(error?.message || error) });
        }
      }

      return {
        describe: describeResult,
        sheets
      };
    };

    const ensureExcelAttachmentDetails = async (message, summaryEntry) => {
      if (!summaryEntry?.agentContext) return;
      const attachments = Array.isArray(message?.attachments) ? message.attachments : [];
      if (!attachments.length) return;

      await ensureAttachmentDir();

      const enriched = [];
      for (const attachment of attachments) {
        const baseInfo = {
          id: attachment.id || null,
          name: attachment.name || null,
          contentType: attachment.contentType || null,
          size: attachment.size ?? null,
          isInline: Boolean(attachment.isInline)
        };

        if (!isExcelAttachment(attachment) || attachment.isInline) {
          enriched.push(baseInfo);
          continue;
        }

        if (!attachment.id || !message.id) {
          enriched.push({ ...baseInfo, error: 'attachment id or message id missing' });
          continue;
        }

        const safeName = sanitizeFileName(attachment.name || `${message.id}-${attachment.id}.xlsx`);
        const targetPath = path.join(ATTACHMENTS_DIR, safeName);

        try {
          if (!existsSync(targetPath)) {
            await graph.downloadAttachment({
              messageId: message.id,
              attachmentId: attachment.id,
              targetPath
            });
          }

          const excel = await loadExcelAttachmentContext(targetPath);
          enriched.push({
            ...baseInfo,
            path: targetPath,
            excel
          });
        } catch (error) {
          console.warn('Failed to process Excel attachment:', attachment.name, error?.message || error);
          enriched.push({ ...baseInfo, path: targetPath, error: String(error?.message || error) });
        }
      }

      summaryEntry.agentContext.attachments = enriched;
    };

    const escapeHtml = (text = '') => text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');

    const sanitizeEmailHtml = (html = '') => {
      if (!html) return '';
      let sanitized = html;
      sanitized = sanitized.replace(/<script[\s\S]*?<\/script>/gi, '');
      sanitized = sanitized.replace(/<style[\s\S]*?<\/style>/gi, '');
      sanitized = sanitized.replace(/<link[\s\S]*?>/gi, '');
      sanitized = sanitized.replace(/<iframe[\s\S]*?<\/iframe>/gi, '');
      sanitized = sanitized.replace(/<object[\s\S]*?<\/object>/gi, '');
      sanitized = sanitized.replace(/<embed[\s\S]*?<\/embed>/gi, '');
      sanitized = sanitized.replace(/<base[\s\S]*?>/gi, '');
      sanitized = sanitized.replace(/\s+on[a-z]+\s*=\s*"[^"]*"/gi, '');
      sanitized = sanitized.replace(/\s+on[a-z]+\s*=\s*'[^']*'/gi, '');
      sanitized = sanitized.replace(/\s+on[a-z]+\s*=\s*[^\s>]+/gi, '');
      sanitized = sanitized.replace(/javascript:/gi, '');
      sanitized = sanitized.replace(/data:text\/html;[^"'>]+/gi, '');
      return sanitized.trim();
    };

    const getSanitizedBodyHtml = (message) => {
      if (!message?.body?.content) return null;
      const { content, contentType } = message.body;
      if (!content) return null;
      if (contentType === 'html') {
        return sanitizeEmailHtml(content);
      }
      const plain = typeof content === 'string' ? content : String(content);
      return `<pre>${escapeHtml(plain)}</pre>`;
    };

    const extractMessageContent = (message) => {
      if (!message) return '';
      const { body } = message;
      if (body?.content) {
        const raw = body.contentType === 'html' ? stripHtml(body.content) : body.content;
        return normalizeWhitespace(raw);
      }
      if (message.bodyPreview) {
        return normalizeWhitespace(message.bodyPreview);
      }
      return '';
    };

    const extractModelOutput = (result) => {
      if (!result) return '';
      if (typeof result === 'string') return result;
      if (typeof result.content === 'string') return result.content;
      if (Array.isArray(result.content)) {
        return result.content
          .map((part) => {
            if (typeof part === 'string') return part;
            if (part?.text) return part.text;
            return '';
          })
          .filter(Boolean)
          .join(' ');
      }
      if (result.text) return result.text;
      return '';
    };

    const extractMailParticipant = (entry) => {
      if (!entry) return null;
      const emailAddress = entry.emailAddress || entry;
      const address = emailAddress?.address || emailAddress?.emailAddress || emailAddress?.value || entry.address || null;
      const name = emailAddress?.name || emailAddress?.displayName || entry.name || entry.displayName || null;
      const formatted = name && address ? `${name} <${address}>` : (name || address || null);
      if (!formatted) return null;
      return {
        name,
        email: address,
        formatted
      };
    };

    const formatMailAddress = (entry) => {
      const participant = extractMailParticipant(entry);
      return participant?.formatted || null;
    };

    const mapRecipients = (list = []) => {
      if (!Array.isArray(list)) return [];
      return list
        .map(formatMailAddress)
        .filter(Boolean);
    };

    const mapRecipientDetails = (list = []) => {
      if (!Array.isArray(list)) return [];
      return list
        .map(extractMailParticipant)
        .filter(Boolean)
        .map((participant) => ({
          name: participant.name || null,
          email: participant.email || null
        }));
    };

    const buildAgentContext = (message, summary, category) => {
      const content = extractMessageContent(message) || '';
      const bodyPreview = normalizeWhitespace(message.bodyPreview || '').slice(0, SUMMARY_MAX_OUTPUT_CHARS);
      const sender = extractMailParticipant(message.from);
      const from = sender?.formatted || null;
      const toDetails = mapRecipientDetails(message.toRecipients);
      const ccDetails = mapRecipientDetails(message.ccRecipients);
      const bodyHtml = getSanitizedBodyHtml(message);
      return {
        id: message.id,
        subject: message.subject || '',
        from,
        sender: sender
          ? {
              name: sender.name || null,
              email: sender.email || null,
              formatted: sender.formatted
            }
          : null,
        toRecipients: mapRecipients(message.toRecipients),
        toRecipientDetails: toDetails,
        ccRecipients: mapRecipients(message.ccRecipients),
        ccRecipientDetails: ccDetails,
        receivedDateTime: message.receivedDateTime || null,
        webLink: message.webLink || null,
        hasAttachments: Boolean(message.hasAttachments),
        attachmentCount: Array.isArray(message.attachments) ? message.attachments.length : null,
        category,
        summary,
        bodyPreview,
        body: content,
        bodyText: content,
        bodyHtml,
        importance: message.importance || null,
        inferenceClassification: message.inferenceClassification || null,
        replyGuidelines: {
          defaultEmailRecipients: sender?.email ? [sender.email] : [],
          defaultCalendarAttendees: sender?.email ? [sender.email] : [],
          instructions: 'Bei Antworten oder Kalendereinladungen den ursprünglichen Absender automatisch als Empfänger hinzufügen, es sei denn, der Nutzer nennt ausdrücklich weitere Teilnehmer.'
        },
        attachments: []
      };
    };

    const finalizeSummaryResult = (message, summaryText, categoryText) => {
      const fallback = message.bodyPreview?.trim() || SUMMARY_FALLBACK;
      const normalizedSummary = normalizeWhitespace(summaryText || fallback);
      const truncated = truncate(normalizedSummary || fallback, SUMMARY_MAX_OUTPUT_CHARS);
      const normalizedCategory = SUMMARY_CATEGORIES.includes(categoryText) ? categoryText : DEFAULT_CATEGORY;
      const agentContext = buildAgentContext(message, truncated || fallback, normalizedCategory);
      return { summary: truncated || fallback, category: normalizedCategory, agentContext };
    };

    const generateSummaryForMessage = async (message) => {
      const content = extractMessageContent(message);
      const safeContent = content ? content.slice(0, SUMMARY_MAX_INPUT_CHARS) : '';
      const subject = message.subject || '';

      if (!safeContent) {
        return finalizeSummaryResult(message, message.bodyPreview, DEFAULT_CATEGORY);
      }

      const userPrompt = `Fasse die folgende E-Mail in höchstens zwei Sätzen (maximal 280 Zeichen) zusammen und kategorisiere sie.
Gültige Kategorien: To Respond, Notification, FYI, Meeting Update, Action needed, Completed.
Gib das Ergebnis ausschließlich als kompaktes JSON-Objekt zurück: {"summary":"...","category":"..."}.

Betreff: ${subject || '—'}

${safeContent}`;

      try {
        const response = await summarizer.invoke([
          {
            role: 'system',
            content: 'Du bist ein Assistent, der eingehende E-Mails prägnant in höchstens zwei Sätzen (maximal 280 Zeichen) zusammenfasst und sie in eine vorgegebene Kategorie einordnet. Antworte ausschließlich mit gültigem JSON im Format {"summary":"...","category":"..."}.'
          },
          {
            role: 'user',
            content: userPrompt
          }
        ]);

        const rawContent = (extractModelOutput(response) || '').trim();
        if (!rawContent) {
          return finalizeSummaryResult(message, null, DEFAULT_CATEGORY);
        }
        let parsed = null;
        try {
          const jsonMatch = rawContent.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            parsed = JSON.parse(jsonMatch[0]);
          } else {
            parsed = JSON.parse(rawContent);
          }
        } catch (parseError) {
          parsed = null;
        }

        if (parsed && typeof parsed === 'object') {
          const summaryCandidate = typeof parsed.summary === 'string' ? parsed.summary : null;
          const categoryCandidate = typeof parsed.category === 'string' ? parsed.category : DEFAULT_CATEGORY;
          return finalizeSummaryResult(message, summaryCandidate, categoryCandidate);
        }

        return finalizeSummaryResult(message, rawContent, DEFAULT_CATEGORY);
      } catch (error) {
        console.warn('Failed to generate mail summary:', error?.message || error);
        return finalizeSummaryResult(message, message.bodyPreview, DEFAULT_CATEGORY);
      }
    };

    const ensureSummaryForMessage = async (session, message) => {
      if (!message?.id) return finalizeSummaryResult(message, null, DEFAULT_CATEGORY);
      if (session.summaries.has(message.id)) {
        return session.summaries.get(message.id);
      }
      const summary = await generateSummaryForMessage(message);
      try {
        await ensureExcelAttachmentDetails(message, summary);
      } catch (error) {
        console.warn('ensureExcelAttachmentDetails failed:', error?.message || error);
      }
      session.summaries.set(message.id, summary);
      return summary;
    };

    const ensureSummariesForMessages = async (session, messages = []) => {
      for (const message of messages) {
        try {
          await ensureSummaryForMessage(session, message);
        } catch (error) {
          console.warn('ensureSummaryForMessage failed:', error?.message || error);
        }
      }
    };

    // Microsoft Graph client (CLI login based)
    const graph = new GraphClient({ logger: console });
    await graph.bootstrap(['Mail.Read', 'Mail.ReadWrite', 'Mail.Send', 'Calendars.Read', 'Calendars.ReadWrite']);

    const POLL_INTERVAL_MS = 10_000;
    const MAX_INIT_UNREAD = 10;

    const startPollerIfNeeded = async (userId) => {
      const session = ensureSession(userId);
      if (session.timer) return;

      // Initial fetch
      try {
        const initial = await graph.listUnreadMessages({ maxResults: MAX_INIT_UNREAD });
        session.buffer = initial;
        session.knownIds = new Set(initial.map(m => m.id));
        await ensureSummariesForMessages(session, session.buffer);
      } catch (e) {
        console.warn('Initial unread fetch failed:', e?.message || e);
      }

      session.timer = setInterval(async () => {
        try {
          const unread = await graph.listUnreadMessages({ maxResults: MAX_INIT_UNREAD });
          const currentIds = new Set(unread.map(m => m.id));

          // New arrivals
          for (const msg of unread) {
            if (!session.knownIds.has(msg.id)) {
              session.knownIds.add(msg.id);
              session.buffer.unshift(msg);
              // Trim buffer
              if (session.buffer.length > MAX_INIT_UNREAD) session.buffer.length = MAX_INIT_UNREAD;
              await ensureSummaryForMessage(session, msg);
              broadcastToUser(userId, { type: 'new', item: sanitizeMessage(msg, session) });
            }
          }

          // Items that disappeared (likely got marked as read elsewhere)
          for (const id of Array.from(session.knownIds)) {
            if (!currentIds.has(id)) {
              session.knownIds.delete(id);
              session.buffer = session.buffer.filter(x => x.id !== id);
              session.summaries.delete(id);
              broadcastToUser(userId, { type: 'read', id });
            }
          }
        } catch (e) {
          console.warn('Polling unread messages failed:', e?.message || e);
        }
      }, POLL_INTERVAL_MS);
    };

    const stopPollerIfOrphaned = (userId) => {
      const session = notificationSessions.get(userId);
      if (!session) return;
      if (session.clients.size === 0 && session.timer) {
        clearInterval(session.timer);
        session.timer = null;
      }
    };

    const sanitizeMessage = (msg, session) => {
      const cacheEntry = session?.summaries?.get(msg.id) || null;
      return {
        id: msg.id,
        subject: msg.subject || '',
        from: msg.from || null,
        receivedDateTime: msg.receivedDateTime,
        isRead: Boolean(msg.isRead),
        webLink: msg.webLink || '',
        summary: cacheEntry?.summary || null,
        category: cacheEntry?.category || null,
        agentContext: cacheEntry?.agentContext || null,
        hasAttachments: Boolean(msg.hasAttachments)
      };
    };

    // SSE stream endpoint
    app.get('/service/stammtisch/notifications/stream', async (req, res) => {
      const userId = getUserId(req);
      res.setHeader('Content-Type', 'text/event-stream');
      res.setHeader('Cache-Control', 'no-cache');
      res.setHeader('Connection', 'keep-alive');
      res.setHeader('X-Accel-Buffering', 'no');
      res.flushHeaders?.();

      const session = ensureSession(userId);
      session.clients.add(res);

      // Send initial buffer (unread only)
      try {
        // Ensure we have fresh buffer for this connect
        if (!session.buffer.length) {
          const initial = await graph.listUnreadMessages({ maxResults: MAX_INIT_UNREAD });
          session.buffer = initial;
          session.knownIds = new Set(initial.map(m => m.id));
          await ensureSummariesForMessages(session, session.buffer);
        } else {
          await ensureSummariesForMessages(session, session.buffer);
        }
        sseSend(res, { type: 'init', items: session.buffer.map((msg) => sanitizeMessage(msg, session)) });
      } catch (e) {
        sseSend(res, { type: 'error', message: String(e?.message || e) });
      }

      // Start poller if needed
      startPollerIfNeeded(userId);

      req.on('close', () => {
        const s = notificationSessions.get(userId);
        if (s) {
          s.clients.delete(res);
          stopPollerIfOrphaned(userId);
        }
      });
    });

    // Mark-as-read endpoint (backend-only, no MCP tool)
    app.post('/service/stammtisch/notifications/markRead', express.json(), async (req, res) => {
      try {
        const userId = getUserId(req);
        const { id } = req.body || {};
        if (!id) return res.status(400).json({ error: 'id is required' });
        await graph.markMessageRead(id, true);

        const session = ensureSession(userId);
        session.knownIds.delete(id);
        session.buffer = session.buffer.filter(x => x.id !== id);
        session.summaries.delete(id);
        broadcastToUser(userId, { type: 'read', id });
        return res.json({ status: 'ok', id });
      } catch (e) {
        console.error('markRead failed:', e);
        return res.status(500).json({ error: String(e?.message || e) });
      }
    });

    const initializeAgent = async () => {
      if (agentExecutor) return agentExecutor;

      // +++ ERWEITERT: Log-Nachricht angepasst +++
      console.log("Initializing Agent with Database, Web Search, Filesystem, Excel, Microsoft 365, and Time capabilities...");

      try {
        mcpClients = await initAllMCPClients();

        const [postgresTools, braveSearchTools, filesystemTools, excelTools, timeTools] = await Promise.all([
          loadMcpTools("query", mcpClients.postgres),
          loadMcpTools("brave_web_search,brave_local_search", mcpClients.braveSearch),
          loadMcpTools("read_file,write_file,edit_file,create_directory,list_directory,move_file,search_files,get_file_info,list_allowed_directories", mcpClients.filesystem),
          loadMcpTools("excel_describe_sheets,excel_read_sheet,excel_screen_capture,excel_write_to_sheet,excel_create_table,excel_copy_sheet", mcpClients.excel),
          loadMcpTools("get_current_time,convert_time", mcpClients.time)
        ]);

        // Kombiniere alle Tools
        const allTools = [...postgresTools, ...braveSearchTools, ...filesystemTools, ...excelTools, ...timeTools];

        // Lade Microsoft 365 Tools dynamisch aus dem Manifest
        if (mcpClients.m365) {
          console.log("Loading Microsoft 365 tools...");
          const manifest = await mcpClients.m365.listTools();
          const m365Tools = manifest.tools.map((toolDef) => {
            const schema = jsonSchemaToZod(toolDef.inputSchema, z);
            return new DynamicStructuredTool({
              name: toolDef.name,
              description: toolDef.description,
              schema,
              func: async (input) => {
                const result = await mcpClients.m365.callTool({ name: toolDef.name, arguments: input });
                return typeof result === 'string' ? result : JSON.stringify(result);
              }
            });
          });
          allTools.push(...m365Tools);
          console.log(`✅ Loaded ${m365Tools.length} Microsoft 365 tools`);
        }

        console.log(`✅ Loaded ${postgresTools.length} PostgreSQL, ${braveSearchTools.length} Brave Search, ${filesystemTools.length} Filesystem, ${excelTools.length} Excel, and ${timeTools.length} Time tools`);
        console.log("Available tools:", allTools.map(tool => tool.name));

        const llm = new AzureOpenAiChatClient({ modelName: 'gpt-4.1' });
        const checkpointer = new MemorySaver();

        agentExecutor = createReactAgent({
          llm,
          tools: allTools,
          checkpointSaver: checkpointer
        });
        
        // +++ ERWEITERT: Log-Nachricht angepasst +++
        console.log("✅ Multi-Modal Agent is ready (Database + Web Search + Filesystem + Excel + M365 + Time).");
        return agentExecutor;

      } catch (error) {
        console.error("❌ Failed to initialize agent:", error);
        throw error;
      }
    };

    await initializeAgent();

    this.on('callLLM', async (req) => {
      const { prompt: userPrompt } = req.data;
      if (!userPrompt) {
        req.error(400, 'Prompt is required');
        return;
      }

      console.log('🚀 Received prompt for Multi-Modal Agent:', userPrompt);
      const executor = await initializeAgent();

      try {
        const systemMessage = {
          role: "system",
          content: `You are a helpful assistant with access to database queries, web search, the local filesystem, Microsoft 365 (mail + calendar), and MS Excel capabilities, who helps the user Hoang by his work.

                   RESPONSE GUIDELINES:
              - Keep responses intentionally concise: focus on the key result, list only the most relevant steps, and offer extra details only when the user asks for them.
              - Highlight the most important information for the user by wrapping key phrases or sentences in **bold**.

                  DATABASE ACCESS:
                  - You can query a PostgreSQL database using the 'query' tool (SELECT only).
                  - Use 'execute_dml_ddl_dcl_tcl' for INSERT/UPDATE/DELETE/DDL and 'execute_commit' / 'execute_rollback' for transactions.
                  - IMPORTANT: PostgreSQL + CAP naming — never use dot-notation like sap.stammtisch.*.
                    CAP flattens CDS names to underscore table names. Always discover with 'list_tables' and verify columns with 'describe_table' before writing.
                  - Relevant tables: sap_stammtisch_stammtische (events), sap_stammtisch_praesentatoren (presenters), sap_stammtisch_teilnehmer (attendees).
                  - Quote columns exactly as returned by 'describe_table' (e.g., "ID", "praesentator_ID").
                  - If a command fails and you see "current transaction is aborted", immediately call 'execute_rollback' and then retry with corrected SQL.

                  STAMMTISCH IMPORT RULES (POC):
                  - ID generation rule: Always generate UUIDs using gen_random_uuid() (PostgreSQL pgcrypto) for any missing "id" fields and for "praesentator_ID" when mapping presenters.
                  - On explicit user approval to import a neues Thema, INSERT into table sap_stammtisch_stammtische using 'execute_dml_ddl_dcl_tcl' and then call 'execute_commit'.
                  - Columns to consider (confirm via 'describe_table'): "ID", "thema", "datum", "ort", "notizen", "praesentator_ID".
                  - ID: Prefer DB default. If needed, set "ID" = gen_random_uuid(); if the function is unavailable, omit "ID" so that the DB default generates it.
                  - datum: Build a timestamp at 18:00 local (ISO string, e.g., '2025-09-30T18:00:00Z'). Ask the user if the date is unknown.
                  - ort: Default to 'Luzern' unless the user provides a different location.
                  - Presenter mapping: For each value in the Excel column "Vorgetragen durch", set "praesentator_ID" to gen_random_uuid()
                  - Duplicate prevention: Compare normalized Themen against BekannteThemenJSON (case-insensitive, trim). If a duplicate is found, do not insert without explicit user approval.

                  WEB SEARCH ACCESS:
                  - You can search the web using 'brave_web_search'. 

                  FILESYSTEM ACCESS:
                  - You can read, write, and manage files and directories in the project.
                  - SECURITY: You can ONLY operate within the allowed project directory.
                  - Use 'list_directory' with '.' or a subdirectory to see available files first.
                  - For 'edit_file', ALWAYS use 'dryRun: true' first to preview changes.

                  MICROSOFT 365 ACCESS:
                  - Use mail tools for reading, replying, or downloading attachments.
                  - Use calendar tools only if the user explicitly asks to schedule or modify a meeting; do not create events when the user only requests text drafts.
                  - Before scheduling events with relative dates ("morgen", "übermorgen", "in X Tagen"), call the 'get_current_time' tool with timezone 'Europe/Berlin', compute the exact target date/time, confirm it with the user if unclear, and then create the event.

                  EXCEL ACCESS:
                  - You can read from and write to MS Excel files (.xlsx, .xlsm, etc.).
                  - Available tools: excel_describe_sheets, excel_read_sheet, excel_write_to_sheet, excel_create_table, excel_copy_sheet, excel_screen_capture (Windows only).
                  - ALWAYS start by using 'excel_describe_sheets' to understand the file's structure (sheet names).
                  - For all Excel tools, you MUST provide the 'fileAbsolutePath' to the target Excel file.
                  - When reading large sheets, the tool uses pagination. Pay attention to the 'knownPagingRanges' argument to read subsequent parts.
                  - When writing with 'excel_write_to_sheet', you can create a new sheet by setting 'newSheet: true'. Be careful as writing can modify files permanently.

                  ANALYSIS & VISUALIZATION WORKFLOW:
                  - If the user asks for an "analysis", "report", or "visualization" of data, you MUST follow this specific workflow:
                  1.  **Query Data:** First, use the 'query' tool to retrieve the necessary data from the PostgreSQL database. If the user's request is ambiguous (e.g., "analyze the data"), ask clarifying questions to determine which tables and columns are relevant for the analysis.
                  2.  **Generate HTML File:** After successfully retrieving the data, you will generate a single, self-contained HTML file to present the analysis and visualization.
                      -   **Structure:** Create a well-structured HTML5 document.
                      -   **Styling:** Include some basic CSS in a <style> tag in the <head> for a clean and professional look (e.g., set a modern font, center content, add padding).
                      -   **Visualization Library:** You MUST use a JavaScript charting library like **Chart.js** to create professional-looking charts (e.g., bar charts, line charts, pie charts). Include the library via its CDN link in a <script> tag in the <head>. Example: <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
                      -   **Content:** The HTML body should contain:
                          -   A clear headline (<h1>) describing the analysis (e.g., "Analyse der monatlichen Umsätze").
                          -   A <canvas> element where the chart will be rendered.
                          -   A <script> block at the end of the body. Inside this script, you will:
                              a) Store the data retrieved from the database in a JavaScript variable.
                              b) Write the JavaScript code to initialize Chart.js and render the chart on the canvas, using the data.
                  3.  **Save the File:** Use the 'edit_file' tool to write the complete HTML code into a new file.
                  4.  **Report Back:** Finally, after the file has been successfully created, inform the user that the analysis is complete and provide the full, correct path to the generated HTML file so they can open it.

                    `
                      };

        const userMessage = {
          role: "user",
          content: userPrompt
        };
        
        const stream = await executor.stream(
          {
            messages: [systemMessage, userMessage]
          },
          {
            configurable: { thread_id: `session_test}` }
          }
        );

        const finalResponseParts = [];
        console.log("\n\n---- AGENT STREAM START ----\n");

        for await (const chunk of stream) {
          if (chunk.agent?.messages) {
            const message = chunk.agent.messages[chunk.agent.messages.length - 1];
            if (message && message.content) {
              process.stdout.write(message.content);
              finalResponseParts.push(message.content);
            }
            if (message.tool_calls && message.tool_calls.length > 0) {
              const toolCall = message.tool_calls[0];
              const toolCallStr = `\n\n<TOOL_CALL>\n  Tool: ${toolCall.name}\n  Args: ${JSON.stringify(toolCall.args)}\n</TOOL_CALL>\n\n`;
              process.stdout.write(toolCallStr);
            }
          }

          if (chunk.tools?.messages) {
             const toolMessage = chunk.tools.messages[0];
             const toolOutputStr = `<TOOL_OUTPUT>\n  ${toolMessage.content}\n</TOOL_OUTPUT>\n\n`;
             process.stdout.write(toolOutputStr);
          }
        }
        console.log("\n---- AGENT STREAM END ----\n");

        const rawResponse = finalResponseParts.join("");
        const htmlResponse = MarkdownConverter.convertForStammtischAI(rawResponse);

        return { response: htmlResponse };

      } catch (error) {
        console.error('💥 Error during agent execution:', error);
        req.error(500, `Failed to process query: ${error.message}`);
      }
    });

    this.on('EXIT', async () => {
      console.log('Shutting down MCP clients...');
      for (const session of notificationSessions.values()) {
        if (session.timer) {
          clearInterval(session.timer);
        }
      }
      notificationSessions.clear();
      await graph.close();
      await closeMCPClients();
    });
  }
}
</file>

</files>
