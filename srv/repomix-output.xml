This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
lib/mcp-client.js
m365-mcp/graph-client.js
m365-mcp/helpers/logging.js
m365-mcp/index.js
m365-mcp/mcp-jsonschema.js
m365-mcp/mcp-tool-manifest.js
m365-mcp/tools/calendar.js
m365-mcp/tools/index.js
m365-mcp/tools/mail.js
service.cds
service.js
utils/markdown-converter.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="lib/mcp-client.js">
// srv/lib/mcp-client.js

import cds from '@sap/cds';
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import { initM365InProcessClient as createInProcessM365Client } from '../m365-mcp/index.js';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const dbConfig = cds.env.requires.db;
let postgresClient = null;
let braveSearchClient = null;
let playwrightClient = null;
let filesystemClient = null;
let excelClient = null; // +++ NEU: Excel Client Variable
let m365Client = null;

function getPostgresUri() {
  const creds = dbConfig.credentials;
  return `postgresql://${creds.user}:${creds.password}@${creds.host}:${creds.port}/${creds.database}`;
}

export async function initPostgresMCPClient() {
  if (postgresClient) return postgresClient;
  console.log(`Initializing PostgreSQL MCP client...`);
  const postgresUri = getPostgresUri();
  const transport = new StdioClientTransport({
    command: "npx",
    args: ["-y", "mcp-postgres-full-access", postgresUri],
  });
  postgresClient = new Client({ name: "postgres-client", version: "1.0.0" }, {});
  await postgresClient.connect(transport);
  console.log("✅ PostgreSQL MCP Client initialized successfully.");
  return postgresClient;
}

export async function initBraveSearchMCPClient() {
  if (braveSearchClient) return braveSearchClient;
  const braveApiKey = process.env.BRAVE_API_KEY || cds.env.BRAVE_API_KEY;
  if (!braveApiKey) throw new Error("BRAVE_API_KEY is required but not provided");
  console.log(`Initializing Brave Search MCP client...`);
  const transport = new StdioClientTransport({
    command: "npx",
    args: ["-y", "@modelcontextprotocol/server-brave-search"],
    env: { ...process.env, BRAVE_API_KEY: braveApiKey }
  });
  braveSearchClient = new Client({ name: "brave-search-client", version: "1.0.0" }, {});
  await braveSearchClient.connect(transport);
  console.log("✅ Brave Search MCP Client initialized successfully.");
  return braveSearchClient;
}

export async function initPlaywrightMCPClient() {
  if (playwrightClient) return playwrightClient;
  console.log(`Initializing Playwright MCP client...`);
  const transport = new StdioClientTransport({
    command: "npx",
    args: ["-y", "@executeautomation/playwright-mcp-server"],
    env: {
      ...process.env,
      PLAYWRIGHT_BROWSER: process.env.PLAYWRIGHT_BROWSER || "chromium",
      PLAYWRIGHT_HEADLESS: process.env.PLAYWRIGHT_HEADLESS || "true"
    }
  });
  playwrightClient = new Client({ name: "playwright-client", version: "1.0.0" }, {});
  await playwrightClient.connect(transport);
  console.log("✅ Playwright MCP Client initialized successfully.");
  return playwrightClient;
}

export async function initFilesystemMCPClient() {
  if (filesystemClient) return filesystemClient;
  console.log(`Initializing Filesystem MCP client...`);
  const allowedDirectory = process.cwd();
  console.log(`Filesystem access is sandboxed to: ${allowedDirectory}`);
  const transport = new StdioClientTransport({
    command: "npx",
    args: ["-y", "@modelcontextprotocol/server-filesystem", allowedDirectory, "C:/Users/HoangDuong/Desktop/StammtischAI"]
  });
  filesystemClient = new Client({ name: "filesystem-client", version: "1.0.0" }, {});
  await filesystemClient.connect(transport);
  console.log("✅ Filesystem MCP Client initialized successfully.");
  return filesystemClient;
}

// +++ NEUE FUNKTION: Excel MCP Client initialisieren +++
export async function initExcelMCPClient() {
  if (excelClient) return excelClient;

  console.log(`Initializing Excel MCP client...`);

  // Konfiguration basierend auf der README des Excel MCP Servers.
  // Diese Konfiguration ist für Windows. Für andere Plattformen (macOS/Linux)
  // wäre der Befehl: { command: "npx", args: ["--yes", "@negokaz/excel-mcp-server"] }
  const transport = new StdioClientTransport({
    command: "cmd",
    args: ["/c", "npx", "--yes", "@negokaz/excel-mcp-server"],
    env: {
      ...process.env,
      EXCEL_MCP_PAGING_CELLS_LIMIT: "4000" // Wie im Beispiel der README
    }
  });

  excelClient = new Client({ name: "excel-client", version: "1.0.0" }, {});
  await excelClient.connect(transport);
  console.log("✅ Excel MCP Client initialized successfully.");
  return excelClient;
}


export async function initM365Client() {
  if (m365Client) return m365Client;

  m365Client = await createInProcessM365Client({ logger: console });
  return m365Client;
}


export async function initAllMCPClients() {
  console.log("Initializing all MCP clients...");
  
  // +++ ERWEITERT: Excel Client wird mit initialisiert +++
  const [pgClient, braveClient, playwrightClient, fsClient, xlsxClient, microsoft365Client] = await Promise.all([
    initPostgresMCPClient(),
    initBraveSearchMCPClient(),
    initPlaywrightMCPClient(),
    initFilesystemMCPClient(),
    initExcelMCPClient(), // Neuer Client
    initM365Client()
  ]);

  return {
    postgres: pgClient,
    braveSearch: braveClient,
    playwright: playwrightClient,
    filesystem: fsClient,
    excel: xlsxClient, // Neuer Client im Rückgabeobjekt
    m365: microsoft365Client
  };
}

export async function closeMCPClients() {
  const closePromises = [];
  
  if (postgresClient) {
    console.log("Closing PostgreSQL MCP client connection");
    closePromises.push(postgresClient.close());
    postgresClient = null;
  }
  if (braveSearchClient) {
    console.log("Closing Brave Search MCP client connection");
    closePromises.push(braveSearchClient.close());
    braveSearchClient = null;
  }
  if (playwrightClient) {
    console.log("Closing Playwright MCP client connection");
    closePromises.push(playwrightClient.close());
    playwrightClient = null;
  }
  if (filesystemClient) {
    console.log("Closing Filesystem MCP client connection");
    closePromises.push(filesystemClient.close());
    filesystemClient = null;
  }
  // +++ ERWEITERT: Excel Client wird geschlossen +++
  if (excelClient) {
    console.log("Closing Excel MCP client connection");
    closePromises.push(excelClient.close());
    excelClient = null;
  }
  if (m365Client) {
    console.log("Closing Microsoft 365 MCP client connection");
    closePromises.push(m365Client.close());
    m365Client = null;
  }

  await Promise.all(closePromises);
  console.log("✅ All MCP clients closed");
}

// Backward compatibility
export const initMCPClient = initPostgresMCPClient;
export const closeMCPClient = closeMCPClients;
</file>

<file path="m365-mcp/graph-client.js">
// srv/m365-mcp/graph-client.js
// Thin wrapper around the Microsoft Graph API using the m365 CLI for authentication.

import { execFile } from 'node:child_process';
import { promisify } from 'node:util';
import { setTimeout as delay } from 'node:timers/promises';
import { existsSync } from 'node:fs';
import { mkdir, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { safeJson } from './helpers/logging.js';

const execFileAsync = promisify(execFile);
const GRAPH_RESOURCE = 'https://graph.microsoft.com';
const GRAPH_BASE_URL = `${GRAPH_RESOURCE}/v1.0`;
const DEFAULT_TOKEN_TTL_MS = 5 * 60 * 1000;

export class GraphClient {
  constructor(options = {}) {
    const {
      authMethod = process.env.M365_AUTH_METHOD || 'cli',
      cliCommand = process.env.M365_CLI_COMMAND || 'm365',
      logger = console,
      tokenTtlMs = DEFAULT_TOKEN_TTL_MS
    } = options;

    this.authMethod = authMethod;
    this.cliCommand = cliCommand;
    this.logger = logger;
    this.tokenTtlMs = tokenTtlMs;
    this.tokenCache = new Map();
    this.closed = false;
  }

  async bootstrap(scopes = ['Mail.Read']) {
    this.logger.log('Initializing Microsoft 365 in-process MCP client...');
    try {
      await this.getAccessToken(scopes);
      this.logger.log('✅ Microsoft 365 MCP client initialized successfully.');
    } catch (error) {
      this.logger.error('❌ Failed to initialize Microsoft 365 MCP client:', error.message);
      throw error;
    }
  }

  async getAccessToken(scopes = []) {
    if (this.closed) {
      throw new Error('GraphClient is closed');
    }
    if (this.authMethod !== 'cli') {
      throw new Error(`Unsupported M365 auth method: ${this.authMethod}`);
    }

    const normalizedScopes = Array.isArray(scopes) ? [...scopes].sort() : [];
    const cacheKey = normalizedScopes.join(' ');
    const cached = this.tokenCache.get(cacheKey);
    if (cached && cached.expiresAt > Date.now()) {
      return cached.token;
    }

    const cliArgs = ['util', 'accesstoken', 'get', '--resource', GRAPH_RESOURCE];
    if (normalizedScopes.length) {
      cliArgs.push('--scopes', normalizedScopes.join(','));
    }

    try {
      const { stdout } = await execFileAsync(this.cliCommand, cliArgs, {
        env: process.env,
        maxBuffer: 1024 * 1024
      });
      const token = stdout.trim();
      if (!token) {
        throw new Error('m365 CLI returned an empty access token. Ensure you are logged in with "m365 login".');
      }
      this.tokenCache.set(cacheKey, {
        token,
        expiresAt: Date.now() + this.tokenTtlMs
      });
      return token;
    } catch (error) {
      if (error.code === 'ENOENT') {
        throw new Error(`Could not find the m365 CLI (${this.cliCommand}). Install it via "npm i -g @pnp/cli-microsoft365".`);
      }
      throw new Error(`Failed to acquire Microsoft Graph token via m365 CLI: ${error.message}`);
    }
  }

  async request(method, relativePath, { query = {}, headers = {}, body, scopes = [] } = {}) {
    if (this.closed) {
      throw new Error('GraphClient is closed');
    }

    const url = new URL(relativePath.replace(/^\//, ''), `${GRAPH_BASE_URL}/`);
    Object.entries(query)
      .filter(([, value]) => value !== undefined && value !== null && value !== '')
      .forEach(([key, value]) => {
        url.searchParams.append(key, value);
      });

    const accessToken = await this.getAccessToken(scopes);
    const baseHeaders = {
      Authorization: `Bearer ${accessToken}`,
      Accept: 'application/json'
    };

    const options = {
      method,
      headers: { ...baseHeaders, ...headers }
    };

    if (body !== undefined) {
      options.body = typeof body === 'string' ? body : JSON.stringify(body);
      options.headers['Content-Type'] = 'application/json';
    }

    this.logger.debug?.(`Graph request ${method} ${url} with body ${safeJson(body)}`);

    const response = await fetch(url, options);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`Graph request failed (${response.status} ${response.statusText}): ${errorBody}`);
    }
    const contentType = response.headers.get('content-type') || '';
    if (contentType.includes('application/json')) {
      return await response.json();
    }
    return Buffer.from(await response.arrayBuffer());
  }

  async getLatestMessage({ folderId = 'inbox' } = {}) {
    const data = await this.request(
      'GET',
      `/me/mailFolders/${encodeURIComponent(folderId)}/messages`,
      {
        query: {
          '$top': '1',
          '$orderby': 'receivedDateTime desc'
        },
        scopes: ['Mail.Read']
      }
    );
    const message = Array.isArray(data.value) && data.value.length ? data.value[0] : null;
    if (!message) {
      return null;
    }
    return {
      id: message.id,
      subject: message.subject,
      from: message.from?.emailAddress || null,
      toRecipients: (message.toRecipients || []).map((entry) => entry.emailAddress),
      receivedDateTime: message.receivedDateTime,
      hasAttachments: Boolean(message.hasAttachments)
    };
  }

  async downloadAttachment({ messageId, attachmentId, targetPath }) {
    if (!messageId || !attachmentId || !targetPath) {
      throw new Error('messageId, attachmentId and targetPath are required for attachment download.');
    }

    const attachmentBinary = await this.request(
      'GET',
      `/me/messages/${encodeURIComponent(messageId)}/attachments/${encodeURIComponent(attachmentId)}/$value`,
      {
        scopes: ['Mail.Read'],
        headers: {
          Accept: 'application/octet-stream'
        }
      }
    );

    const directory = path.dirname(targetPath);
    if (!existsSync(directory)) {
      await mkdir(directory, { recursive: true });
    }

    await writeFile(targetPath, attachmentBinary);

    const bytesWritten = typeof attachmentBinary.length === 'number'
      ? attachmentBinary.length
      : (attachmentBinary.byteLength || 0);

    return {
      messageId,
      attachmentId,
      targetPath,
      bytesWritten
    };
  }

  async listCalendarEvents({ startDateTime, endDateTime }) {
    if (!startDateTime || !endDateTime) {
      throw new Error('startDateTime and endDateTime are required to list events.');
    }

    const data = await this.request(
      'GET',
      '/me/calendarView',
      {
        query: {
          startDateTime,
          endDateTime,
          '$orderby': 'start/dateTime asc'
        },
        scopes: ['Calendars.Read']
      }
    );

    return (data.value || []).map((event) => ({
      id: event.id,
      subject: event.subject,
      start: event.start,
      end: event.end,
      location: event.location,
      organizer: event.organizer
    }));
  }

  async close() {
    this.closed = true;
    this.tokenCache.clear();
    // Give pending CLI processes a moment to settle; mainly relevant for unit tests.
    await delay(10);
  }
}
</file>

<file path="m365-mcp/helpers/logging.js">
// srv/m365-mcp/helpers/logging.js
// Provides defensive JSON serialization for logging without crashing on circular structures.

export function safeJson(value, max = 4000) {
  try {
    const serialized = typeof value === 'string' ? value : JSON.stringify(value);
    const output = typeof serialized === 'string' ? serialized : String(serialized);
    return output.length > max ? `${output.slice(0, max)} ...[truncated]` : output;
  } catch (error) {
    try {
      return String(value);
    } catch {
      return '[unprintable]';
    }
  }
}
</file>

<file path="m365-mcp/index.js">
// srv/m365-mcp/index.js
// Entry point for the Microsoft 365 in-process MCP client.

import { createM365ToolManifest, toolDefinitions } from './mcp-tool-manifest.js';
import { GraphClient } from './graph-client.js';
import { getToolHandler, listSupportedTools } from './tools/index.js';
import { safeJson } from './helpers/logging.js';

export async function initM365InProcessClient(options = {}) {
  const {
    logger = console,
    bootstrapScopes = ['Mail.Read']
  } = options;

  const graphClient = new GraphClient({ ...options, logger });
  await graphClient.bootstrap(bootstrapScopes);

  async function listTools() {
    return createM365ToolManifest();
  }

  async function callTool({ name, arguments: args = {} }) {
    if (!name) {
      throw new Error('Tool name is required');
    }
    const handler = getToolHandler(name);
    if (!handler) {
      throw new Error(`Unknown Microsoft 365 tool: ${name}. Supported tools: ${listSupportedTools().join(', ')}`);
    }
    const input = args && typeof args === 'object' ? args : {};
    try {
      const result = await handler({ input, graphClient, logger });
      return result;
    } catch (error) {
      logger.error?.(`Error while executing Microsoft 365 tool ${name}:`, safeJson(error.message || error));
      throw error;
    }
  }

  async function close() {
    await graphClient.close();
  }

  return {
    listTools,
    callTool,
    close,
    toolDefinitions
  };
}
</file>

<file path="m365-mcp/mcp-jsonschema.js">
// srv/m365-mcp/mcp-jsonschema.js
// Minimal JSON Schema to Zod converter tailored to the MCP tool definitions.

function applyCommonMetadata(zodSchema, schema) {
  let result = zodSchema;
  if (schema && typeof schema.description === 'string') {
    result = result.describe(schema.description);
  }
  if (schema && Object.prototype.hasOwnProperty.call(schema, 'default')) {
    result = result.default(schema.default);
  }
  return result;
}

function convertEnum(schema, z) {
  if (!Array.isArray(schema.enum) || schema.enum.length === 0) {
    return null;
  }
  if (schema.enum.every((value) => typeof value === 'string')) {
    return applyCommonMetadata(z.enum([...schema.enum]), schema);
  }
  return applyCommonMetadata(z.union(schema.enum.map((value) => z.literal(value))), schema);
}

function convertArray(schema, z) {
  const itemSchema = schema.items ? jsonSchemaToZod(schema.items, z) : z.any();
  let arraySchema = z.array(itemSchema);
  if (typeof schema.minItems === 'number') {
    arraySchema = arraySchema.min(schema.minItems);
  }
  if (typeof schema.maxItems === 'number') {
    arraySchema = arraySchema.max(schema.maxItems);
  }
  return applyCommonMetadata(arraySchema, schema);
}

function convertObject(schema, z) {
  const properties = schema.properties || {};
  const requiredProps = new Set(schema.required || []);
  const shape = {};

  for (const [key, propertySchema] of Object.entries(properties)) {
    let prop = jsonSchemaToZod(propertySchema, z);
    if (!requiredProps.has(key)) {
      prop = prop.optional();
    }
    shape[key] = prop;
  }

  let objectSchema = z.object(shape);
  if (schema.additionalProperties) {
    const additional = jsonSchemaToZod(schema.additionalProperties, z);
    objectSchema = objectSchema.catchall(additional);
  } else {
    objectSchema = objectSchema.strict();
  }

  if (schema.minProperties) {
    objectSchema = objectSchema.min(schema.minProperties);
  }
  if (schema.maxProperties) {
    objectSchema = objectSchema.max(schema.maxProperties);
  }

  return applyCommonMetadata(objectSchema, schema);
}

export function jsonSchemaToZod(schema, z) {
  if (!schema) {
    return z.any();
  }

  if (schema.enum) {
    const enumSchema = convertEnum(schema, z);
    if (enumSchema) {
      return enumSchema;
    }
  }

  switch (schema.type) {
    case 'string': {
      let stringSchema = z.string();
      if (schema.format === 'date-time') {
        stringSchema = stringSchema.regex(/^[^\s]+$/, 'Expected ISO-8601 datetime string');
      }
      if (schema.minLength) {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (schema.maxLength) {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      return applyCommonMetadata(stringSchema, schema);
    }
    case 'number':
    case 'integer': {
      let numberSchema = schema.type === 'integer' ? z.number().int() : z.number();
      if (typeof schema.minimum === 'number') {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === 'number') {
        numberSchema = numberSchema.max(schema.maximum);
      }
      return applyCommonMetadata(numberSchema, schema);
    }
    case 'boolean': {
      return applyCommonMetadata(z.boolean(), schema);
    }
    case 'array': {
      return convertArray(schema, z);
    }
    case 'object': {
      return convertObject(schema, z);
    }
    default:
      return applyCommonMetadata(z.any(), schema);
  }
}
</file>

<file path="m365-mcp/mcp-tool-manifest.js">
// srv/m365-mcp/mcp-tool-manifest.js
// Describes the tool surface exposed by the Microsoft 365 in-process MCP client.

const manifestVersion = '0.1.0';

function clone(value) {
  return JSON.parse(JSON.stringify(value));
}

export const toolDefinitions = [
  {
    name: 'mail.latestMessage.get',
    description: 'Liest deterministisch die neueste Nachricht aus einem Mailordner und liefert Metadaten.',
    inputSchema: {
      type: 'object',
      properties: {
        folderId: {
          type: 'string',
          description: 'ID oder bekannter Name des Zielordners, z. B. inbox.',
          default: 'inbox'
        }
      }
    },
    metadata: { scopes: ['Mail.Read'] }
  },
  {
    name: 'mail.attachment.download',
    description: 'Lädt einen bestimmten Anhang einer Nachricht und speichert ihn deterministisch im Zielpfad.',
    inputSchema: {
      type: 'object',
      required: ['messageId', 'attachmentId', 'targetPath'],
      properties: {
        messageId: { type: 'string', description: 'ID der Nachricht.' },
        attachmentId: { type: 'string', description: 'ID des Anhangs.' },
        targetPath: {
          type: 'string',
          description: 'Absoluter Ablageort für den heruntergeladenen Anhang.'
        }
      }
    },
    metadata: { scopes: ['Mail.Read'] }
  },
  {
    name: 'calendar.events.list',
    description: 'Listet Kalenderereignisse in einem Zeitraum mit deterministischer Filterung.',
    inputSchema: {
      type: 'object',
      required: ['startDateTime', 'endDateTime'],
      properties: {
        startDateTime: { type: 'string', description: 'ISO-8601 Startzeitpunkt.' },
        endDateTime: { type: 'string', description: 'ISO-8601 Endzeitpunkt.' }
      }
    },
    metadata: { scopes: ['Calendars.Read'] }
  }
  // Weitere Tools aus dem PoC können hier ergänzt werden.
];

export function createM365ToolManifest() {
  return {
    namespace: 'm365',
    version: manifestVersion,
    tools: toolDefinitions.map(clone)
  };
}
</file>

<file path="m365-mcp/tools/calendar.js">
// srv/m365-mcp/tools/calendar.js
// Tool handlers for Microsoft 365 calendar interactions.

import { safeJson } from '../helpers/logging.js';

function getInfoLogger(logger) {
  if (!logger) return () => {};
  if (typeof logger.info === 'function') return logger.info.bind(logger);
  if (typeof logger.log === 'function') return logger.log.bind(logger);
  return () => {};
}

export async function handleCalendarEventsList({ input, graphClient, logger }) {
  const info = getInfoLogger(logger);
  info('M365 calendar.events.list invoked with input:', safeJson(input));

  const events = await graphClient.listCalendarEvents({
    startDateTime: input.startDateTime,
    endDateTime: input.endDateTime
  });

  return {
    startDateTime: input.startDateTime,
    endDateTime: input.endDateTime,
    count: events.length,
    events
  };
}
</file>

<file path="m365-mcp/tools/index.js">
// srv/m365-mcp/tools/index.js
// Registry of tool handlers exposed by the Microsoft 365 MCP client.

import { handleMailLatestMessage, handleMailAttachmentDownload } from './mail.js';
import { handleCalendarEventsList } from './calendar.js';

const handlers = {
  'mail.latestMessage.get': handleMailLatestMessage,
  'mail.attachment.download': handleMailAttachmentDownload,
  'calendar.events.list': handleCalendarEventsList
};

export function getToolHandler(name) {
  return handlers[name] || null;
}

export function listSupportedTools() {
  return Object.keys(handlers);
}
</file>

<file path="m365-mcp/tools/mail.js">
// srv/m365-mcp/tools/mail.js
// Tool handlers for Microsoft 365 mail interactions.

import { safeJson } from '../helpers/logging.js';

function getInfoLogger(logger) {
  if (!logger) return () => {};
  if (typeof logger.info === 'function') return logger.info.bind(logger);
  if (typeof logger.log === 'function') return logger.log.bind(logger);
  return () => {};
}

export async function handleMailLatestMessage({ input, graphClient, logger }) {
  const info = getInfoLogger(logger);
  info('M365 mail.latestMessage.get invoked with input:', safeJson(input));
  const folderId = input.folderId || 'inbox';
  const message = await graphClient.getLatestMessage({ folderId });
  if (!message) {
    return {
      message: `No messages found in folder "${folderId}"`,
      folderId
    };
  }
  return {
    folderId,
    message
  };
}

export async function handleMailAttachmentDownload({ input, graphClient, logger }) {
  const info = getInfoLogger(logger);
  info('M365 mail.attachment.download invoked with input:', safeJson({
    ...input,
    targetPath: '[redacted]'
  }));

  const result = await graphClient.downloadAttachment({
    messageId: input.messageId,
    attachmentId: input.attachmentId,
    targetPath: input.targetPath
  });
  return {
    status: 'downloaded',
    details: result
  };
}
</file>

<file path="service.cds">
using { sap.stammtisch as StammtischModel } from '../db/schema';
using from '../app/annotations'; 

service StammtischService @(path: '/service/stammtisch') { 

    @odata.draft.enabled // Aktiviere Draft-Modus für diese Entität
    entity Stammtische as projection on StammtischModel.Stammtische {
        *,
        // Navigation Properties explizit exponieren
        praesentator : redirected to Praesentatoren,
        teilnehmer : redirected to Teilnehmer
    };

    entity Praesentatoren as projection on StammtischModel.Praesentatoren {
        *,
        stammtische : redirected to Stammtische
    };
    
    entity Teilnehmer as projection on StammtischModel.Teilnehmer {
        *,
        stammtisch : redirected to Stammtische
    };

    action callLLM (prompt: String) returns { response: String };

}
</file>

<file path="service.js">
// srv/StammtischService.js

import cds from '@sap/cds';
import { loadMcpTools } from '@langchain/mcp-adapters';
import { createReactAgent } from "@langchain/langgraph/prebuilt";
import { AzureOpenAiChatClient } from "@sap-ai-sdk/langchain";
import { MemorySaver } from "@langchain/langgraph-checkpoint";
import { DynamicStructuredTool } from "@langchain/core/tools";
import { z } from "zod";
import { initAllMCPClients, closeMCPClients } from './lib/mcp-client.js';
import { jsonSchemaToZod } from './m365-mcp/mcp-jsonschema.js';
import MarkdownConverter from './utils/markdown-converter.js';

export default class StammtischService extends cds.ApplicationService {
  async init() {
    await super.init();
    let agentExecutor = null;
    let mcpClients = null;

    const initializeAgent = async () => {
      if (agentExecutor) return agentExecutor;

      // +++ ERWEITERT: Log-Nachricht angepasst +++
      console.log("Initializing Agent with Database, Web Search, Browser, Filesystem, Excel, and Microsoft 365 capabilities...");

      try {
        mcpClients = await initAllMCPClients();

        // +++ ERWEITERT: Lade Tools vom neuen Excel Client +++
        const [postgresTools, braveSearchTools, playwrightTools, filesystemTools, excelTools] = await Promise.all([
          loadMcpTools("query", mcpClients.postgres),
          loadMcpTools("brave_web_search,brave_local_search", mcpClients.braveSearch),
          loadMcpTools("take_screenshot,goto_page,click_element,fill_input,execute_javascript,get_page_content,wait_for_element,generate_test_code", mcpClients.playwright),
          loadMcpTools("read_file,write_file,edit_file,create_directory,list_directory,move_file,search_files,get_file_info,list_allowed_directories", mcpClients.filesystem),
          // +++ NEU: Lade alle verfügbaren Excel-Tools +++
          loadMcpTools("excel_describe_sheets,excel_read_sheet,excel_screen_capture,excel_write_to_sheet,excel_create_table,excel_copy_sheet", mcpClients.excel)
        ]);

        // Kombiniere alle Tools
        const allTools = [...postgresTools, ...braveSearchTools, ...playwrightTools, ...filesystemTools, ...excelTools];

        // Lade Microsoft 365 Tools dynamisch aus dem Manifest
        if (mcpClients.m365) {
          console.log("Loading Microsoft 365 tools...");
          const manifest = await mcpClients.m365.listTools();
          const m365Tools = manifest.tools.map((toolDef) => {
            const schema = jsonSchemaToZod(toolDef.inputSchema, z);
            return new DynamicStructuredTool({
              name: toolDef.name,
              description: toolDef.description,
              schema,
              func: async (input) => {
                const result = await mcpClients.m365.callTool({ name: toolDef.name, arguments: input });
                return typeof result === 'string' ? result : JSON.stringify(result);
              }
            });
          });
          allTools.push(...m365Tools);
          console.log(`✅ Loaded ${m365Tools.length} Microsoft 365 tools`);
        }

        console.log(`✅ Loaded ${postgresTools.length} PostgreSQL, ${braveSearchTools.length} Brave Search, ${playwrightTools.length} Playwright, ${filesystemTools.length} Filesystem, and ${excelTools.length} Excel tools`);
        console.log("Available tools:", allTools.map(tool => tool.name));

        const llm = new AzureOpenAiChatClient({ modelName: 'gpt-4.1' });
        const checkpointer = new MemorySaver();

        agentExecutor = createReactAgent({
          llm,
          tools: allTools,
          checkpointSaver: checkpointer
        });
        
        // +++ ERWEITERT: Log-Nachricht angepasst +++
        console.log("✅ Multi-Modal Agent is ready (Database + Web Search + Browser + Filesystem + Excel).");
        return agentExecutor;

      } catch (error) {
        console.error("❌ Failed to initialize agent:", error);
        throw error;
      }
    };

    await initializeAgent();

    this.on('callLLM', async (req) => {
      const { prompt: userPrompt } = req.data;
      if (!userPrompt) {
        req.error(400, 'Prompt is required');
        return;
      }

      console.log('🚀 Received prompt for Multi-Modal Agent:', userPrompt);
      const executor = await initializeAgent();

      try {
        const systemMessage = {
          role: "system",
          content: `You are a helpful assistant with access to database queries, web search, browser automation, local filesystem, and MS Excel capabilities.

                  DATABASE ACCESS:
                  - You can query a PostgreSQL database using the 'query' tool.
                  - IMPORTANT: Use PostgreSQL syntax.

                  WEB SEARCH ACCESS:
                  - You can search the web using 'brave_web_search'. 

                  BROWSER AUTOMATION ACCESS (Playwright):
                  - You can control a web browser to perform tasks like testing web applications.

                  FILESYSTEM ACCESS:
                  - You can read, write, and manage files and directories in the project.
                  - SECURITY: You can ONLY operate within the allowed project directory.
                  - Use 'list_directory' with '.' or a subdirectory to see available files first.
                  - For 'edit_file', ALWAYS use 'dryRun: true' first to preview changes.

                  EXCEL ACCESS:
                  - You can read from and write to MS Excel files (.xlsx, .xlsm, etc.).
                  - Available tools: excel_describe_sheets, excel_read_sheet, excel_write_to_sheet, excel_create_table, excel_copy_sheet, excel_screen_capture (Windows only).
                  - ALWAYS start by using 'excel_describe_sheets' to understand the file's structure (sheet names).
                  - For all Excel tools, you MUST provide the 'fileAbsolutePath' to the target Excel file.
                  - When reading large sheets, the tool uses pagination. Pay attention to the 'knownPagingRanges' argument to read subsequent parts.
                  - When writing with 'excel_write_to_sheet', you can create a new sheet by setting 'newSheet: true'. Be careful as writing can modify files permanently.

                  ANALYSIS & VISUALIZATION WORKFLOW:
                  - If the user asks for an "analysis", "report", or "visualization" of data, you MUST follow this specific workflow:
                  1.  **Query Data:** First, use the 'query' tool to retrieve the necessary data from the PostgreSQL database. If the user's request is ambiguous (e.g., "analyze the data"), ask clarifying questions to determine which tables and columns are relevant for the analysis.
                  2.  **Generate HTML File:** After successfully retrieving the data, you will generate a single, self-contained HTML file to present the analysis and visualization.
                      -   **Structure:** Create a well-structured HTML5 document.
                      -   **Styling:** Include some basic CSS in a <style> tag in the <head> for a clean and professional look (e.g., set a modern font, center content, add padding).
                      -   **Visualization Library:** You MUST use a JavaScript charting library like **Chart.js** to create professional-looking charts (e.g., bar charts, line charts, pie charts). Include the library via its CDN link in a <script> tag in the <head>. Example: <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
                      -   **Content:** The HTML body should contain:
                          -   A clear headline (<h1>) describing the analysis (e.g., "Analyse der monatlichen Umsätze").
                          -   A <canvas> element where the chart will be rendered.
                          -   A <script> block at the end of the body. Inside this script, you will:
                              a) Store the data retrieved from the database in a JavaScript variable.
                              b) Write the JavaScript code to initialize Chart.js and render the chart on the canvas, using the data.
                  3.  **Save the File:** Use the 'edit_file' tool to write the complete HTML code into a new file.
                  4.  **Report Back:** Finally, after the file has been successfully created, inform the user that the analysis is complete and provide the full, correct path to the generated HTML file so they can open it.

                  RESPONSE GUIDELINES:
                   - First, determine which tool or combination of tools is best for the user's request.
              - Clearly explain your plan before executing it.
              - Combine information from different sources clearly, distinguishing between database results, web content, file content, and Excel data.
              - Always provide context about where information is coming from.
                    `
                      };

        const userMessage = {
          role: "user",
          content: userPrompt
        };
        
        const stream = await executor.stream(
          {
            messages: [systemMessage, userMessage]
          },
          {
            configurable: { thread_id: `session_test}` }
          }
        );

        const finalResponseParts = [];
        console.log("\n\n---- AGENT STREAM START ----\n");

        for await (const chunk of stream) {
          if (chunk.agent?.messages) {
            const message = chunk.agent.messages[chunk.agent.messages.length - 1];
            if (message && message.content) {
              process.stdout.write(message.content);
              finalResponseParts.push(message.content);
            }
            if (message.tool_calls && message.tool_calls.length > 0) {
              const toolCall = message.tool_calls[0];
              const toolCallStr = `\n\n<TOOL_CALL>\n  Tool: ${toolCall.name}\n  Args: ${JSON.stringify(toolCall.args)}\n</TOOL_CALL>\n\n`;
              process.stdout.write(toolCallStr);
            }
          }

          if (chunk.tools?.messages) {
             const toolMessage = chunk.tools.messages[0];
             const toolOutputStr = `<TOOL_OUTPUT>\n  ${toolMessage.content}\n</TOOL_OUTPUT>\n\n`;
             process.stdout.write(toolOutputStr);
          }
        }
        console.log("\n---- AGENT STREAM END ----\n");

        const rawResponse = finalResponseParts.join("");
        const htmlResponse = MarkdownConverter.convertForStammtischAI(rawResponse);

        return { response: htmlResponse };

      } catch (error) {
        console.error('💥 Error during agent execution:', error);
        req.error(500, `Failed to process query: ${error.message}`);
      }
    });

    this.on('EXIT', async () => {
      console.log('Shutting down MCP clients...');
      await closeMCPClients();
    });
  }
}
</file>

<file path="utils/markdown-converter.js">
// srv/utils/markdown-converter.js
/**
 * Einfacher Markdown-zu-HTML Konverter für AI-Antworten
 * Speziell optimiert für SAP UI5 FormattedText Component
 */

class MarkdownConverter {
  
  /**
   * Konvertiert Markdown zu HTML für SAP UI5 FormattedText
   * @param {string} markdown - Markdown Text
   * @returns {string} HTML String
   */
  static convertToHTML(markdown) {
    if (!markdown || typeof markdown !== 'string') {
      return '';
    }

    let html = markdown;

    // 1. Code-Blöcke (müssen zuerst verarbeitet werden)
    html = this.convertCodeBlocks(html);

    // 2. Inline Code
    html = this.convertInlineCode(html);

    // 3. Headers (H1-H4)
    html = this.convertHeaders(html);

    // 4. Bold und Italic
    html = this.convertTextFormatting(html);

    // 5. Listen
    html = this.convertLists(html);

    // 6. Links (falls vorhanden)
    html = this.convertLinks(html);

    // 7. Emojis und Sonderzeichen beibehalten
    html = this.preserveEmojis(html);

    // 8. Zeilenumbrüche
    html = this.convertLineBreaks(html);

    // 9. SAP UI5 spezifische Optimierungen
    html = this.optimizeForSAPUI5(html);

    return html.trim();
  }

  /**
   * Konvertiert Code-Blöcke
   */
  static convertCodeBlocks(text) {
    // ```language \n code \n ```
    return text.replace(/```(\w*)\n([\s\S]*?)\n```/g, (match, language, code) => {
      const cleanCode = this.escapeHTML(code.trim());
      return `<div class="ai-code-block">
        <div class="ai-code-header">${language || 'Code'}</div>
        <pre class="ai-code-content"><code>${cleanCode}</code></pre>
      </div>`;
    });
  }

  /**
   * Konvertiert Inline-Code
   */
  static convertInlineCode(text) {
    return text.replace(/`([^`]+)`/g, '<code class="ai-inline-code">$1</code>');
  }

  /**
   * Konvertiert Headers
   */
  static convertHeaders(text) {
    // ### Header 3
    text = text.replace(/^### (.+)$/gm, '<h3 class="ai-header-3">$1</h3>');
    // ## Header 2  
    text = text.replace(/^## (.+)$/gm, '<h2 class="ai-header-2">$1</h2>');
    // # Header 1
    text = text.replace(/^# (.+)$/gm, '<h1 class="ai-header-1">$1</h1>');
    
    return text;
  }

  /**
   * Konvertiert Bold und Italic
   */
  static convertTextFormatting(text) {
    // **Bold**
    text = text.replace(/\*\*([^*]+)\*\*/g, '<strong class="ai-bold">$1</strong>');
    // *Italic*
    text = text.replace(/\*([^*]+)\*/g, '<em class="ai-italic">$1</em>');
    
    return text;
  }

  /**
   * Konvertiert Listen
   */
  static convertLists(text) {
    // Unordered Lists
    text = text.replace(/^- (.+)$/gm, '<li class="ai-list-item">$1</li>');
    
    // Wrap consecutive list items in <ul>
    text = text.replace(/(<li class="ai-list-item">.*<\/li>\s*)+/gs, (match) => {
      return `<ul class="ai-unordered-list">${match}</ul>`;
    });

    // Numbered Lists (vereinfacht)
    text = text.replace(/^\d+\. (.+)$/gm, '<li class="ai-numbered-item">$1</li>');
    
    // Wrap consecutive numbered items in <ol>
    text = text.replace(/(<li class="ai-numbered-item">.*<\/li>\s*)+/gs, (match) => {
      return `<ol class="ai-ordered-list">${match}</ol>`;
    });

    return text;
  }

  /**
   * Konvertiert Links
   */
  static convertLinks(text) {
    // [Text](URL)
    return text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="#" class="ai-link" data-url="$2" title="$2">$1</a>');
  }

  /**
   * Behält Emojis bei
   */
  static preserveEmojis(text) {
    // Emojis sind bereits Unicode, keine Konvertierung nötig
    return text;
  }

  /**
   * Konvertiert Zeilenumbrüche
   */
  static convertLineBreaks(text) {
    // Doppelte Zeilenumbrüche zu Paragraphen
    text = text.replace(/\n\n+/g, '</p><p class="ai-paragraph">');
    
    // Einzelne Zeilenumbrüche zu <br>
    text = text.replace(/\n/g, '<br/>');
    
    // Wrap in paragraph wenn nicht schon in anderen Tags
    if (!text.startsWith('<') && text.length > 0) {
      text = `<p class="ai-paragraph">${text}</p>`;
    }

    return text;
  }

  /**
   * SAP UI5 spezifische Optimierungen
   */
  static optimizeForSAPUI5(text) {
    // Bereinige leere Paragraphen
    text = text.replace(/<p class="ai-paragraph"><\/p>/g, '');
    
    // Stelle sicher, dass alle Tags geschlossen sind
    text = this.closeOpenTags(text);
    
    return text;
  }

  /**
   * HTML Escaping für Sicherheit
   */
  static escapeHTML(text) {
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    return text.replace(/[&<>"']/g, (m) => map[m]);
  }

  /**
   * Schließt offene Tags (vereinfacht)
   */
  static closeOpenTags(html) {
    // Einfache Implementation - für Produktionsumgebung sollte ein richtiger HTML-Parser verwendet werden
    const openTags = [];
    const tagRegex = /<\/?([a-zA-Z][a-zA-Z0-9]*)[^>]*>/g;
    
    let match;
    while ((match = tagRegex.exec(html)) !== null) {
      if (match[0].startsWith('</')) {
        // Closing tag
        const tag = match[1].toLowerCase();
        const index = openTags.lastIndexOf(tag);
        if (index !== -1) {
          openTags.splice(index, 1);
        }
      } else if (!match[0].endsWith('/>')) {
        // Opening tag (not self-closing)
        openTags.push(match[1].toLowerCase());
      }
    }

    // Schließe offene Tags
    for (let i = openTags.length - 1; i >= 0; i--) {
      html += `</${openTags[i]}>`;
    }

    return html;
  }

  /**
   * Spezielle Konvertierung für SAP-spezifische Inhalte
   */
  static convertSAPContent(text) {
    // SAP UI5 Komponenten-Namen hervorheben
    text = text.replace(/\b(List Report|Object Page|Draft|Value Help|Smart Filter Bar)\b/g, 
      '<span class="ai-sap-term">$1</span>');
    
    // Schritt-für-Schritt Anleitungen
    text = text.replace(/^\*\*Schritt (\d+)\*\*:?/gm, 
      '<div class="ai-step-header">📋 <strong>Schritt $1</strong></div>');
    
    return text;
  }

  /**
   * Hauptmethode für die Konvertierung mit SAP-spezifischen Verbesserungen
   */
  static convertForStammtischAI(markdown) {
    let html = this.convertToHTML(markdown);
    html = this.convertSAPContent(html);
    return html;
  }
}

export default MarkdownConverter;
</file>

</files>
