This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
lib/claude-agent.ts
lib/mcp-client.ts
m365-mcp/graph-client.ts
m365-mcp/helpers/logging.ts
m365-mcp/index.ts
m365-mcp/mcp-jsonschema.ts
m365-mcp/mcp-tool-manifest.ts
m365-mcp/tools/calendar.ts
m365-mcp/tools/index.ts
m365-mcp/tools/mail.ts
mcp-cap/index.ts
service.cds
service.ts
types/cds-augmentations.d.ts
utils/markdown-converter.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="lib/claude-agent.ts">
import { query } from '@anthropic-ai/claude-agent-sdk';
import type {
  HookCallbackMatcher,
  HookEvent,
  Options,
  PostToolUseHookInput,
  PreToolUseHookInput,
  SDKAssistantMessage,
  SDKMessage,
  SDKResultMessage,
  SDKSystemMessage
} from '@anthropic-ai/claude-agent-sdk';

type ConsoleLike = Pick<Console, 'debug' | 'info' | 'warn' | 'error' | 'log'>;

const DEFAULT_MODEL = process.env.CLAUDE_AGENT_MODEL
  || process.env.CLAUDE_MODEL
  || 'claude-3.5-sonnet';

interface RunClaudeAgentParams {
  prompt: string;
  systemPrompt: string;
  options?: Partial<Options>;
  logger?: ConsoleLike;
  resumeSessionId?: string;
}

interface ClaudeAgentResult {
  result: string;
  sessionId?: string;
}

const isAssistantMessage = (message: SDKMessage): message is SDKAssistantMessage =>
  message.type === 'assistant';

const isResultMessage = (message: SDKMessage): message is SDKResultMessage =>
  message.type === 'result';

const getResultString = (message: SDKResultMessage): string | undefined => {
  return typeof (message as { result?: unknown }).result === 'string'
    ? (message as { result: string }).result
    : undefined;
};

const summarizeResultError = (message: SDKResultMessage): string => {
  const base = getResultString(message)?.trim();
  if (base) return base;
  if (message.subtype !== 'success') return message.subtype;
  if (message.permission_denials?.length) {
    const denied = message.permission_denials
      .map((denial) => denial.tool_name)
      .join(', ');
    return `permission denied for tools: ${denied}`;
  }
  return message.is_error ? 'unknown error' : 'no content returned';
};

const extractTextBlocks = (assistantMessage: SDKAssistantMessage): string => {
  const blocks = assistantMessage.message?.content;
  if (!Array.isArray(blocks)) return '';

  return blocks
    .map((block) => {
      if (block && typeof block === 'object' && 'type' in block) {
        if (block.type === 'text' && typeof (block as { text?: unknown }).text === 'string') {
          return (block as { text: string }).text;
        }
        if (block.type === 'tool_result' && typeof (block as { content?: unknown }).content === 'string') {
          return (block as { content: string }).content;
        }
      }
      return '';
    })
    .filter(Boolean)
    .join('')
    .trim();
};

const truncateForLog = (value: unknown, maxLength = 500): string => {
  let str = '';
  if (typeof value === 'string') {
    str = value;
  } else if (value !== undefined) {
    try {
      str = JSON.stringify(value, null, 2) || '';
    } catch {
      str = String(value);
    }
  }
  if (!str) return '';
  if (str.length <= maxLength) return str;
  return `${str.slice(0, maxLength)}…`;
};

const createLoggingHooks = (
  logger: ConsoleLike | undefined,
  toolTimers: Map<string, { tool: string; startedAt: number }>
): Options['hooks'] | undefined => {
  if (!logger) return undefined;

  const pre: HookCallbackMatcher = {
    hooks: [
      async (input, toolUseId) => {
        try {
          const preInput = input as PreToolUseHookInput;
          const toolName = preInput.tool_name;
          const toolInput = preInput.tool_input;
          if (toolUseId) {
            toolTimers.set(toolUseId, { tool: toolName, startedAt: Date.now() });
          }
          logger.debug?.('[ClaudeAgent] Tool invocation requested', {
            tool: toolName,
            toolUseId,
            input: truncateForLog(toolInput)
          });
        } catch (error) {
          logger.warn?.('[ClaudeAgent] Failed to log PreToolUse hook', { error });
        }
        return { continue: true };
      }
    ]
  };

  const post: HookCallbackMatcher = {
    hooks: [
      async (input, toolUseId) => {
        try {
          const postInput = input as PostToolUseHookInput;
          const toolName = postInput.tool_name;
          const toolInput = postInput.tool_input;
          const toolResponse = postInput.tool_response;
          const timing = toolUseId ? toolTimers.get(toolUseId) : undefined;
          const durationMs = timing ? Date.now() - timing.startedAt : undefined;
          if (toolUseId && timing) {
            toolTimers.delete(toolUseId);
          }
          logger.debug?.('[ClaudeAgent] Tool invocation completed', {
            tool: toolName,
            toolUseId,
            durationMs,
            input: truncateForLog(toolInput),
            output: truncateForLog(toolResponse)
          });
        } catch (error) {
          logger.warn?.('[ClaudeAgent] Failed to log PostToolUse hook', { error });
        }
        return { continue: true };
      }
    ]
  };

  return {
    PreToolUse: [pre],
    PostToolUse: [post]
  };
};

const mergeHooks = (
  base: Options['hooks'] | undefined,
  extra: Options['hooks'] | undefined
): Options['hooks'] | undefined => {
  if (!base) return extra;
  if (!extra) return base;

  const merged: Partial<Record<HookEvent, HookCallbackMatcher[]>> = {};
  const assign = (source: Options['hooks'] | undefined) => {
    if (!source) return;
    for (const [event, matchers] of Object.entries(source)) {
      if (!matchers?.length) continue;
      const hookEvent = event as HookEvent;
      const list = merged[hookEvent] ?? [];
      list.push(...matchers);
      merged[hookEvent] = list;
    }
  };

  assign(base);
  assign(extra);
  return merged;
};

const logSdkMessage = (message: SDKMessage, logger?: ConsoleLike): void => {
  if (!logger) return;

  const basePayload: Record<string, unknown> = {
    type: message.type,
    sessionId: (message as { session_id?: string }).session_id,
    uuid: (message as { uuid?: string }).uuid
  };

  if (message.type === 'assistant') {
    const assistantMessage = message as SDKAssistantMessage;
    const preview = extractTextBlocks(assistantMessage);
    logger.debug?.('[ClaudeAgent] Assistant message', {
      ...basePayload,
      parentToolUseId: assistantMessage.parent_tool_use_id,
      preview: preview ? truncateForLog(preview, 300) : undefined,
      usage: assistantMessage.message?.usage
    });
    return;
  }

  if (message.type === 'user') {
    logger.debug?.('[ClaudeAgent] User message received', basePayload);
    return;
  }

  if (message.type === 'result') {
    const resultMessage = message as SDKResultMessage;
    logger.debug?.('[ClaudeAgent] Result message', {
      ...basePayload,
      subtype: resultMessage.subtype,
      isError: resultMessage.is_error,
      durationMs: resultMessage.duration_ms,
      apiDurationMs: resultMessage.duration_api_ms,
      totalCostUsd: resultMessage.total_cost_usd,
      usage: resultMessage.usage,
      result: truncateForLog(getResultString(resultMessage), 300) || undefined
    });
    return;
  }

  if (message.type === 'stream_event') {
    logger.debug?.('[ClaudeAgent] Stream event', {
      ...basePayload,
      eventType: (message as { event?: { type?: string } }).event?.type
    });
    return;
  }

  if (message.type === 'system') {
    const systemMessage = message as SDKSystemMessage;

    logger.debug?.('[ClaudeAgent] System message', {
      ...basePayload,
      tools: systemMessage.tools,
      mcpServers: systemMessage.mcp_servers
    });
    return;
  }

  logger.debug?.('[ClaudeAgent] Message', basePayload);
};

export async function runClaudeAgent(params: RunClaudeAgentParams): Promise<ClaudeAgentResult> {
  const { prompt, systemPrompt, logger, options, resumeSessionId } = params;

  if (!prompt.trim()) {
    throw new Error('Claude Agent prompt must not be empty.');
  }
  
  if (!process.env.ANTHROPIC_API_KEY) {
    throw new Error('ANTHROPIC_API_KEY is not configured. Set it to call the Claude Agent SDK.');
  }

  const toolTimers = new Map<string, { tool: string; startedAt: number }>();

  const mergedOptions: Options = {
    cwd: process.cwd(),
    model: DEFAULT_MODEL,
    settingSources: ['project'],
    systemPrompt: {
      type: 'preset',
      preset: 'claude_code',
      append: systemPrompt
    },
    includePartialMessages: false,
    ...options
  };

  if (!mergedOptions.permissionMode) {
    mergedOptions.permissionMode = 'bypassPermissions';
  }

  if (resumeSessionId && !mergedOptions.resume) {
    mergedOptions.resume = resumeSessionId;
  }

  if (!mergedOptions.settingSources || mergedOptions.settingSources.length === 0) {
    mergedOptions.settingSources = ['project'];
  }

  if (!mergedOptions.systemPrompt) {
    mergedOptions.systemPrompt = {
      type: 'preset',
      preset: 'claude_code',
      append: systemPrompt
    };
  }

  const loggingHooks = createLoggingHooks(logger, toolTimers);
  mergedOptions.hooks = mergeHooks(loggingHooks, options?.hooks);

  logger?.debug?.('[ClaudeAgent] Invoking claude-agent-sdk', {
    model: mergedOptions.model,
    cwd: mergedOptions.cwd,
    settingSources: mergedOptions.settingSources
  });

  const session = query({ prompt, options: mergedOptions });
  let finalResult = '';
  let lastAssistantText = '';
  let resolvedSessionId: string | undefined;

  for await (const message of session) {
    logSdkMessage(message, logger);

    if (message.type === 'system') {
      const systemMessage = message as SDKSystemMessage;
      resolvedSessionId = systemMessage.session_id ?? resolvedSessionId;
    }

    if (isAssistantMessage(message)) {
      lastAssistantText = extractTextBlocks(message) || lastAssistantText;
      continue;
    }

    if (isResultMessage(message)) {
      if (message.subtype !== 'success' || message.is_error) {
        const reason = summarizeResultError(message);
        const failureResult = getResultString(message);
        logger?.error?.('[ClaudeAgent] Query failed', {
          result: failureResult,
          subtype: message.subtype,
          isError: message.is_error,
          permissionDenials: message.permission_denials
        });
        throw new Error(`Claude Agent run failed: ${reason}`);
      }
      finalResult = getResultString(message)?.trim() ?? '';
    }
  }

  if (!finalResult) {
    finalResult = lastAssistantText.trim();
  }

  if (!finalResult) {
    throw new Error('Claude Agent did not return any content.');
  }

  logger?.debug?.('[ClaudeAgent] Completed invocation');
  return { result: finalResult, sessionId: resolvedSessionId ?? resumeSessionId };
}
</file>

<file path="lib/mcp-client.ts">
// srv/lib/mcp-client.ts

import cds from '@sap/cds';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
import { initM365InProcessClient as createInProcessM365Client } from '../m365-mcp/index.js';
import { initCapMCPClient as createInProcessCapClient } from '../mcp-cap/index.js';

interface CapClientInitOptions {
  capService: any;
  logger?: Console;
}

interface InitAllClientOptions {
  capService?: any;
  logger?: Console;
}

interface InitAllClientsResult {
  cap: any;
  cdsModel: Client;
  postgres: Client;
  braveSearch: Client;
  playwright: null;
  filesystem: Client;
  excel: Client;
  m365: Awaited<ReturnType<typeof createInProcessM365Client>>;
  time: Client;
}

interface DbCredentials {
  user: string;
  password: string;
  host: string;
  port: number | string;
  database: string;
}

interface RequiresDbConfig {
  credentials?: Partial<DbCredentials> | null;
}

function normalizeDbCredentials(candidate: Partial<DbCredentials> | null | undefined): DbCredentials | null {
  if (!candidate) return null;
  const { user, password, host, database } = candidate;
  const port = candidate.port ?? 5433;
  if (!user || !password || !host || !database) {
    return null;
  }
  return {
    user,
    password,
    host,
    port,
    database
  };
}

function resolveDbCredentials(): DbCredentials {
  const requiresDb = cds.env?.requires?.db as RequiresDbConfig | undefined;
  const credentialsFromConfig = normalizeDbCredentials(requiresDb?.credentials ?? null);
  if (credentialsFromConfig) {
    return credentialsFromConfig;
  }

  const envCredentials = normalizeDbCredentials({
    user: process.env.POSTGRES_USER ?? process.env.CLAIMAI_POSTGRES_USER ?? undefined,
    password: process.env.POSTGRES_PASSWORD ?? process.env.CLAIMAI_POSTGRES_PASSWORD ?? undefined,
    host: process.env.POSTGRES_HOST ?? process.env.CLAIMAI_POSTGRES_HOST ?? 'localhost',
    port: process.env.POSTGRES_PORT ?? process.env.CLAIMAI_POSTGRES_PORT ?? 5433,
    database: process.env.POSTGRES_DB ?? process.env.CLAIMAI_POSTGRES_DB ?? undefined
  });

  if (envCredentials) {
    return envCredentials;
  }

  throw new Error('Unable to resolve PostgreSQL credentials from cds.env or process.env.');
}

function sanitizeEnv(overrides: Record<string, string | undefined> = {}): Record<string, string> {
  const sanitized: Record<string, string> = {};
  for (const [key, value] of Object.entries(process.env)) {
    if (typeof value === 'string') {
      sanitized[key] = value;
    }
  }
  for (const [key, value] of Object.entries(overrides)) {
    if (typeof value === 'string') {
      sanitized[key] = value;
    } else if (value === undefined) {
      delete sanitized[key];
    }
  }
  return sanitized;
}

const dbCredentials = resolveDbCredentials();

let postgresClient: Client | null = null;
let braveSearchClient: Client | null = null;
let playwrightClient: null = null;
let filesystemClient: Client | null = null;
let excelClient: Client | null = null;
let m365Client: Awaited<ReturnType<typeof createInProcessM365Client>> | null = null;
let timeClient: Client | null = null;
let capClient: any | null = null;
let cdsModelClient: Client | null = null;

function getPostgresUri(): string {
  const creds = dbCredentials;
  return `postgresql://${creds.user}:${creds.password}@${creds.host}:${creds.port}/${creds.database}`;
}

export async function initPostgresMCPClient(): Promise<Client> {
  if (postgresClient) return postgresClient;
  console.log('Initializing PostgreSQL MCP client...');
  const postgresUri = getPostgresUri();
  const transport = new StdioClientTransport({
    command: 'npx',
    args: ['-y', 'mcp-postgres-full-access', postgresUri]
  });
  postgresClient = new Client({ name: 'postgres-client', version: '1.0.0' }, {});
  await postgresClient.connect(transport);
  console.log('✅ PostgreSQL MCP Client initialized successfully.');
  return postgresClient;
}

export async function initBraveSearchMCPClient(): Promise<Client> {
  if (braveSearchClient) return braveSearchClient;
  const braveApiKey = process.env.BRAVE_API_KEY || (cds.env as any).BRAVE_API_KEY;
  if (!braveApiKey) throw new Error('BRAVE_API_KEY is required but not provided');
  console.log('Initializing Brave Search MCP client...');
  const transport = new StdioClientTransport({
    command: 'npx',
    args: ['-y', '@modelcontextprotocol/server-brave-search'],
    env: sanitizeEnv({ BRAVE_API_KEY: braveApiKey })
  });
  braveSearchClient = new Client({ name: 'brave-search-client', version: '1.0.0' }, {});
  await braveSearchClient.connect(transport);
  console.log('✅ Brave Search MCP Client initialized successfully.');
  return braveSearchClient;
}

export async function initPlaywrightMCPClient(): Promise<null> {
  console.log('⏸️ Playwright MCP client initialization is temporarily disabled.');
  return null;
}

export async function initFilesystemMCPClient(): Promise<Client> {
  if (filesystemClient) return filesystemClient;
  console.log('Initializing Filesystem MCP client...');
  const allowedDirectory = process.env.M365_ATTACHMENT_BASE_PATH || process.cwd();
  console.log(`Filesystem access is sandboxed to: ${allowedDirectory}`);
  const transport = new StdioClientTransport({
    command: 'npx',
    args: ['-y', '@modelcontextprotocol/server-filesystem', allowedDirectory]
  });
  filesystemClient = new Client({ name: 'filesystem-client', version: '1.0.0' }, {});
  await filesystemClient.connect(transport);
  console.log('✅ Filesystem MCP Client initialized successfully.');
  return filesystemClient;
}

export async function initExcelMCPClient(): Promise<Client> {
  if (excelClient) return excelClient;

  console.log('Initializing Excel MCP client...');
  const transport = new StdioClientTransport({
    command: process.platform === 'win32' ? 'cmd' : 'npx',
    args: process.platform === 'win32'
      ? ['/c', 'npx', '--yes', '@negokaz/excel-mcp-server']
      : ['--yes', '@negokaz/excel-mcp-server'],
    env: sanitizeEnv({ EXCEL_MCP_PAGING_CELLS_LIMIT: '4000' })
  });

  excelClient = new Client({ name: 'excel-client', version: '1.0.0' }, {});
  await excelClient.connect(transport);
  console.log('✅ Excel MCP Client initialized successfully.');
  return excelClient;
}

export async function initM365Client(): Promise<Awaited<ReturnType<typeof createInProcessM365Client>>> {
  if (m365Client) return m365Client;
  m365Client = await createInProcessM365Client({ logger: console });
  return m365Client;
}

export async function initTimeMCPClient(): Promise<Client> {
  if (timeClient) return timeClient;

  const command = process.env.TIME_MCP_COMMAND || 'python';
  let args: string[];
  try {
    const parsed = process.env.TIME_MCP_ARGS ? JSON.parse(process.env.TIME_MCP_ARGS) : ['-m', 'mcp_server_time'];
    if (!Array.isArray(parsed)) {
      throw new Error('TIME_MCP_ARGS must be a JSON array string when provided.');
    }
    args = parsed;
  } catch (error) {
    const err = error as Error;
    throw new Error(`Failed to parse TIME_MCP_ARGS. Provide a JSON array string, e.g. ["-m","mcp_server_time"]. Original error: ${err.message}`);
  }

  console.log('Initializing Time MCP client...');
  const transport = new StdioClientTransport({
    command,
    args,
    env: sanitizeEnv()
  });

  timeClient = new Client({ name: 'time-client', version: '1.0.0' }, {});
  await timeClient.connect(transport);
  console.log('✅ Time MCP Client initialized successfully.');

  return timeClient;
}

export async function initCdsModelMCPClient(): Promise<Client> {
  if (cdsModelClient) return cdsModelClient;

  console.log('Initializing cds-mcp (model/documentation) client...');
  const transport = new StdioClientTransport({
    command: 'npx',
    args: ['--yes', '--package', '@cap-js/mcp-server', 'cds-mcp']
  });

  cdsModelClient = new Client({ name: 'cds-mcp-client', version: '1.0.0' }, {});
  await cdsModelClient.connect(transport);
  console.log('✅ cds-mcp client initialized successfully.');
  return cdsModelClient;
}

export async function initCapInProcessClient({ capService, logger }: CapClientInitOptions): Promise<any> {
  if (capClient) return capClient;
  if (!capService) {
    throw new Error('initCapInProcessClient requires the CAP service instance.');
  }
  console.log('Initializing CAP in-process MCP client...');
  capClient = await createInProcessCapClient({ service: capService, logger });
  console.log('✅ CAP MCP Client initialized successfully.');
  return capClient;
}

export async function initAllMCPClients(options: InitAllClientOptions = {}): Promise<InitAllClientsResult> {
  console.log('Initializing all MCP clients...');

  const { capService, logger } = options;
  const [capInProcessClient, cdsModel, pgClient, braveClient, fsClient, xlsxClient, microsoft365Client, timeMcpClient] = await Promise.all([
    initCapInProcessClient({ capService, logger }),
    initCdsModelMCPClient(),
    initPostgresMCPClient(),
    initBraveSearchMCPClient(),
    initFilesystemMCPClient(),
    initExcelMCPClient(),
    initM365Client(),
    initTimeMCPClient()
  ]);

  return {
    cap: capInProcessClient,
    cdsModel,
    postgres: pgClient,
    braveSearch: braveClient,
    playwright: playwrightClient,
    filesystem: fsClient,
    excel: xlsxClient,
    m365: microsoft365Client,
    time: timeMcpClient
  };
}

export async function closeMCPClients(): Promise<void> {
  const closePromises: Array<Promise<unknown>> = [];

  if (postgresClient) {
    console.log('Closing PostgreSQL MCP client connection');
    closePromises.push(postgresClient.close());
    postgresClient = null;
  }
  if (braveSearchClient) {
    console.log('Closing Brave Search MCP client connection');
    closePromises.push(braveSearchClient.close());
    braveSearchClient = null;
  }
  if (filesystemClient) {
    console.log('Closing Filesystem MCP client connection');
    closePromises.push(filesystemClient.close());
    filesystemClient = null;
  }
  if (excelClient) {
    console.log('Closing Excel MCP client connection');
    closePromises.push(excelClient.close());
    excelClient = null;
  }
  if (cdsModelClient) {
    console.log('Closing cds-mcp client connection');
    closePromises.push(cdsModelClient.close());
    cdsModelClient = null;
  }
  if (m365Client) {
    console.log('Closing Microsoft 365 MCP client connection');
    closePromises.push(m365Client.close());
    m365Client = null;
  }
  if (timeClient) {
    console.log('Closing Time MCP client connection');
    closePromises.push(timeClient.close());
    timeClient = null;
  }
  if (capClient) {
    console.log('Closing CAP MCP client connection');
    closePromises.push(capClient.close());
    capClient = null;
  }

  await Promise.all(closePromises);
  console.log('✅ All MCP clients closed');
}

export const initMCPClient = initPostgresMCPClient;
export const closeMCPClient = closeMCPClients;
</file>

<file path="m365-mcp/graph-client.ts">
// srv/m365-mcp/graph-client.ts
// Thin wrapper around the Microsoft Graph API using the m365 CLI for authentication.

import { execFile } from 'node:child_process';
import { promisify } from 'node:util';
import { setTimeout as delay } from 'node:timers/promises';
import { existsSync } from 'node:fs';
import { mkdir, writeFile } from 'node:fs/promises';
import path from 'node:path';

const execFileAsync = promisify(execFile);
const GRAPH_RESOURCE = 'https://graph.microsoft.com';
const GRAPH_BASE_URL = `${GRAPH_RESOURCE}/v1.0`;
const DEFAULT_TOKEN_TTL_MS = 5 * 60 * 1000;

interface LoggerLike {
  log?: (...args: unknown[]) => void;
  info?: (...args: unknown[]) => void;
  warn?: (...args: unknown[]) => void;
  error?: (...args: unknown[]) => void;
  debug?: (...args: unknown[]) => void;
}

export interface GraphClientOptions {
  authMethod?: string;
  cliCommand?: string;
  logger?: LoggerLike;
  tokenTtlMs?: number;
}

interface TokenCacheEntry {
  token: string;
  expiresAt: number;
}

interface RequestOptions {
  query?: Record<string, string>;
  headers?: Record<string, string>;
  body?: unknown;
  scopes?: string[];
}

interface LatestMessageInput {
  folderId?: string;
}

interface ReplyToMessageInput {
  messageId: string;
  comment?: string;
  body?: string;
  contentType?: string;
  replyAll?: boolean;
}

interface DownloadAttachmentInput {
  messageId: string;
  attachmentId: string;
  targetPath: string;
}

interface ListMessagesInput {
  folderId?: string;
  startDateTime?: string;
  endDateTime?: string;
  maxResults?: number;
  onlyUnread?: boolean;
}

interface CalendarEventsInput {
  startDateTime: string;
  endDateTime: string;
}

interface CreateCalendarEventInput {
  subject: string;
  body?: string;
  contentType?: string;
  startDateTime: string;
  endDateTime: string;
  timezone?: string;
  attendees?: Array<string | Record<string, any>>;
  teams?: boolean;
  location?: unknown;
  reminderMinutesBeforeStart?: number;
  allowNewTimeProposals?: boolean;
  isOnlineMeeting?: boolean;
  onlineMeetingProvider?: string;
}

export class GraphClient {
  private readonly authMethod: string;
  private readonly cliCommand: string;
  private readonly logger: LoggerLike;
  private readonly tokenTtlMs: number;
  private readonly tokenCache: Map<string, TokenCacheEntry>;
  private closed: boolean;
  private scopesOptionSupported: boolean;

  constructor(options: GraphClientOptions = {}) {
    const {
      authMethod = process.env.M365_AUTH_METHOD || 'cli',
      cliCommand = process.env.M365_CLI_COMMAND || 'm365',
      logger = console,
      tokenTtlMs = DEFAULT_TOKEN_TTL_MS
    } = options;

    this.authMethod = authMethod;
    this.cliCommand = cliCommand;
    this.logger = logger;
    this.tokenTtlMs = tokenTtlMs;
    this.tokenCache = new Map<string, TokenCacheEntry>();
    this.closed = false;
    this.scopesOptionSupported = true;
  }

  async bootstrap(scopes: string[] = ['Mail.Read']): Promise<void> {
    this.logger.log?.('Initializing Microsoft 365 in-process MCP client...');
    try {
      await this.getAccessToken(scopes);
      this.logger.log?.('✅ Microsoft 365 MCP client initialized successfully.');
    } catch (error) {
      const err = error as Error;
      this.logger.error?.('❌ Failed to initialize Microsoft 365 MCP client:', err.message);
      throw err;
    }
  }

  async getAccessToken(scopes: string[] = []): Promise<string> {
    if (this.closed) {
      throw new Error('GraphClient is closed');
    }
    if (this.authMethod !== 'cli') {
      throw new Error(`Unsupported M365 auth method: ${this.authMethod}`);
    }

    const normalizedScopes = Array.isArray(scopes) ? [...scopes].sort() : [];
    const cacheKey = normalizedScopes.join(' ');
    const cached = this.tokenCache.get(cacheKey);
    if (cached && cached.expiresAt > Date.now()) {
      return cached.token;
    }

    const cliArgs = ['util', 'accesstoken', 'get', '--resource', GRAPH_RESOURCE];
    if (normalizedScopes.length && this.scopesOptionSupported) {
      cliArgs.push('--scope', normalizedScopes.join(','));
    }

    try {
      const execOptions: Record<string, unknown> = {
        env: process.env,
        maxBuffer: 1024 * 1024
      };

      if (process.platform === 'win32') {
        const lower = this.cliCommand.toLowerCase();
        if (lower.endsWith('.cmd') || lower.endsWith('.bat')) {
          execOptions.shell = process.env.ComSpec || 'cmd.exe';
        }
      }

      const { stdout } = await execFileAsync(this.cliCommand, cliArgs, execOptions);
      const token = stdout.trim();
      if (!token) {
        throw new Error('m365 CLI returned an empty access token. Ensure you are logged in with "m365 login".');
      }
      this.tokenCache.set(cacheKey, {
        token,
        expiresAt: Date.now() + this.tokenTtlMs
      });
      return token;
    } catch (error) {
      const err = error as NodeJS.ErrnoException & { stderr?: string };
      const errorMessage = String(err?.stderr || err?.message || err);
      if (normalizedScopes.length && this.scopesOptionSupported && /Invalid option: 'scopes?'/.test(errorMessage)) {
        this.logger.warn?.('m365 CLI does not support the --scope option. Falling back to default Graph scopes.');
        this.scopesOptionSupported = false;
        return this.getAccessToken([]);
      }
      if (err?.code === 'ENOENT') {
        throw new Error(`Could not find the m365 CLI (${this.cliCommand}). Install it via "npm i -g @pnp/cli-microsoft365".`);
      }
      throw new Error(`Failed to acquire Microsoft Graph token via m365 CLI: ${err?.message}`);
    }
  }

  async request<T = any>(method: string, relativePath: string, { query = {}, headers = {}, body, scopes = [] }: RequestOptions = {}): Promise<T> {
    if (this.closed) {
      throw new Error('GraphClient is closed');
    }

    const url = new URL(relativePath.replace(/^\//, ''), `${GRAPH_BASE_URL}/`);
    Object.entries(query)
      .filter(([, value]) => value !== undefined && value !== null && value !== '')
      .forEach(([key, value]) => {
        url.searchParams.append(key, String(value));
      });

    const accessToken = await this.getAccessToken(scopes);
    const baseHeaders: Record<string, string> = {
      Authorization: `Bearer ${accessToken}`,
      Accept: 'application/json'
    };

    const requestHeaders: Record<string, string> = { ...baseHeaders, ...headers };
    const requestInit: RequestInit = {
      method,
      headers: requestHeaders
    };

    if (body !== undefined) {
      requestInit.body = typeof body === 'string' ? body : JSON.stringify(body);
      requestHeaders['Content-Type'] = 'application/json';
    }

    // this.logger.debug?.(`Graph request ${method} ${url} with body ${safeJson(body)}`);

    const response = await fetch(url, requestInit);
    if (!response.ok) {
      const errorBody = await response.text();
      throw new Error(`Graph request failed (${response.status} ${response.statusText}): ${errorBody}`);
    }
    const contentType = response.headers.get('content-type') || '';
    if (contentType.includes('application/json')) {
      return (await response.json()) as T;
    }
    return Buffer.from(await response.arrayBuffer()) as T;
  }

  async getLatestMessage({ folderId = 'inbox' }: LatestMessageInput = {}) {
    const data = await this.request<any>(
      'GET',
      `/me/mailFolders/${encodeURIComponent(folderId)}/messages`,
      {
        query: {
          '$top': '1',
          '$orderby': 'receivedDateTime desc',
          '$select': 'id,subject,from,toRecipients,receivedDateTime,hasAttachments,bodyPreview,body,isRead,webLink',
          '$expand': 'attachments($select=id,name,contentType,size,isInline)'
        },
        scopes: ['Mail.Read']
      }
    );
    const message = Array.isArray(data.value) && data.value.length ? data.value[0] : null;
    if (!message) {
      return null;
    }
    return {
      id: message.id,
      subject: message.subject,
      from: message.from?.emailAddress || null,
      toRecipients: (message.toRecipients || []).map((entry: any) => entry.emailAddress),
      receivedDateTime: message.receivedDateTime,
      isRead: Boolean(message.isRead),
      webLink: message.webLink,
      hasAttachments: Boolean(message.hasAttachments),
      bodyPreview: message.bodyPreview || null,
      body: message.body
        ? {
            contentType: message.body.contentType,
            content: message.body.content
          }
        : null,
      attachments: Array.isArray(message.attachments)
        ? message.attachments.map((attachment: any) => ({
            id: attachment.id,
            name: attachment.name,
            contentType: attachment.contentType,
            size: attachment.size,
            isInline: attachment.isInline
          }))
        : []
    };
  }

  async replyToMessage({ messageId, comment = '', body, contentType = 'Text', replyAll = false }: ReplyToMessageInput) {
    if (!messageId) {
      throw new Error('messageId is required to reply to a mail.');
    }

    const normalizedType = (contentType || 'Text').toUpperCase() === 'HTML' ? 'HTML' : 'Text';
    const payload: Record<string, unknown> = {
      comment: comment ?? ''
    };

    if (body) {
      payload.message = {
        body: {
          contentType: normalizedType,
          content: body
        }
      };
    }

    const endpoint = replyAll
      ? `/me/messages/${encodeURIComponent(messageId)}/replyAll`
      : `/me/messages/${encodeURIComponent(messageId)}/reply`;

    await this.request('POST', endpoint, {
      body: payload,
      scopes: ['Mail.Send']
    });

    return {
      status: 'sent',
      replyAll: Boolean(replyAll)
    };
  }

  async downloadAttachment({ messageId, attachmentId, targetPath }: DownloadAttachmentInput) {
    if (!messageId || !attachmentId || !targetPath) {
      throw new Error('messageId, attachmentId and targetPath are required for attachment download.');
    }

    let resolvedTargetPath = targetPath;
    const baseDirectory = process.env.M365_ATTACHMENT_BASE_PATH;
    if (!path.isAbsolute(resolvedTargetPath)) {
      resolvedTargetPath = baseDirectory
        ? path.resolve(baseDirectory, resolvedTargetPath)
        : path.resolve(resolvedTargetPath);
    }

    const attachmentBinary = await this.request<Buffer>(
      'GET',
      `/me/messages/${encodeURIComponent(messageId)}/attachments/${encodeURIComponent(attachmentId)}/$value`,
      {
        scopes: ['Mail.Read'],
        headers: {
          Accept: 'application/octet-stream'
        }
      }
    );

    const directory = path.dirname(resolvedTargetPath);
    if (!existsSync(directory)) {
      await mkdir(directory, { recursive: true });
    }

    await writeFile(resolvedTargetPath, attachmentBinary);

    const bytesWritten = typeof attachmentBinary.length === 'number'
      ? attachmentBinary.length
      : (attachmentBinary.byteLength || 0);

    return {
      messageId,
      attachmentId,
      targetPath: resolvedTargetPath,
      bytesWritten
    };
  }

  async listMessages({ folderId = 'inbox', startDateTime, endDateTime, maxResults = 20, onlyUnread = false }: ListMessagesInput = {}) {
    const numericMax = typeof maxResults === 'number' ? maxResults : undefined;
    const safeTop = Number.isInteger(numericMax ?? NaN)
      ? Math.min(Math.max(numericMax as number, 1), 200)
      : 20;

    const filterParts: string[] = [];
    if (startDateTime) {
      filterParts.push(`receivedDateTime ge ${startDateTime}`);
    }
    if (endDateTime) {
      filterParts.push(`receivedDateTime le ${endDateTime}`);
    }
    if (onlyUnread) {
      filterParts.push('isRead eq false');
    }

    const query: Record<string, string> = {
      '$orderby': 'receivedDateTime desc',
      '$top': String(safeTop),
      '$select': 'id,subject,from,toRecipients,receivedDateTime,hasAttachments,bodyPreview,body,isRead,webLink',
      '$expand': 'attachments($select=id,name,contentType,size,isInline)'
    };

    if (filterParts.length) {
      query['$filter'] = filterParts.join(' and ');
    }

    const data = await this.request<any>(
      'GET',
      `/me/mailFolders/${encodeURIComponent(folderId)}/messages`,
      {
        query,
        scopes: ['Mail.Read']
      }
    );

    return (data.value || []).map((message: any) => ({
      id: message.id,
      subject: message.subject,
      from: message.from?.emailAddress || null,
      toRecipients: (message.toRecipients || []).map((entry: any) => entry.emailAddress),
      receivedDateTime: message.receivedDateTime,
      isRead: Boolean(message.isRead),
      webLink: message.webLink,
      hasAttachments: Boolean(message.hasAttachments),
      bodyPreview: message.bodyPreview || null,
      attachments: Array.isArray(message.attachments)
        ? message.attachments.map((attachment: any) => ({
            id: attachment.id,
            name: attachment.name,
            contentType: attachment.contentType,
            size: attachment.size,
            isInline: attachment.isInline
          }))
        : []
    }));
  }

  async listUnreadMessages({ folderId = 'inbox', maxResults = 20 }: { folderId?: string; maxResults?: number } = {}) {
    return this.listMessages({ folderId, maxResults, onlyUnread: true });
  }

  async markMessageRead(messageId: string, isRead = true) {
    if (!messageId) throw new Error('messageId is required');
    const body = { isRead: Boolean(isRead) };
    await this.request(
      'PATCH',
      `/me/messages/${encodeURIComponent(messageId)}`,
      { body, scopes: ['Mail.ReadWrite'] }
    );
    return { id: messageId, isRead: Boolean(isRead) };
  }

  async listCalendarEvents({ startDateTime, endDateTime }: CalendarEventsInput) {
    if (!startDateTime || !endDateTime) {
      throw new Error('startDateTime and endDateTime are required to list events.');
    }

    const data = await this.request<any>(
      'GET',
      '/me/calendarView',
      {
        query: {
          startDateTime,
          endDateTime,
          '$orderby': 'start/dateTime asc'
        },
        scopes: ['Calendars.Read']
      }
    );

    return (data.value || []).map((event: any) => ({
      id: event.id,
      subject: event.subject,
      start: event.start,
      end: event.end,
      location: event.location,
      organizer: event.organizer
    }));
  }

  async createCalendarEvent({
    subject,
    body,
    contentType = 'Text',
    startDateTime,
    endDateTime,
    timezone = 'UTC',
    attendees = [],
    teams = false,
    location,
    reminderMinutesBeforeStart,
    allowNewTimeProposals,
    isOnlineMeeting,
    onlineMeetingProvider
  }: CreateCalendarEventInput): Promise<any> {
    if (!subject) {
      throw new Error('subject is required to create an event.');
    }
    if (!startDateTime || !endDateTime) {
      throw new Error('startDateTime and endDateTime are required.');
    }

    const normalizedContentType = (contentType || 'Text').toUpperCase() === 'HTML' ? 'HTML' : 'Text';
    const attendeeArray = Array.isArray(attendees) ? attendees : [];

    const eventPayload: Record<string, any> = {
      subject,
      start: {
        dateTime: startDateTime,
        timeZone: timezone || 'UTC'
      },
      end: {
        dateTime: endDateTime,
        timeZone: timezone || 'UTC'
      },
      attendees: attendeeArray
        .map((entry) => {
          if (!entry) return null;
          if (typeof entry === 'string') {
            return {
              emailAddress: {
                address: entry
              },
              type: 'required'
            };
          }
          const record = entry as Record<string, any>;
          const address = record.address || record.email || record.mail || record.emailAddress;
          if (!address) return null;
          return {
            emailAddress: {
              address,
              name: record.name || record.displayName || undefined
            },
            type: record.type || 'required'
          };
        })
        .filter(Boolean)
    };

    if (body) {
      eventPayload.body = {
        contentType: normalizedContentType,
        content: body
      };
    }

    if (location) {
      eventPayload.location = typeof location === 'string'
        ? { displayName: location }
        : location;
    }

    if (typeof reminderMinutesBeforeStart === 'number') {
      eventPayload.reminderMinutesBeforeStart = reminderMinutesBeforeStart;
    }

    if (typeof allowNewTimeProposals === 'boolean') {
      eventPayload.allowNewTimeProposals = allowNewTimeProposals;
    }

    if (typeof isOnlineMeeting === 'boolean') {
      eventPayload.isOnlineMeeting = isOnlineMeeting;
    }

    if (onlineMeetingProvider) {
      eventPayload.onlineMeetingProvider = onlineMeetingProvider;
    }

    if (teams) {
      eventPayload.isOnlineMeeting = true;
      eventPayload.onlineMeetingProvider = 'teamsForBusiness';
    }

    const response = await this.request<any>('POST', '/me/events', {
      body: eventPayload,
      scopes: ['Calendars.ReadWrite']
    });

    return response;
  }

  async close(): Promise<void> {
    this.closed = true;
    this.tokenCache.clear();
    // Give pending CLI processes a moment to settle; mainly relevant for unit tests.
    await delay(10);
  }
}
</file>

<file path="m365-mcp/helpers/logging.ts">
// srv/m365-mcp/helpers/logging.ts
// Provides defensive JSON serialization for logging without crashing on circular structures.

export function safeJson(value: unknown, max = 4000): string {
  try {
    const serialized = typeof value === 'string' ? value : JSON.stringify(value);
    const output = typeof serialized === 'string' ? serialized : String(serialized);
    return output.length > max ? `${output.slice(0, max)} ...[truncated]` : output;
  } catch (error) {
    try {
      return String(value);
    } catch {
      return '[unprintable]';
    }
  }
}
</file>

<file path="m365-mcp/index.ts">
// srv/m365-mcp/index.ts
// Entry point for the Microsoft 365 in-process MCP client.

import { createM365ToolManifest, toolDefinitions } from './mcp-tool-manifest.js';
import { GraphClient, type GraphClientOptions } from './graph-client.js';
import { getToolHandler, listSupportedTools } from './tools/index.js';
import { safeJson } from './helpers/logging.js';

type LoggerLike = Console | { error?: (...args: unknown[]) => void; log?: (...args: unknown[]) => void; info?: (...args: unknown[]) => void };

interface InitOptions extends GraphClientOptions {
  bootstrapScopes?: string[];
  logger?: LoggerLike;
}

interface ToolInvocation {
  name: string;
  arguments?: Record<string, unknown>;
}

export async function initM365InProcessClient(options: InitOptions = {}) {
  const {
    logger = console,
    bootstrapScopes = ['Mail.Read']
  } = options;

  const graphClient = new GraphClient({ ...options, logger });
  await graphClient.bootstrap(bootstrapScopes);

  async function listTools() {
    return createM365ToolManifest();
  }

  async function callTool({ name, arguments: args = {} }: ToolInvocation) {
    if (!name) {
      throw new Error('Tool name is required');
    }
    const handler = getToolHandler(name);
    if (!handler) {
      throw new Error(`Unknown Microsoft 365 tool: ${name}. Supported tools: ${listSupportedTools().join(', ')}`);
    }
    const input = args && typeof args === 'object' ? args : {};
    try {
      const result = await handler({ input, graphClient, logger });
      return result;
    } catch (error) {
      const err = error as Error & { message?: string };
      logger.error?.(`Error while executing Microsoft 365 tool ${name}:`, safeJson(err.message || err));
      throw err;
    }
  }

  async function close() {
    await graphClient.close();
  }

  return {
    listTools,
    callTool,
    close,
    toolDefinitions
  };
}
</file>

<file path="m365-mcp/mcp-jsonschema.ts">
// srv/m365-mcp/mcp-jsonschema.ts
// Minimal JSON Schema to Zod converter tailored to the MCP tool definitions.

import type { UnknownKeysParam, ZodObject, ZodTypeAny } from 'zod';

type ZodNamespace = typeof import('zod');

export interface JsonSchema {
  type?: 'string' | 'number' | 'integer' | 'boolean' | 'array' | 'object';
  enum?: unknown[];
  description?: string;
  default?: unknown;
  properties?: Record<string, JsonSchema>;
  required?: string[];
  additionalProperties?: JsonSchema | boolean;
  minProperties?: number;
  maxProperties?: number;
  items?: JsonSchema | JsonSchema[];
  minItems?: number;
  maxItems?: number;
  format?: string;
  minLength?: number;
  maxLength?: number;
  minimum?: number;
  maximum?: number;
  anyOf?: JsonSchema[];
}

const hasOwn = Object.prototype.hasOwnProperty;

function applyCommonMetadata(schema: ZodTypeAny, jsonSchema?: JsonSchema | null): ZodTypeAny {
  let result: ZodTypeAny = schema;
  if (jsonSchema?.description) {
    result = result.describe(jsonSchema.description);
  }
  if (jsonSchema && hasOwn.call(jsonSchema, 'default')) {
    result = result.default(jsonSchema.default as unknown) as ZodTypeAny;
  }
  return result;
}

function convertEnum(schema: JsonSchema, z: ZodNamespace): ZodTypeAny | null {
  if (!Array.isArray(schema.enum) || schema.enum.length === 0) {
    return null;
  }
  if (schema.enum.every((value) => typeof value === 'string')) {
    const stringValues = schema.enum as string[];
    const [first, ...rest] = stringValues;
    return applyCommonMetadata(z.enum([first, ...rest] as [string, ...string[]]), schema);
  }
  const literals = schema.enum.map((value) => z.literal(value as never)) as ZodTypeAny[];
  if (literals.length === 1) {
    return applyCommonMetadata(literals[0], schema);
  }
  const [firstLiteral, secondLiteral, ...rest] = literals;
  return applyCommonMetadata(z.union([firstLiteral, secondLiteral, ...rest] as [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]), schema);
}

function convertArray(schema: JsonSchema, z: ZodNamespace): ZodTypeAny {
  const itemDefinition = Array.isArray(schema.items) ? schema.items[0] : schema.items;
  const itemSchema = itemDefinition ? jsonSchemaToZod(itemDefinition, z) : z.any();
  let arraySchema = z.array(itemSchema);
  if (typeof schema.minItems === 'number') {
    arraySchema = arraySchema.min(schema.minItems);
  }
  if (typeof schema.maxItems === 'number') {
    arraySchema = arraySchema.max(schema.maxItems);
  }
  return applyCommonMetadata(arraySchema, schema);
}

function convertObject(schema: JsonSchema, z: ZodNamespace): ZodTypeAny {
  const properties = schema.properties || {};
  const requiredProps = new Set(schema.required || []);
  const shape: Record<string, ZodTypeAny> = {};

  for (const [key, propertySchema] of Object.entries(properties)) {
    let prop = jsonSchemaToZod(propertySchema, z);
    if (!requiredProps.has(key)) {
      prop = prop.optional();
    }
    shape[key] = prop;
  }

  let objectSchema: ZodObject<Record<string, ZodTypeAny>, UnknownKeysParam, ZodTypeAny> = z.object(shape);
  if (schema.additionalProperties === true) {
    objectSchema = objectSchema.passthrough();
  } else if (schema.additionalProperties && typeof schema.additionalProperties === 'object') {
    const additional = jsonSchemaToZod(schema.additionalProperties, z);
    objectSchema = objectSchema.catchall(additional);
  } else {
    objectSchema = objectSchema.strict();
  }

  let resultSchema: ZodTypeAny = objectSchema;

  if (typeof schema.minProperties === 'number' || typeof schema.maxProperties === 'number') {
    const { minProperties, maxProperties } = schema;
    resultSchema = objectSchema.superRefine((data, ctx) => {
      const propertyCount = Object.keys(data).length;
      if (typeof minProperties === 'number' && propertyCount < minProperties) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Expected at least ${minProperties} properties`
        });
      }
      if (typeof maxProperties === 'number' && propertyCount > maxProperties) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Expected at most ${maxProperties} properties`
        });
      }
    });
  }

  return applyCommonMetadata(resultSchema, schema);
}

export function jsonSchemaToZod(schema: JsonSchema | undefined, z: ZodNamespace): ZodTypeAny {
  if (!schema) {
    return z.any();
  }

  if (schema.enum) {
    const enumSchema = convertEnum(schema, z);
    if (enumSchema) {
      return enumSchema;
    }
  }

  switch (schema.type) {
    case 'string': {
      let stringSchema = z.string();
      if (schema.format === 'date-time') {
        stringSchema = stringSchema.regex(/^[^\s]+$/, 'Expected ISO-8601 datetime string');
      }
      if (typeof schema.minLength === 'number') {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === 'number') {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      return applyCommonMetadata(stringSchema, schema);
    }
    case 'number':
    case 'integer': {
      let numberSchema = schema.type === 'integer' ? z.number().int() : z.number();
      if (typeof schema.minimum === 'number') {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === 'number') {
        numberSchema = numberSchema.max(schema.maximum);
      }
      return applyCommonMetadata(numberSchema, schema);
    }
    case 'boolean': {
      return applyCommonMetadata(z.boolean(), schema);
    }
    case 'array': {
      return convertArray(schema, z);
    }
    case 'object': {
      return convertObject(schema, z);
    }
    default:
      return applyCommonMetadata(z.any(), schema);
  }
}
</file>

<file path="m365-mcp/mcp-tool-manifest.ts">
// srv/m365-mcp/mcp-tool-manifest.ts
// Describes the tool surface exposed by the Microsoft 365 in-process MCP client.

import type { JsonSchema } from './mcp-jsonschema.js';

const manifestVersion = '0.1.0';

type ToolMetadata = {
  scopes?: string[];
};

export interface ToolDefinition {
  name: string;
  description: string;
  inputSchema: JsonSchema;
  metadata?: ToolMetadata;
}

function clone<T>(value: T): T {
  return JSON.parse(JSON.stringify(value)) as T;
}

export const toolDefinitions: ToolDefinition[] = [
  {
    name: 'mail.latestMessage.get',
    description: 'Liest deterministisch die neueste Nachricht aus einem Mailordner und liefert Metadaten.',
    inputSchema: {
      type: 'object',
      properties: {
        folderId: {
          type: 'string',
          description: 'ID oder bekannter Name des Zielordners, z. B. inbox.',
          default: 'inbox'
        }
      }
    },
    metadata: { scopes: ['Mail.Read'] }
  },
  {
    name: 'mail.messages.list',
    description: 'Listet eingegangene Nachrichten eines Ordners, optional gefiltert nach Zeitraum und Limit.',
    inputSchema: {
      type: 'object',
      properties: {
        folderId: {
          type: 'string',
          description: 'ID oder bekannter Name des Mailordners (z. B. inbox).',
          default: 'inbox'
        },
        startDateTime: {
          type: 'string',
          description: 'ISO-8601 Zeitpunkt. Filtert Nachrichten mit Empfangszeit >= startDateTime.'
        },
        endDateTime: {
          type: 'string',
          description: 'ISO-8601 Zeitpunkt. Filtert Nachrichten mit Empfangszeit <= endDateTime.'
        },
        maxResults: {
          type: 'integer',
          minimum: 1,
          maximum: 200,
          default: 20,
          description: 'Begrenzt die Anzahl der zurückgegebenen Nachrichten (1-200). Standard: 20.'
        }
      }
    },
    metadata: { scopes: ['Mail.Read'] }
  },
  {
    name: 'mail.attachment.download',
    description: 'Lädt einen bestimmten Anhang einer Nachricht und speichert ihn deterministisch im Zielpfad.',
    inputSchema: {
      type: 'object',
      required: ['messageId', 'attachmentId', 'targetPath'],
      properties: {
        messageId: { type: 'string', description: 'ID der Nachricht.' },
        attachmentId: { type: 'string', description: 'ID des Anhangs.' },
        targetPath: {
          type: 'string',
          description: 'Absoluter Ablageort für den heruntergeladenen Anhang.'
        }
    }
    },
    metadata: { scopes: ['Mail.Read'] }
  },
  {
    name: 'mail.message.reply',
    description: 'Antwortet auf eine vorhandene Nachricht (wahlweise Reply-All) mit Text oder HTML-Inhalt.',
    inputSchema: {
      type: 'object',
      required: ['messageId'],
      properties: {
        messageId: {
          type: 'string',
          description: 'ID der Nachricht, auf die geantwortet werden soll.'
        },
        comment: {
          type: 'string',
          description: 'Optionaler Kommentar, der oberhalb des Antworttexts eingefügt wird (Plain Text).'
        },
        body: {
          type: 'string',
          description: 'Optionaler kompletter Antworttext. Wird entsprechend contentType als Text oder HTML interpretiert.'
        },
        contentType: {
          type: 'string',
          description: 'Legt fest, ob der Body als Text oder HTML interpretiert wird.',
          enum: ['Text', 'HTML'],
          default: 'Text'
        },
        replyAll: {
          type: 'boolean',
          description: 'true, um „Allen antworten“ zu verwenden. Standard: false.'
        }
      }
    },
    metadata: { scopes: ['Mail.Send'] }
  },
  {
    name: 'calendar.events.list',
    description: 'Listet Kalenderereignisse in einem Zeitraum mit deterministischer Filterung.',
    inputSchema: {
      type: 'object',
      required: ['startDateTime', 'endDateTime'],
      properties: {
        startDateTime: { type: 'string', description: 'ISO-8601 Startzeitpunkt.' },
        endDateTime: { type: 'string', description: 'ISO-8601 Endzeitpunkt.' }
      }
    },
    metadata: { scopes: ['Calendars.Read'] }
  },
  {
    name: 'calendar.event.create',
    description: 'Erstellt einen neuen Kalendereintrag und kann optional ein Microsoft Teams Online-Meeting anlegen.',
    inputSchema: {
      type: 'object',
      required: ['subject', 'startDateTime', 'endDateTime'],
      properties: {
        subject: {
          type: 'string',
          description: 'Betreff des Termins.'
        },
        body: {
          type: 'string',
          description: 'Beschreibung des Termins. Wird gemäß contentType interpretiert.'
        },
        contentType: {
          type: 'string',
          enum: ['Text', 'HTML'],
          default: 'Text',
          description: 'Legt fest, ob die Beschreibung als Text oder HTML versendet wird.'
        },
        startDateTime: {
          type: 'string',
          description: 'Startzeit im ISO-8601 Format (z. B. 2024-09-01T09:00:00).'
        },
        endDateTime: {
          type: 'string',
          description: 'Endzeit im ISO-8601 Format.'
        },
        timezone: {
          type: 'string',
          description: 'Zeitzone für Start/Ende, z. B. Europe/Berlin. Standard: UTC.'
        },
        attendees: {
          type: 'array',
          description: 'Liste von Empfängern (E-Mail-Adressen als Strings).',
          items: {
            type: 'string'
          }
        },
        location: {
          description: 'Optionaler Ort (String oder Graph Location Objekt).',
          anyOf: [
            { type: 'string' },
            { type: 'object' }
          ]
        },
        reminderMinutesBeforeStart: {
          type: 'integer',
          description: 'Reminder in Minuten vor dem Start.'
        },
        allowNewTimeProposals: {
          type: 'boolean',
          description: 'Ob Teilnehmer neue Zeiten vorschlagen dürfen.'
        },
        isOnlineMeeting: {
          type: 'boolean',
          description: 'Setzt ein Online-Meeting ohne Provider-Auswahl.'
        },
        onlineMeetingProvider: {
          type: 'string',
          description: 'Optionaler Provider (z. B. teamsForBusiness).'
        },
        teams: {
          type: 'boolean',
          description: 'true, um automatisch ein Teams-Meeting zu erzeugen.'
        }
      }
    },
    metadata: { scopes: ['Calendars.ReadWrite'] }
  }
  // Weitere Tools aus dem PoC können hier ergänzt werden.
];

export function createM365ToolManifest() {
  return {
    namespace: 'm365',
    version: manifestVersion,
    tools: toolDefinitions.map(clone)
  };
}
</file>

<file path="m365-mcp/tools/calendar.ts">
// srv/m365-mcp/tools/calendar.ts
// Tool handlers for Microsoft 365 calendar interactions.

import { safeJson } from '../helpers/logging.js';
import type { GraphClient } from '../graph-client.js';

type LoggerLike = Console | { info?: (...args: unknown[]) => void; log?: (...args: unknown[]) => void } | undefined;

interface CalendarToolContext<TInput> {
  input: TInput;
  graphClient: GraphClient;
  logger?: LoggerLike;
}

interface CalendarEventsListInput {
  startDateTime: string;
  endDateTime: string;
}

interface CalendarEventCreateInput {
  subject: string;
  startDateTime: string;
  endDateTime: string;
  body?: string;
  contentType?: string;
  timezone?: string;
  attendees?: string[];
  teams?: boolean;
  location?: unknown;
  reminderMinutesBeforeStart?: number;
  allowNewTimeProposals?: boolean;
  isOnlineMeeting?: boolean;
  onlineMeetingProvider?: string;
}

function getInfoLogger(logger: LoggerLike): (...args: unknown[]) => void {
  if (!logger) return () => {};
  if (typeof logger.info === 'function') return logger.info.bind(logger);
  if (typeof logger.log === 'function') return logger.log.bind(logger);
  return () => {};
}

export async function handleCalendarEventsList({ input, graphClient, logger }: CalendarToolContext<CalendarEventsListInput>) {
  const info = getInfoLogger(logger);
  info('M365 calendar.events.list invoked with input:', safeJson(input));

  const events = await graphClient.listCalendarEvents({
    startDateTime: input.startDateTime,
    endDateTime: input.endDateTime
  });

  return {
    startDateTime: input.startDateTime,
    endDateTime: input.endDateTime,
    count: events.length,
    events
  };
}

export async function handleCalendarEventCreate({ input, graphClient, logger }: CalendarToolContext<CalendarEventCreateInput>) {
  const info = getInfoLogger(logger);
  const masked = {
    ...input,
    body: input.body ? '[provided]' : undefined
  };
  info('M365 calendar.event.create invoked with input:', safeJson(masked));

  const { startDateTime, endDateTime } = input;

  if (typeof startDateTime !== 'string' || typeof endDateTime !== 'string' || !startDateTime || !endDateTime) {
    throw new Error('startDateTime and endDateTime are required to create a calendar event.');
  }

  const result = await graphClient.createCalendarEvent({
    subject: input.subject,
    body: input.body,
    contentType: input.contentType,
    startDateTime,
    endDateTime,
    timezone: input.timezone,
    attendees: input.attendees,
    teams: input.teams,
    location: input.location,
    reminderMinutesBeforeStart: input.reminderMinutesBeforeStart,
    allowNewTimeProposals: input.allowNewTimeProposals,
    isOnlineMeeting: input.isOnlineMeeting,
    onlineMeetingProvider: input.onlineMeetingProvider
  });

  return result;
}
</file>

<file path="m365-mcp/tools/index.ts">
// srv/m365-mcp/tools/index.ts
// Registry of tool handlers exposed by the Microsoft 365 MCP client.

import { handleMailLatestMessage, handleMailAttachmentDownload, handleMailMessagesList, handleMailMessageReply } from './mail.js';
import { handleCalendarEventsList, handleCalendarEventCreate } from './calendar.js';

type ToolHandler = (...args: any[]) => unknown | Promise<unknown>;

const handlers: Record<string, ToolHandler> = {
  'mail.latestMessage.get': handleMailLatestMessage,
  'mail.attachment.download': handleMailAttachmentDownload,
  'mail.messages.list': handleMailMessagesList,
  'mail.message.reply': handleMailMessageReply,
  'calendar.events.list': handleCalendarEventsList,
  'calendar.event.create': handleCalendarEventCreate
};

export function getToolHandler(name: string): ToolHandler | null {
  return handlers[name] || null;
}

export function listSupportedTools(): string[] {
  return Object.keys(handlers);
}
</file>

<file path="m365-mcp/tools/mail.ts">
// srv/m365-mcp/tools/mail.ts
// Tool handlers for Microsoft 365 mail interactions.

import { safeJson } from '../helpers/logging.js';
import type { GraphClient } from '../graph-client.js';

type LoggerLike = Console | { info?: (...args: unknown[]) => void; log?: (...args: unknown[]) => void } | undefined;

interface MailToolContext<TInput> {
  input: TInput;
  graphClient: GraphClient;
  logger?: LoggerLike;
}

interface LatestMessageInput {
  folderId?: string;
}

interface AttachmentDownloadInput {
  messageId: string;
  attachmentId: string;
  targetPath: string;
}

interface MessagesListInput extends LatestMessageInput {
  startDateTime?: string;
  endDateTime?: string;
  maxResults?: number;
}

interface MessageReplyInput {
  messageId: string;
  comment?: string;
  body?: string;
  contentType?: string;
  replyAll?: boolean;
}

function getInfoLogger(logger: LoggerLike): (...args: unknown[]) => void {
  if (!logger) return () => {};
  if (typeof logger.info === 'function') return logger.info.bind(logger);
  if (typeof logger.log === 'function') return logger.log.bind(logger);
  return () => {};
}

export async function handleMailLatestMessage({ input, graphClient, logger }: MailToolContext<LatestMessageInput>) {
  const info = getInfoLogger(logger);
  info('M365 mail.latestMessage.get invoked with input:', safeJson(input));
  const folderId = input.folderId || 'inbox';
  const message = await graphClient.getLatestMessage({ folderId });
  if (!message) {
    return {
      message: `No messages found in folder "${folderId}"`,
      folderId
    };
  }
  return {
    folderId,
    message
  };
}

export async function handleMailAttachmentDownload({ input, graphClient, logger }: MailToolContext<AttachmentDownloadInput>) {
  const info = getInfoLogger(logger);
  info('M365 mail.attachment.download invoked with input:', safeJson({
    ...input,
    targetPath: '[redacted]'
  }));

  const result = await graphClient.downloadAttachment({
    messageId: input.messageId,
    attachmentId: input.attachmentId,
    targetPath: input.targetPath
  });
  return {
    status: 'downloaded',
    details: result
  };
}

export async function handleMailMessagesList({ input, graphClient, logger }: MailToolContext<MessagesListInput>) {
  const info = getInfoLogger(logger);
  info('M365 mail.messages.list invoked with input:', safeJson(input));

  const messages = await graphClient.listMessages({
    folderId: input.folderId,
    startDateTime: input.startDateTime,
    endDateTime: input.endDateTime,
    maxResults: input.maxResults
  });

  return {
    folderId: input.folderId || 'inbox',
    count: messages.length,
    messages
  };
}

export async function handleMailMessageReply({ input, graphClient, logger }: MailToolContext<MessageReplyInput>) {
  const info = getInfoLogger(logger);
  const masked = {
    ...input,
    body: input.body ? '[redacted]' : undefined,
    comment: input.comment ? '[provided]' : undefined
  };
  info('M365 mail.message.reply invoked with input:', safeJson(masked));

  if (!input.messageId) {
    throw new Error('messageId is required');
  }

  const result = await graphClient.replyToMessage({
    messageId: input.messageId,
    comment: input.comment,
    body: input.body,
    contentType: input.contentType,
    replyAll: input.replyAll
  });

  return result;
}
</file>

<file path="mcp-cap/index.ts">
import cds from '@sap/cds';
import type { EventContext, Service, User } from '@sap/cds';
import { AsyncLocalStorage } from 'node:async_hooks';
import { createSdkMcpServer, tool } from '@anthropic-ai/claude-agent-sdk';
import { z } from 'zod';
import type { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import type { JsonSchema } from '../m365-mcp/mcp-jsonschema.js';

type AnyRecord = Record<string, any>;

type LoggerLike = Console | { debug?: (...args: unknown[]) => void; log?: (...args: unknown[]) => void };

interface CapInitOptions {
  service: Service;
  logger?: LoggerLike;
}

interface ResolveDraftOptions {
  allowVirtual?: string[];
}

interface ServiceEntity {
  name: string;
  elements?: Record<string, EntityElement>;
  drafts?: ServiceEntity;
}

interface EntityElement {
  type?: string;
  virtual?: boolean;
  _target?: ServiceEntity;
}

interface DraftKey {
  ID?: string | number;
  DraftAdministrativeData_DraftUUID?: string;
  IsActiveEntity?: boolean;
  [key: string]: unknown;
}

interface DraftCacheEntry {
  keys: DraftKey;
  data: AnyRecord;
  timestamp: number;
}

interface DraftStore extends Map<string, DraftCacheEntry> {
  lastKey?: string;
}

interface ContextOverrides {
  event?: string;
  user?: User;
  tenant?: string;
  locale?: string;
  data?: AnyRecord;
  query?: AnyRecord;
  headers?: Record<string, string>;
}

type ServiceRequest = InstanceType<typeof cds.Request>;

type RequestContextState = ContextOverrides & { request?: ServiceRequest };

const MAX_ROWS = 200;

const DEFAULT_DRAFT_DATA: AnyRecord = {
  ort: 'Luzern',
  datum: null
};

// Lightweight in-memory cache that remembers the most recent drafts per entity.
const draftContext = new Map<string, DraftStore>();
const requestContextStorage = new AsyncLocalStorage<RequestContextState>();

const DEFAULT_DRAFT_ADMIN_COLUMNS = [
  'DraftUUID',
  'CreatedByUser',
  'LastChangedByUser',
  'InProcessByUser',
  'CreatedAt',
  'LastChangedAt'
];

const formatError = (error: unknown): string => {
  if (error instanceof Error && typeof error.message === 'string') {
    return error.message;
  }
  try {
    return JSON.stringify(error);
  } catch {
    return String(error);
  }
};

function normalizePatchData(data: unknown): AnyRecord | null {
  if (data === null || data === undefined) {
    return null;
  }

  if (typeof data === 'string') {
    const trimmed = data.trim();
    if (!trimmed) {
      return null;
    }
    try {
      const parsed = JSON.parse(trimmed);
      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
        return parsed as AnyRecord;
      }
      throw new Error('Der Payload muss ein JSON-Objekt repräsentieren.');
    } catch (error) {
      const reason = error instanceof Error ? error.message : String(error);
      throw new Error(`Daten-Payload konnte nicht geparst werden: ${reason}`);
    }
  }

  if (typeof data === 'object' && !Array.isArray(data)) {
    return data as AnyRecord;
  }

  throw new Error('cap.draft.patch erwartet ein Objekt als data-Payload.');
}

const toolDefinitions: Array<{ name: string; description: string; inputSchema: JsonSchema; metadata?: AnyRecord }> = [
  {
    name: 'cap.sql.execute',
    description: 'Execute a SQL statement through the CAP database connection. Defaults to read-only unless allowWrite is true.',
    inputSchema: {
      type: 'object',
      properties: {
        sql: { type: 'string', description: 'Complete SQL statement to execute.' },
        params: {
          description: 'Optional positional or named parameters passed to the statement.',
          anyOf: [
            { type: 'array', items: {} },
            { type: 'object', additionalProperties: true }
          ]
        },
        allowWrite: {
          type: 'boolean',
          description: 'Set to true to allow INSERT/UPDATE/DELETE/DDL statements.',
          default: false
        }
      },
      required: ['sql'],
      additionalProperties: false
    }
  },
  {
    name: 'cap.cqn.read',
    description: 'Run a CAP SELECT query using CQN primitives and return the resulting rows.',
    inputSchema: {
      type: 'object',
      properties: {
        entity: { type: 'string', description: 'Entity name as exposed by the service (for example kfz.claims.Claims).' },
        columns: { type: 'array', items: { type: 'string' }, description: 'Optional list of columns to project.' },
        where: { type: 'object', additionalProperties: true, description: 'Optional WHERE clause expressed as CQN object literal.' },
        limit: { type: 'integer', minimum: 1, description: 'Maximum number of rows to return.' },
        offset: { type: 'integer', minimum: 0, description: 'Offset for pagination.' },
        draft: { type: 'string', enum: ['merged', 'active', 'draft'], default: 'merged', description: 'Choose between merged (default), active-only, or draft-only records.' }
      },
      required: ['entity'],
      additionalProperties: false
    }
  },
  {
    name: 'cap.draft.new',
    description: 'Create a new draft instance for a draft-enabled entity.',
    inputSchema: {
      type: 'object',
      properties: {
        entity: { type: 'string', description: 'Draft-enabled entity name.' },
        data: { type: 'object', additionalProperties: true, description: 'Optional initial payload (default: Ort=Luzern, Datum=null).' }
      },
      required: ['entity'],
      additionalProperties: true
    }
  },
  {
    name: 'cap.draft.edit',
    description: 'Put an active instance into draft edit mode.',
    inputSchema: {
      type: 'object',
      properties: {
        entity: { type: 'string', description: 'Draft-enabled entity name.' },
        keys: { type: 'object', additionalProperties: true, description: 'Primary key identifying the active record. Optional if ein offener Draft existiert.' },
        ID: { type: 'string', description: 'Convenience field: ID der aktiven Instanz, falls keys fehlt.' }
      },
      required: ['entity'],
      additionalProperties: false
    }
  },
  {
    name: 'cap.draft.patch',
    description: 'Apply partial updates to an existing draft instance.',
    inputSchema: {
      type: 'object',
      properties: {
        entity: { type: 'string', description: 'Draft-enabled entity name.' },
        keys: { type: 'object', additionalProperties: true, description: 'Optional: Primärschlüssel (ID + DraftUUID). Wird automatisch ergänzt, wenn ein einzelner offener Draft existiert.' },
        data: { type: 'object', additionalProperties: true, description: 'Optional: Felder zum Aktualisieren.' },
        ID: { type: 'string', description: 'Convenience field: Draft-ID, falls keys fehlt.' },
        DraftAdministrativeData_DraftUUID: { type: 'string', description: 'Convenience field: DraftUUID, falls keys fehlt.' }
      },
      required: ['entity'],
      additionalProperties: true
    }
  },
  {
    name: 'cap.draft.save',
    description: 'Activate a draft and persist it as the active instance.',
    inputSchema: {
      type: 'object',
      properties: {
        entity: { type: 'string', description: 'Draft-enabled entity name.' },
        keys: { type: 'object', additionalProperties: true, description: 'Optional: Primärschlüssel (ID + DraftUUID). Wird automatisch ergänzt.' },
        ID: { type: 'string', description: 'Convenience: Draft-ID falls keys fehlt.' },
        DraftAdministrativeData_DraftUUID: { type: 'string', description: 'Convenience: DraftUUID falls keys fehlt.' }
      },
      required: ['entity'],
      additionalProperties: true
    }
  },
  {
    name: 'cap.draft.cancel',
    description: 'Discard an existing draft instance.',
    inputSchema: {
      type: 'object',
      properties: {
        entity: { type: 'string', description: 'Draft-enabled entity name.' },
        keys: { type: 'object', additionalProperties: true, description: 'Optional: Primärschlüssel (ID + DraftUUID). Wird automatisch ergänzt.' },
        ID: { type: 'string', description: 'Convenience: Draft-ID falls keys fehlt.' },
        DraftAdministrativeData_DraftUUID: { type: 'string', description: 'Convenience: DraftUUID falls keys fehlt.' }
      },
      required: ['entity'],
      additionalProperties: true
    }
  },
  {
    name: 'cap.draft.getAdminData',
    description: 'Read DraftAdministrativeData metadata for a draft-enabled entity.',
    inputSchema: {
      type: 'object',
      properties: {
        entity: { type: 'string', description: 'Draft-enabled entity name.' },
        keys: { type: 'object', additionalProperties: true, description: 'Optional: Primärschlüssel (ID + DraftUUID). Wird automatisch ergänzt.' },
        ID: { type: 'string', description: 'Convenience: Draft-ID falls keys fehlt.' },
        DraftAdministrativeData_DraftUUID: { type: 'string', description: 'Convenience: DraftUUID falls keys fehlt.' },
        columns: { type: 'array', items: { type: 'string' }, description: 'Optional Liste der gewünschten DraftAdmin-Felder.' }
      },
      required: ['entity'],
      additionalProperties: true
    }
  },
  {
    name: 'cap.draft.addChild',
    description: 'Append entries to a composition element of a draft-enabled root entity.',
    inputSchema: {
      type: 'object',
      properties: {
        entity: { type: 'string', description: 'Draft-enabled root entity name.' },
        child: { type: 'string', description: 'Name des Composition-Elements (z. B. "teilnehmer").' },
        entries: {
          type: 'array',
          items: { type: 'object', additionalProperties: true },
          description: 'Liste der zu ergänzenden Kind-Einträge.'
        },
        entry: { type: 'object', additionalProperties: true, description: 'Alternative zu entries: einzelner Kind-Eintrag.' },
        keys: { type: 'object', additionalProperties: true, description: 'Optional: Primärschlüssel (ID + DraftUUID).' },
        ID: { type: 'string', description: 'Convenience: Draft-ID falls keys fehlt.' },
        DraftAdministrativeData_DraftUUID: { type: 'string', description: 'Convenience: DraftUUID falls keys fehlt.' }
      },
      required: ['entity', 'child'],
      additionalProperties: true
    }
  }
];

export async function initCapMCPClient(options: CapInitOptions) {
  const { service, logger = console } = options;
  if (!service) {
    throw new Error('CAP MCP client requires a service instance. Pass { service } when initializing.');
  }

  const log = typeof logger?.debug === 'function' ? logger : console;
  log.debug?.('Initializing CAP MCP in-process client...');

  const db = await cds.connect.to('db');
  const privilegedUser: User = cds.User?.Privileged
    ? new (cds.User.Privileged as unknown as new (...args: any[]) => User)('mcp-cap')
    : ({ id: 'mcp-cap', roles: ['mcp.cap'], attr: {} } as User);

  function resolveEntity(entityName: string): ServiceEntity {
    if (!entityName) {
      throw new Error('Entity name must be a non-empty string');
    }
    const entities = (service.entities ?? {}) as Record<string, ServiceEntity>;
    const direct = entities[entityName];
    if (direct) {
      return direct;
    }
    const shortName = entityName.includes('.') ? entityName.split('.').pop() : undefined;
    if (shortName && entities[shortName]) {
      return entities[shortName];
    }
    const available = Object.keys(entities).join(', ') || '<none>';
    throw new Error(`Unknown entity "${entityName}". Available entities: ${available}`);
  }

  function getDraftStore(entityName: string): DraftStore {
    const key = entityName;
    if (!draftContext.has(key)) {
      draftContext.set(key, new Map() as DraftStore);
    }
    return draftContext.get(key)!;
  }

  function rememberDraft(entityRef: ServiceEntity, draftInstance: AnyRecord) {
    const draftUUID = draftInstance?.DraftAdministrativeData_DraftUUID || draftInstance?.draftAdministrativeData_DraftUUID;
    const id = draftInstance?.ID;
    if (!draftUUID || id === undefined || id === null) return;
    const store = getDraftStore(entityRef.name);
    const key = String(id);
    const keys: DraftKey = { ID: id, DraftAdministrativeData_DraftUUID: draftUUID, IsActiveEntity: false };
    store.set(key, { keys, data: draftInstance, timestamp: Date.now() });
    store.lastKey = key;
  }

  function forgetDraft(entityRef: ServiceEntity, keys: AnyRecord) {
    const store = getDraftStore(entityRef.name);
    const id = keys?.ID;
    const key = id === undefined || id === null ? undefined : String(id);
    if (key && store.has(key)) {
      store.delete(key);
    }
    if (store.lastKey === key) {
      store.lastKey = undefined;
    }
    if (store.size === 0) {
      draftContext.delete(entityRef.name);
    }
  }

  function hasProvidedDraftKeys(input: AnyRecord = {}) {
    if (!input || typeof input !== 'object') return false;
    if (input.keys && Object.keys(input.keys).length) return true;
    if (input.ID) return true;
    if (input.DraftAdministrativeData_DraftUUID) return true;
    return false;
  }

  function isMissingDraftError(error: unknown) {
    return (error as { message?: string })?.message?.includes('Kein passender Draft gefunden');
  }

  function resolveDraftKeys(entityRef: ServiceEntity, draftEntity: ServiceEntity, providedKeys: AnyRecord = {}, options: AnyRecord = {}) {
    const store = getDraftStore(entityRef.name);

    if (providedKeys && Object.keys(providedKeys).length) {
      const keys = { ...providedKeys };
      if (keys.DraftAdministrativeData_DraftUUID) {
        if (keys.IsActiveEntity === undefined) {
          keys.IsActiveEntity = false;
        }
        return keys;
      }
      if (keys.ID) {
        const cached = store.get(String(keys.ID));
        if (cached) {
          return { ...cached.keys, ...keys };
        }
        if (keys.IsActiveEntity !== undefined) {
          const { IsActiveEntity, ...rest } = keys;
          return { ID: keys.ID, ...rest, IsActiveEntity: Boolean(IsActiveEntity) };
        }
        return { ID: keys.ID, IsActiveEntity: false };
      } else if (keys.DraftAdministrativeData_DraftUUID) {
        for (const entry of store.values()) {
          if (entry.keys.DraftAdministrativeData_DraftUUID === keys.DraftAdministrativeData_DraftUUID) {
            return { ...entry.keys, ...keys, IsActiveEntity: false };
          }
        }
      }
      if (keys.IsActiveEntity !== undefined) {
        const { IsActiveEntity, ...rest } = keys;
        return { ...rest, IsActiveEntity: Boolean(IsActiveEntity) };
      }
    }

    const { ID, DraftAdministrativeData_DraftUUID, IsActiveEntity } = options;
    if (ID && DraftAdministrativeData_DraftUUID) {
      return {
        ID,
        DraftAdministrativeData_DraftUUID,
        IsActiveEntity: IsActiveEntity === undefined ? false : Boolean(IsActiveEntity)
      };
    }

    if (ID) {
      const cached = store.get(String(ID));
      if (cached) {
        return cached.keys;
      }
      return { ID, IsActiveEntity: false };
    }

    if (store.lastKey) {
      const cached = store.get(store.lastKey);
      if (cached) return cached.keys;
    }

    throw new Error(`Kein passender Draft gefunden. Bitte zuerst 'cap.draft.new' ausführen oder Keys (ID + DraftUUID) angeben.`);
  }

  function extractKeysAndData(entityRef: any, draftEntity: any, input: AnyRecord = {}) {
    const { keys: rawKeys, data: rawData, ...rest } = input;
    if (rest.entity !== undefined) delete rest.entity;
    const recognizedKeys = rawKeys ? { ...rawKeys } : {};
    const convenienceKeys: AnyRecord = {};

    if (rest.ID !== undefined) {
      convenienceKeys.ID = rest.ID;
      delete rest.ID;
    }
    if (rest.DraftAdministrativeData_DraftUUID !== undefined) {
      convenienceKeys.DraftAdministrativeData_DraftUUID = rest.DraftAdministrativeData_DraftUUID;
      delete rest.DraftAdministrativeData_DraftUUID;
    }

    const keys = Object.keys(recognizedKeys).length
      ? recognizedKeys
      : convenienceKeys;

    let data: any;
    if (rawData !== undefined) {
      data = rawData; // may be object or JSON string; normalize later
    } else {
      data = Object.keys(rest).length ? rest : null;
    }

    const resolvedKeys = resolveDraftKeys(entityRef, draftEntity, keys, convenienceKeys);

    return { keys: resolvedKeys, data };
  }

  function ensureDraftEntity(entity: any, originalName?: string) {
    if (!entity?.drafts) {
      const name = originalName || entity?.name || '<unknown>';
      throw new Error(`Entity "${name}" is not draft-enabled.`);
    }
    return entity.drafts;
  }

  async function withServiceContext<T>(fn: (req: ServiceRequest) => Promise<T> | T, overrides: ContextOverrides = {}): Promise<T> {
    const previous = cds.context as EventContext | undefined;
    const ambient = requestContextStorage.getStore() ?? {};
    const effectiveUser = overrides.user ?? ambient.user ?? previous?.user ?? privilegedUser;
    const effectiveTenant = overrides.tenant ?? ambient.tenant ?? previous?.tenant ?? (effectiveUser as User & { tenant?: string })?.tenant;
    const effectiveLocale = overrides.locale ?? ambient.locale ?? previous?.locale;

    const request = new cds.Request();
    Object.assign(request, {
      event: overrides.event ?? 'READ',
      user: effectiveUser,
      tenant: effectiveTenant,
      locale: effectiveLocale
    });

    try {
      cds.context = request;
      return await fn(request);
    } finally {
      cds.context = previous;
    }
  }

  function sanitizeDraftKeys(
    entity: any,
    keyValues: AnyRecord = {},
    options: ResolveDraftOptions & { dropKeys?: string[] } = {}
  ) {
    if (!keyValues || typeof keyValues !== 'object') {
      return {};
    }
    const { allowVirtual = [], dropKeys = [] } = options;
    const elements = entity?.elements || {};

    // Keep only primary-key elements plus explicitly allowed virtuals
    const primaryKeys = new Set<string>();
    for (const [name, element] of Object.entries(elements)) {
      // CAP marks key columns with element.key === true on projections/drafts
      if ((element as any)?.key === true) primaryKeys.add(name);
    }

    const cleaned: AnyRecord = {};
    for (const [key, value] of Object.entries(keyValues)) {
      if (dropKeys.includes(key)) continue;
      const element = (elements as any)[key];
      const isVirtual = Boolean(element?.virtual);
      const isAllowedVirtual = allowVirtual.includes(key);
      const isPrimaryKey = primaryKeys.has(key);
      if (!isPrimaryKey && !(isVirtual && isAllowedVirtual)) continue;
      if (value === undefined) continue;
      cleaned[key] = value;
    }
    return cleaned;
  }

  async function autoResolveDraftKeys(entityRef: any, draftEntity: any): Promise<AnyRecord | null> {
    const columns: AnyRecord[] = [];

    if (draftEntity.elements?.ID) {
      columns.push({ ref: ['ID'] });
    }
    if (draftEntity.elements?.DraftAdministrativeData_DraftUUID) {
      columns.push({ ref: ['DraftAdministrativeData_DraftUUID'] });
    }

    if (!columns.length) {
      return null;
    }

    const query = cds.ql.SELECT.one.from(draftEntity).columns(...columns);

    const orderCandidates = [
      ['modifiedAt', 'desc'],
      ['LastChangedAt', 'desc'],
      ['createdAt', 'desc'],
      ['CreationDateTime', 'desc']
    ];

    for (const [field, sort] of orderCandidates) {
      if (draftEntity.elements?.[field]) {
        // Use string form "field desc" to avoid interpreting 'desc' as a column name
        query.orderBy(`${field} ${sort}`);
        break;
      }
    }

    const latest = await withServiceContext(async () => service.run(query));
    if (!latest) {
      return null;
    }

    const autoKeys: DraftKey = {};
    if (latest.ID !== undefined) {
      autoKeys.ID = latest.ID;
    }
    if (latest.DraftAdministrativeData_DraftUUID !== undefined) {
      autoKeys.DraftAdministrativeData_DraftUUID = latest.DraftAdministrativeData_DraftUUID;
    }

    if (!Object.keys(autoKeys).length) {
      return null;
    }

    autoKeys.IsActiveEntity = false;

    rememberDraft(entityRef, {
      ID: autoKeys.ID,
      DraftAdministrativeData_DraftUUID: autoKeys.DraftAdministrativeData_DraftUUID
    });

    return autoKeys;
  }

  function toResultPayload(result: any, metadata: AnyRecord = {}) {
    if (Array.isArray(result)) {
      return { rows: result, rowCount: result.length, metadata };
    }
    if (result === undefined || result === null) {
      return { rows: [], rowCount: 0, metadata };
    }
    if (typeof result === 'number') {
      return { rows: [], rowCount: result, metadata };
    }
    return { result, metadata };
  }

  async function handleSqlExecute(input: AnyRecord = {}) {
    const { sql, params, allowWrite = false } = input;
    if (typeof sql !== 'string' || !sql.trim()) {
      throw new Error('The "sql" property must be a non-empty string.');
    }
    const trimmed = sql.trim();
    const firstWordMatch = trimmed.match(/^([A-Za-z]+)/);
    const firstWord = firstWordMatch ? firstWordMatch[1].toUpperCase() : '';
    const readOnlyCommands = new Set(['SELECT', 'WITH', 'SHOW', 'EXPLAIN']);
    const isReadOnly = readOnlyCommands.has(firstWord);
    if (!allowWrite && !isReadOnly) {
      throw new Error('Write operations are disabled. Set allowWrite=true to enable this statement.');
    }
    const statement = cds.raw(trimmed);
    const result = await db.run(statement, params);
    return toResultPayload(result, { command: firstWord || 'RAW' });
  }

  async function handleCqnRead(input: AnyRecord = {}) {
    const { entity, columns, where, limit, offset, draft = 'merged' } = input;
    const entityRef = resolveEntity(entity);
    const { SELECT } = cds.ql;

    const target = draft === 'draft' ? ensureDraftEntity(entityRef, entity) : entityRef;
    const query = SELECT.from(target);

    if (Array.isArray(columns) && columns.length > 0) {
      query.columns(...columns);
    }

    if (where && typeof where === 'object' && Object.keys(where).length) {
      query.where(where);
    }

    if (draft === 'active') {
      query.where({ IsActiveEntity: true });
    } else if (draft === 'draft' && target === entityRef) {
      query.where({ IsActiveEntity: false });
    }

    if (Number.isInteger(offset) && offset >= 0 && Number.isInteger(limit) && limit > 0) {
      query.limit(limit, offset);
    } else if (Number.isInteger(limit) && limit > 0) {
      query.limit(limit);
    } else if (!query.SELECT.limit) {
      query.limit(MAX_ROWS);
    }

    const result = await withServiceContext(async () => service.run(query));
    return toResultPayload(result, { entity: entityRef.name, draft });
  }

  async function handleDraftNew(input: AnyRecord = {}) {
    const { entity } = input;
    const entityRef = resolveEntity(entity);
    const draftEntity = ensureDraftEntity(entityRef, entity);
    // Apply domain defaults only for elements that actually exist
    const basePayload: AnyRecord = {};
    if (draftEntity?.elements) {
      for (const [k, v] of Object.entries(DEFAULT_DRAFT_DATA)) {
        if (k in draftEntity.elements) basePayload[k] = v;
      }
    }
    const rawData: AnyRecord = input.data && typeof input.data === 'object' ? { ...input.data } : {};
    const extraFields: AnyRecord = { ...input };
    delete extraFields.entity;
    delete extraFields.data;
    const payload = { ...basePayload, ...extraFields, ...rawData };
    const result = await withServiceContext(async () => (service as any).new(draftEntity, payload), { event: 'NEW' });

    const instance = Array.isArray(result) ? result[0] : result;
    rememberDraft(entityRef, instance);

    return toResultPayload(result, { entity: entityRef.name, action: 'NEW' });
  }

  async function handleDraftEdit(input: AnyRecord = {}) {
    const { entity } = input;
    const entityRef = resolveEntity(entity);
    const draftEntity = ensureDraftEntity(entityRef, entity);

    let keys = input.keys;
    if (!keys || !Object.keys(keys).length) {
      const id = input.ID;
      if (!id) {
        throw new Error('Bitte die ID der aktiven Instanz angeben, um einen Draft zu erzeugen.');
      }
      keys = { ID: id };
    }

    const result = await withServiceContext(async () => (service as any).edit(entityRef, keys), { event: 'EDIT' });
    const instance = Array.isArray(result) ? result[0] : result;
    rememberDraft(entityRef, instance);

    // Ensure DraftUUID is cached even if not present on the edit result payload
    try {
      const id = instance?.ID ?? (Array.isArray(result) ? result?.[0]?.ID : undefined);
      const hasUUID = Boolean(
        instance?.DraftAdministrativeData_DraftUUID || instance?.draftAdministrativeData_DraftUUID
      );
      if (id !== undefined && id !== null && !hasUUID) {
        const query = cds.ql.SELECT.one
          .from(draftEntity)
          .columns({ ref: ['ID'] }, { ref: ['DraftAdministrativeData_DraftUUID'] })
          .where({ ID: id, IsActiveEntity: false });
        const meta = await withServiceContext(async () => service.run(query));
        if (meta?.DraftAdministrativeData_DraftUUID) {
          console.log('[cap.draft.edit] fetched DraftUUID for cache', {
            ID: id,
            DraftAdministrativeData_DraftUUID: meta.DraftAdministrativeData_DraftUUID
          });
          rememberDraft(entityRef, {
            ID: id,
            DraftAdministrativeData_DraftUUID: meta.DraftAdministrativeData_DraftUUID
          });
        }
      }
    } catch (e) {
      console.log('[cap.draft.edit] failed to fetch DraftUUID for cache', formatError(e));
    }
    return toResultPayload(result, { entity: entityRef.name, action: 'EDIT' });
  }

  async function handleDraftPatch(input: AnyRecord = {}) {
    const { entity } = input;
    const entityRef = resolveEntity(entity);
    const draftEntity = ensureDraftEntity(entityRef, entity);

    const { keys, data } = extractKeysAndData(entityRef, draftEntity, input);

    let mutationKeys = sanitizeDraftKeys(draftEntity, keys, { allowVirtual: ['IsActiveEntity', 'DraftAdministrativeData_DraftUUID'] });

    const normalizedData = normalizePatchData(data);

    // Fallback: auto-resolve DraftUUID if missing
    if (mutationKeys.DraftAdministrativeData_DraftUUID === undefined) {
      try {
        const autoKeys = await autoResolveDraftKeys(entityRef, draftEntity);
        if (autoKeys?.DraftAdministrativeData_DraftUUID) {
          // Prefer provided ID if present, but fill missing fields from autoKeys
          mutationKeys = {
            ...autoKeys,
            ...mutationKeys,
            IsActiveEntity: false
          };
          console.log('[cap.draft.patch] autoResolved mutation keys', mutationKeys);
        }
      } catch (e) {
        // keep going; UPDATE may still succeed if single draft by ID exists
        console.log('[cap.draft.patch] autoResolveDraftKeys failed', formatError(e));
      }
    }

    console.log('[cap.draft.patch] mutationKeys', mutationKeys);
    console.log('[cap.draft.patch] normalizedData', normalizedData);

    if (!normalizedData || !Object.keys(normalizedData).length) {
      throw new Error('Es wurden keine Felder zum Aktualisieren übergeben.');
    }

    const payload = { ...normalizedData };
    if (mutationKeys.DraftAdministrativeData_DraftUUID !== undefined && payload.DraftAdministrativeData_DraftUUID === undefined) {
      payload.DraftAdministrativeData_DraftUUID = mutationKeys.DraftAdministrativeData_DraftUUID;
    }
    if (mutationKeys.IsActiveEntity !== undefined && payload.IsActiveEntity === undefined) {
      payload.IsActiveEntity = mutationKeys.IsActiveEntity;
    }
    if (mutationKeys.ID !== undefined && payload.ID === undefined) {
      payload.ID = mutationKeys.ID;
    }

    let affected;
    try {
      affected = await withServiceContext(
        async () => (service as any).update(draftEntity).set(payload).where(mutationKeys),
        { event: 'UPDATE' }
      );
    } catch (error) {
      console.log('[cap.draft.patch] update failed', {
        error: formatError(error),
        payload,
        mutationKeys
      });
      throw error;
    }

    if (!affected) {
      throw new Error('Kein Draft wurde aktualisiert. Bitte prüfe die ID oder erstelle einen neuen Draft.');
    }

    const { ID } = keys;
    if (ID) {
      const store = getDraftStore(entityRef.name);
      const cached = store.get(ID);
      if (cached) {
        cached.data = { ...cached.data, ...normalizedData };
        cached.timestamp = Date.now();
      }
    }

    // Some CAP service implementations return a number (affected rows),
    // others return the updated instance or an array. Normalize to a count.
    const changed = typeof affected === 'number'
      ? affected
      : Array.isArray(affected)
        ? affected.length
        : 1; // truthy non-number => assume one row affected

    return toResultPayload(changed, { entity: entityRef.name, action: 'PATCH' });
  }

  async function handleDraftSave(input: AnyRecord = {}) {
    const { entity } = input;
    const entityRef = resolveEntity(entity);
    const draftEntity = ensureDraftEntity(entityRef, entity);

    const { keys } = extractKeysAndData(entityRef, draftEntity, input);
    let mutationKeys = sanitizeDraftKeys(draftEntity, keys, { allowVirtual: ['IsActiveEntity', 'DraftAdministrativeData_DraftUUID'] });

    // Fallback: ensure DraftUUID present for save
    if (mutationKeys.DraftAdministrativeData_DraftUUID === undefined) {
      try {
        const autoKeys = await autoResolveDraftKeys(entityRef, draftEntity);
        if (autoKeys?.DraftAdministrativeData_DraftUUID) {
          mutationKeys = {
            ...autoKeys,
            ...mutationKeys,
            IsActiveEntity: false
          };
          console.log('[cap.draft.save] autoResolved mutation keys', mutationKeys);
        }
      } catch (e) {
        console.log('[cap.draft.save] autoResolveDraftKeys failed', formatError(e));
      }
    }

    const result = await withServiceContext(async () => (service as any).save(draftEntity, mutationKeys), { event: 'SAVE' });
    forgetDraft(entityRef, mutationKeys);
    return toResultPayload(result, { entity: entityRef.name, action: 'SAVE' });
  }

  async function handleDraftCancel(input: AnyRecord = {}) {
    const { entity } = input;
    const entityRef = resolveEntity(entity);
    const draftEntity = ensureDraftEntity(entityRef, entity);

    const { keys } = extractKeysAndData(entityRef, draftEntity, input);
    const mutationKeys = sanitizeDraftKeys(draftEntity, keys, { dropKeys: ['IsActiveEntity'] });

    const result = await withServiceContext(async () => (service as any).discard(draftEntity, mutationKeys), { event: 'CANCEL' });
    forgetDraft(entityRef, mutationKeys);
    return toResultPayload(result, { entity: entityRef.name, action: 'CANCEL' });
  }

  async function handleDraftGetAdminData(input: AnyRecord = {}) {
    const { entity, columns } = input;
    const entityRef = resolveEntity(entity);
    const draftEntity = ensureDraftEntity(entityRef, entity);

    let keys;
    try {
      ({ keys } = extractKeysAndData(entityRef, draftEntity, input));
    } catch (error) {
      if (!hasProvidedDraftKeys(input) && isMissingDraftError(error)) {
        const autoKeys = await autoResolveDraftKeys(entityRef, draftEntity);
        if (!autoKeys) {
          throw error;
        }
        keys = autoKeys;
      } else {
        throw error;
      }
    }

    const queryKeys = sanitizeDraftKeys(draftEntity, keys, { dropKeys: ['IsActiveEntity', 'HasActiveEntity', 'HasDraftEntity'] });

    const draftAdminAssoc = draftEntity?.elements?.DraftAdministrativeData;
    const adminTargetElements = draftAdminAssoc?._target?.elements || null;
    let availableColumns = adminTargetElements
      ? Object.keys(adminTargetElements)
      : [...DEFAULT_DRAFT_ADMIN_COLUMNS];

    if (!availableColumns.length) {
      availableColumns = [...DEFAULT_DRAFT_ADMIN_COLUMNS];
    }

    let requestedColumns = Array.isArray(columns) && columns.length ? [...columns] : null;
    if (requestedColumns && adminTargetElements) {
      const normalized = requestedColumns.filter((col) => adminTargetElements[col]);
      if (normalized.length) {
        requestedColumns = normalized;
      } else {
        requestedColumns = null;
      }
    }

    const expandColumns = requestedColumns || availableColumns;
    const expand = !expandColumns.length || expandColumns.includes('*')
      ? [{ ref: ['*'] }]
      : expandColumns.map((col) => ({ ref: [col] }));

    const selectColumns: AnyRecord[] = [
      { ref: ['DraftAdministrativeData'], expand }
    ];

    if (draftEntity.elements?.DraftAdministrativeData_DraftUUID) {
      selectColumns.push({ ref: ['DraftAdministrativeData_DraftUUID'] });
    }

    const query = cds.ql.SELECT.one.from(draftEntity)
      .columns(...selectColumns)
      .where(queryKeys);

    const result = await withServiceContext(async () => service.run(query));
    if (!result) {
      return toResultPayload(null, { entity: entityRef.name, action: 'DRAFT_ADMIN' });
    }

    const adminData = result.DraftAdministrativeData ? { ...result.DraftAdministrativeData } : {};
    if (result.DraftAdministrativeData_DraftUUID !== undefined) {
      adminData.DraftAdministrativeData_DraftUUID = result.DraftAdministrativeData_DraftUUID;
    }

    if (requestedColumns && requestedColumns.length) {
      const filtered = requestedColumns.reduce((acc, col) => {
        if (adminData[col] !== undefined) {
          acc[col] = adminData[col];
        }
        return acc;
      }, {});
      return toResultPayload(filtered, { entity: entityRef.name, action: 'DRAFT_ADMIN' });
    }

    return toResultPayload(adminData, { entity: entityRef.name, action: 'DRAFT_ADMIN' });
  }

  async function handleDraftAddChild(input: AnyRecord = {}) {
    const { entity, child } = input;
    if (!entity || typeof entity !== 'string') {
      throw new Error('Bitte das Draft-Root "entity" angeben.');
    }
    if (!child || typeof child !== 'string') {
      throw new Error('Bitte den Namen des Composition-Elements in "child" angeben.');
    }

    const entriesInput = Array.isArray(input.entries)
      ? input.entries
      : input.entry !== undefined
        ? [input.entry]
        : null;

    if (!entriesInput || !entriesInput.length) {
      throw new Error('Bitte mindestens einen Kind-Eintrag in "entries" oder "entry" übergeben.');
    }

    const entityRef = resolveEntity(entity);
    const draftEntity = ensureDraftEntity(entityRef, entity);

    const childElement = draftEntity.elements?.[child] || entityRef.elements?.[child];
    if (!childElement) {
      throw new Error(`Das Element "${child}" existiert auf "${entityRef.name}" nicht.`);
    }
    if (childElement.type !== 'cds.Composition') {
      throw new Error(`Element "${child}" ist keine Composition und kann nicht mit cap.draft.addChild befüllt werden.`);
    }

    const childTarget = childElement._target;
    if (!childTarget) {
      throw new Error(`Composition "${child}" besitzt kein aufgelöstes Ziel.`);
    }

    const providedKeys: DraftKey = input.keys ? { ...input.keys } : {};
    const convenienceKeys: DraftKey = {};
    if (input.ID) convenienceKeys.ID = input.ID;
    if (input.DraftAdministrativeData_DraftUUID) {
      convenienceKeys.DraftAdministrativeData_DraftUUID = input.DraftAdministrativeData_DraftUUID;
    }

    let resolvedKeys;
    try {
      resolvedKeys = resolveDraftKeys(entityRef, draftEntity, providedKeys, convenienceKeys);
    } catch (error) {
      if (!hasProvidedDraftKeys(input) && isMissingDraftError(error)) {
        const autoKeys = await autoResolveDraftKeys(entityRef, draftEntity);
        if (!autoKeys) {
          throw error;
        }
        resolvedKeys = autoKeys;
      } else {
        throw error;
      }
    }

    const mutationKeys = sanitizeDraftKeys(draftEntity, resolvedKeys, {
      allowVirtual: ['IsActiveEntity', 'DraftAdministrativeData_DraftUUID']
    });

    const childColumns = Object.keys(childTarget.elements || {}).map((col) => ({ ref: [col] }));
    const expand = childColumns.length ? childColumns : [{ ref: ['*'] }];
    const selectColumns = [{ ref: [child], expand }];

    const existing = await withServiceContext(
      async () => service.run(
        cds.ql.SELECT.one.from(draftEntity)
          .columns(...selectColumns)
          .where(mutationKeys)
      )
    );

    const currentEntriesRaw = Array.isArray(existing?.[child]) ? existing[child] : [];
    const currentEntries = JSON.parse(JSON.stringify(currentEntriesRaw));

    const preparedEntries = entriesInput.map((entry, index) => {
      if (!entry || typeof entry !== 'object') {
        throw new Error(`Der Eintrag an Position ${index} ist kein Objekt.`);
      }
      const normalized = { ...entry };

      if (normalized.ID === undefined && childTarget.elements?.ID?.type === 'cds.UUID') {
        const utils = cds.utils as any;
        normalized.ID = utils?.uuid ? utils.uuid() : utils.guid();
      }
      if (childTarget.elements?.IsActiveEntity && normalized.IsActiveEntity === undefined) {
        normalized.IsActiveEntity = false;
      }
      if (childTarget.elements?.HasActiveEntity && normalized.HasActiveEntity === undefined) {
        normalized.HasActiveEntity = false;
      }
      if (childTarget.elements?.HasDraftEntity && normalized.HasDraftEntity === undefined) {
        normalized.HasDraftEntity = false;
      }
      if (
        mutationKeys.DraftAdministrativeData_DraftUUID !== undefined &&
        childTarget.elements?.DraftAdministrativeData_DraftUUID &&
        normalized.DraftAdministrativeData_DraftUUID === undefined
      ) {
        normalized.DraftAdministrativeData_DraftUUID = mutationKeys.DraftAdministrativeData_DraftUUID;
      }

      return normalized;
    });

    const payload = {
      [child]: currentEntries.concat(preparedEntries)
    };

    if (mutationKeys.ID !== undefined) {
      payload.ID = mutationKeys.ID;
    }
    if (mutationKeys.IsActiveEntity !== undefined) {
      payload.IsActiveEntity = mutationKeys.IsActiveEntity;
    }
    if (mutationKeys.DraftAdministrativeData_DraftUUID !== undefined) {
      payload.DraftAdministrativeData_DraftUUID = mutationKeys.DraftAdministrativeData_DraftUUID;
    }

    const result = await withServiceContext(
      async () => (service as any).update(draftEntity).set(payload).where(mutationKeys),
      { event: 'UPDATE' }
    );

    if (mutationKeys.ID !== undefined) {
      const store = getDraftStore(entityRef.name);
      const cached = store.get(mutationKeys.ID);
      if (cached) {
        cached.data = {
          ...cached.data,
          [child]: payload[child]
        };
        cached.timestamp = Date.now();
      }
    }

    return toResultPayload(result, { entity: entityRef.name, action: 'ADD_CHILD', child });
  }

  const handlers: Record<string, (input: AnyRecord) => Promise<any> | any> = {
    'cap.sql.execute': handleSqlExecute,
    'cap.cqn.read': handleCqnRead,
    'cap.draft.new': handleDraftNew,
    'cap.draft.edit': handleDraftEdit,
    'cap.draft.patch': handleDraftPatch,
    'cap.draft.save': handleDraftSave,
    'cap.draft.cancel': handleDraftCancel,
    'cap.draft.getAdminData': handleDraftGetAdminData,
    'cap.draft.addChild': handleDraftAddChild
  };

  const invokeHandler = async (toolName: string, input: AnyRecord): Promise<CallToolResult> => {
    const handler = handlers[toolName];
    if (!handler) {
      throw new Error(`Unknown CAP MCP tool "${toolName}".`);
    }
    const result = await handler(input);
    return toCallToolResult(result);
  };

  const recordAny = z.record(z.any());
  const optionalRecordAny = recordAny.optional();
  const optionalArrayOfRecords = z.array(recordAny).optional();

  const sdkServer = createSdkMcpServer({
    name: 'cap',
    version: '1.0.0',
    tools: [
      tool(
        'cap.sql.execute',
        'Execute a SQL statement through the CAP database connection. Defaults to read-only unless allowWrite is true.',
        {
          sql: z.string(),
          params: z.union([z.array(z.any()), recordAny]).optional(),
          allowWrite: z.boolean().optional()
        },
        async (args) => invokeHandler('cap.sql.execute', args)
      ),
      tool(
        'cap.cqn.read',
        'Run a CAP SELECT query using CQN primitives and return the resulting rows.',
        {
          entity: z.string(),
          columns: z.array(z.string()).optional(),
          where: optionalRecordAny,
          limit: z.number().int().min(1).optional(),
          offset: z.number().int().min(0).optional(),
          draft: z.enum(['merged', 'active', 'draft']).optional()
        },
        async (args) => invokeHandler('cap.cqn.read', args)
      ),
      tool(
        'cap.draft.new',
        'Create a new draft instance for a draft-enabled entity.',
        {
          entity: z.string(),
          data: optionalRecordAny
        },
        async (args) => invokeHandler('cap.draft.new', args)
      ),
      tool(
        'cap.draft.edit',
        'Put an active instance into draft edit mode.',
        {
          entity: z.string(),
          keys: optionalRecordAny,
          ID: z.string().optional()
        },
        async (args) => invokeHandler('cap.draft.edit', args)
      ),
      tool(
        'cap.draft.patch',
        'Apply partial updates to an existing draft instance.',
        {
          entity: z.string(),
          keys: optionalRecordAny,
          // Accept data as object or JSON string so our handler can normalize
          data: z.union([recordAny, z.string()]).optional(),
          // Convenience fields
          ID: z.string().optional(),
          DraftAdministrativeData_DraftUUID: z.string().optional(),
          // Allow common top-level patch fields (preserved through validation)
          status: z.string().optional()
        },
        async (args) => invokeHandler('cap.draft.patch', args)
      ),
      tool(
        'cap.draft.save',
        'Activate a draft and persist it as the active instance.',
        {
          entity: z.string(),
          keys: optionalRecordAny,
          ID: z.string().optional(),
          DraftAdministrativeData_DraftUUID: z.string().optional()
        },
        async (args) => invokeHandler('cap.draft.save', args)
      ),
      tool(
        'cap.draft.cancel',
        'Discard an existing draft instance.',
        {
          entity: z.string(),
          keys: optionalRecordAny,
          ID: z.string().optional(),
          DraftAdministrativeData_DraftUUID: z.string().optional()
        },
        async (args) => invokeHandler('cap.draft.cancel', args)
      ),
      tool(
        'cap.draft.getAdminData',
        'Read DraftAdministrativeData metadata for a draft-enabled entity.',
        {
          entity: z.string(),
          keys: optionalRecordAny,
          columns: z.array(z.string()).optional()
        },
        async (args) => invokeHandler('cap.draft.getAdminData', args)
      ),
      tool(
        'cap.draft.addChild',
        'Append entries to a draft composition element.',
        {
          entity: z.string(),
          child: z.string(),
          entries: optionalArrayOfRecords,
          entry: recordAny.optional(),
          keys: optionalRecordAny,
          ID: z.string().optional(),
          DraftAdministrativeData_DraftUUID: z.string().optional()
        },
        async (args) => invokeHandler('cap.draft.addChild', args)
      )
    ]
  });

  async function listTools() {
    return { tools: toolDefinitions };
  }

  const toCallToolResult = (result: unknown): CallToolResult => {
    const text = typeof result === 'string' ? result : JSON.stringify(result, null, 2);
    return {
      content: [{ type: 'text', text }],
      isError: false
    };
  };

  async function callTool(
    { name, arguments: args = {} }: { name?: string; arguments?: AnyRecord } = {},
    options: AnyRecord = {}
  ) {
    if (!name) {
      throw new Error('Tool name is required');
    }
    const handler = handlers[name];
    if (!handler) {
      const supported = Object.keys(handlers).join(', ') || '<none>';
      throw new Error(`Unknown CAP MCP tool "${name}". Supported tools: ${supported}`);
    }
    const input = args && typeof args === 'object' ? args : {};

    const invoke = async () => handler(input);

    if (requestContextStorage.getStore()) {
      const result = await invoke();
      return toCallToolResult(result);
    }

    const context = options.context || {};
    const result = await requestContextStorage.run(context, invoke);
    return toCallToolResult(result);
  }

  async function readResource() {
    throw new Error('CAP MCP client does not expose file resources');
  }

  async function close() {
    log.debug?.('Closing CAP MCP in-process client');
  }

  function runWithContext(context: AnyRecord, fn: (...args: unknown[]) => unknown) {
    if (typeof fn !== 'function') {
      throw new Error('runWithContext expects a callback function');
    }
    return requestContextStorage.run(context || {}, fn);
  }

  return {
    listTools,
    callTool,
    readResource,
    close,
    toolDefinitions,
    runWithContext,
    sdkServer
  };
}
</file>

<file path="service.cds">
using { kfz.claims as ClaimsModel } from '../db/schema';
using from '../app/annotations';

service ClaimsService @(path: '/service/claims', impl: 'gen/srv/service.js') {

    @odata.draft.enabled
    entity Claims as projection on ClaimsModel.Claims {
        *,
        documents : redirected to ClaimDocuments
    };

    entity ClaimDocuments as projection on ClaimsModel.ClaimDocuments {
        *,
        claim : redirected to Claims
    };

    entity ClaimStatusTexts as projection on ClaimsModel.ClaimStatusTexts;

    action callLLM (prompt: String) returns { response: String };
    action callClaudeAgent (prompt: String) returns { response: String };
}
</file>

<file path="service.ts">
// srv/ClaimsService.ts

import cds from '@sap/cds';
import express from 'express';
import type { Request, Response } from 'express';
import { loadMcpTools } from '@langchain/mcp-adapters';
import { createReactAgent } from "@langchain/langgraph/prebuilt";
import { AzureOpenAiChatClient } from "@sap-ai-sdk/langchain";
import { MemorySaver } from "@langchain/langgraph-checkpoint";
import { DynamicStructuredTool } from "@langchain/core/tools";
import type { StructuredToolInterface } from "@langchain/core/tools";
import * as z from "zod";
import path from 'node:path';
import { existsSync } from 'node:fs';
import { mkdir, readFile } from 'node:fs/promises';
import { initAllMCPClients, closeMCPClients } from './lib/mcp-client.js';
import { runClaudeAgent } from './lib/claude-agent.js';
import { jsonSchemaToZod } from './m365-mcp/mcp-jsonschema.js';
import { GraphClient } from './m365-mcp/graph-client.js';
import MarkdownConverter from './utils/markdown-converter.js';

type MCPClients = Awaited<ReturnType<typeof initAllMCPClients>>;
type AgentExecutor = ReturnType<typeof createReactAgent>;
type AttachmentDirPromise = Promise<unknown> | null;

type SsePayload = { type: string; [key: string]: unknown };

interface CapRequestContext {
  user?: { id?: string; name?: string; tenant?: string } | null;
  tenant?: string;
  locale?: string;
}

type ClaimsRequest = Request & CapRequestContext;

interface GraphParticipant {
  name?: string | null;
  email?: string | null;
  formatted?: string;
}

interface GraphAttachment {
  id?: string;
  name?: string;
  contentType?: string;
  size?: number;
  contentBytes?: string;
  [key: string]: unknown;
}

interface GraphMessage {
  id: string;
  subject?: string;
  from?: Record<string, unknown>;
  toRecipients?: Array<Record<string, unknown>>;
  ccRecipients?: Array<Record<string, unknown>>;
  bccRecipients?: Array<Record<string, unknown>>;
  receivedDateTime?: string;
  sentDateTime?: string;
  isRead?: boolean;
  webLink?: string;
  importance?: string;
  inferenceClassification?: string;
  bodyPreview?: string;
  body?: { contentType?: string; content?: string } | null;
  hasAttachments?: boolean;
  attachments?: GraphAttachment[];
  [key: string]: unknown;
}

interface SummaryRecord {
  summary: string;
  category: string;
  agentContext: Record<string, unknown> | null;
}

interface NotificationSession {
  clients: Set<Response>;
  buffer: GraphMessage[];
  knownIds: Set<string>;
  summaries: Map<string, SummaryRecord>;
  timer: NodeJS.Timeout | null;
}

type AgentBackend = 'langgraph' | 'claude';

const resolveAgentBackend = (): AgentBackend => {
  const raw = (process.env.CLAIMAI_AGENT_BACKEND || '').trim().toLowerCase();
  if (['claude', 'claude-agent', 'claude_agent', 'anthropic', 'anthropic-claude'].includes(raw)) {
    return 'claude';
  }
  return 'langgraph';
};

const CLAUDE_APPEND_PROMPT = `Keep replies focused, note every tool you invoke, and highlight critical findings in **bold**.`;

export default class ClaimsService extends cds.ApplicationService {
  async init() {
    await super.init();
    console.log('[ClaimAI] ClaimsService init: Claude MCP build with draft-patch normalization active');
    const projectClaudeInstructions = await readFile(path.resolve(process.cwd(), 'CLAUDE.md'), 'utf8')
      .then((content) => content.trim())
      .catch(() => null);
    const langGraphSystemPrompt = projectClaudeInstructions
      ? `${projectClaudeInstructions}\n\n${CLAUDE_APPEND_PROMPT}`
      : CLAUDE_APPEND_PROMPT;
    let agentExecutor: AgentExecutor | null = null;
    let mcpClients: MCPClients | null = null;
    const app = cds.app as express.Application;

    // Lightweight in-memory notification hub (per-user)
    const notificationSessions = new Map<string, NotificationSession>();
    const claudeSessions = new Map<string, string>();

    const getUserId = (req: ClaimsRequest): string => {
      try {
        return (req.user && (req.user.id || req.user.name)) || 'local';
      } catch {
        return 'local';
      }
    };

    const sseSend = (res: Response, payload: SsePayload): void => {
      res.write(`data: ${JSON.stringify(payload)}\n\n`);
    };

    const broadcastToUser = (userId: string, payload: SsePayload): void => {
      const session = notificationSessions.get(userId);
      if (!session) return;
      for (const client of session.clients) {
        try { sseSend(client, payload); } catch { /* ignore */ }
      }
    };

    const ensureSession = (userId: string): NotificationSession => {
      if (!notificationSessions.has(userId)) {
        notificationSessions.set(userId, {
          clients: new Set<Response>(),
          buffer: [],
          knownIds: new Set<string>(),
          summaries: new Map<string, SummaryRecord>(),
          timer: null
        });
      }
      return notificationSessions.get(userId)!;
    };

    const ensureMcpClients = async (): Promise<MCPClients> => {
      if (mcpClients) return mcpClients;
      const clients = await initAllMCPClients({ capService: this, logger: console });
      mcpClients = clients;
      return clients;
    };

    const summarizer = new AzureOpenAiChatClient({ modelName: 'gpt-4.1' });

    const SUMMARY_MAX_INPUT_CHARS = 6000;
    const SUMMARY_MAX_OUTPUT_CHARS = 280;
    const SUMMARY_FALLBACK = 'Keine Zusammenfassung verfügbar.';
    const SUMMARY_CATEGORIES = ['To Respond', 'Notification', 'FYI', 'Meeting Update', 'Action needed', 'Completed'];
    const DEFAULT_CATEGORY = 'Notification';
    const ATTACHMENTS_DIR = process.env.M365_ATTACHMENT_BASE_PATH
      ? path.resolve(process.env.M365_ATTACHMENT_BASE_PATH)
      : path.resolve(process.cwd(), 'tmp', 'attachments');
    const EXCEL_EXTENSIONS = new Set(['.xlsx', '.xls', '.xlsm', '.xlsb', '.csv']);
    const EXCEL_MIME_PREFIXES = [
      'application/vnd.openxmlformats-officedocument.spreadsheetml',
      'application/vnd.ms-excel',
      'text/csv',
      'application/vnd.ms-excel.sheet'
    ];

    let attachmentDirReadyPromise: AttachmentDirPromise = null;

    const stripHtml = (html = ''): string => html
      .replace(/<style[\s\S]*?<\/style>/gi, ' ')
      .replace(/<script[\s\S]*?<\/script>/gi, ' ')
      .replace(/<[^>]+>/g, ' ');

    const normalizeWhitespace = (text = ''): string => text.replace(/\s+/g, ' ').trim();

    const truncate = (text = '', maxLength = SUMMARY_MAX_OUTPUT_CHARS): string => {
      if (text.length <= maxLength) return text;
      return `${text.slice(0, Math.max(0, maxLength - 1)).trim()}…`;
    };

    const ensureAttachmentDir = async (): Promise<void> => {
      if (!attachmentDirReadyPromise) {
        attachmentDirReadyPromise = mkdir(ATTACHMENTS_DIR, { recursive: true }).catch(() => {});
      }
      await attachmentDirReadyPromise;
    };

    const sanitizeFileName = (name = ''): string => {
      const safe = name.replace(/[^a-z0-9_.-]+/gi, '_').replace(/_+/g, '_').trim();
      if (safe) return safe;
      return `attachment_${Date.now()}`;
    };

    const getErrorMessage = (err: unknown): string => {
      if (err && typeof err === 'object' && 'message' in err) {
        const message = (err as { message?: unknown }).message;
        return typeof message === 'string' ? message : String(message);
      }
      return String(err);
    };

    const buildCapContext = (req: CapRequestContext) => ({
      user: req.user,
      tenant: req.user?.tenant || req.tenant,
      locale: req.locale
    });

    const executeClaudeCall = async (prompt: string, req: CapRequestContext): Promise<string> => {
      const clients = await ensureMcpClients();
      if (!clients?.cap) {
        throw new Error('CAP MCP client is not initialized.');
      }
      console.log('🤖 Invoking Claude Agent SDK for prompt');
      const capServerConfig = clients.cap.sdkServer
        ? { cap: clients.cap.sdkServer }
        : undefined;

      const capAllowedTools = Array.isArray(clients.cap.toolDefinitions)
        ? clients.cap.toolDefinitions.map((tool: { name: string }) => `mcp__cap__${tool.name}`)
        : undefined;

      const userId = getUserId(req as ClaimsRequest);
      const resumeSessionId = claudeSessions.get(userId);

      const agentResult = await clients.cap.runWithContext(buildCapContext(req), async () =>
        runClaudeAgent({
          prompt,
          systemPrompt: CLAUDE_APPEND_PROMPT,
          logger: console,
          resumeSessionId,
          options: {
            ...(capServerConfig ? { mcpServers: capServerConfig } : {}),
            ...(capAllowedTools?.length ? { allowedTools: capAllowedTools } : {})
          }
        })
      );

      if (agentResult.sessionId) {
        claudeSessions.set(userId, agentResult.sessionId);
      }

      return MarkdownConverter.convertForClaims(agentResult.result);
    };

    const isExcelAttachment = (attachment: GraphAttachment | null | undefined): boolean => {
      if (!attachment) return false;
      const name = (attachment.name || '').toLowerCase();
      const ext = path.extname(name);
      if (ext && EXCEL_EXTENSIONS.has(ext)) return true;
      const type = (attachment.contentType || '').toLowerCase();
      return EXCEL_MIME_PREFIXES.some((prefix) => type.startsWith(prefix));
    };

    const parseMcpContent = (payload: unknown): unknown => {
      if (payload === null || payload === undefined) return null;
      if (typeof payload === 'string') {
        try {
          return JSON.parse(payload);
        } catch {
          return payload;
        }
      }
      if (Array.isArray(payload)) {
        const parsed = payload
          .map((entry) => parseMcpContent(entry))
          .filter((entry) => entry !== null && entry !== undefined);
        if (parsed.length === 1) return parsed[0];
        return parsed;
      }
      if (typeof payload === 'object') {
        const record = payload as Record<string, unknown>;
        if (Array.isArray(record.content)) {
          const parts = record.content
            .map((part) => {
              if (!part) return null;
              if (typeof part === 'string') return parseMcpContent(part);
              if (typeof (part as Record<string, unknown>).text === 'string') {
                return parseMcpContent((part as Record<string, unknown>).text);
              }
              const partRecord = part as Record<string, unknown>;
              if (partRecord.json !== undefined) return partRecord.json;
              if (partRecord.data !== undefined) return partRecord.data;
              return null;
            })
            .filter((entry) => entry !== null && entry !== undefined);
          if (parts.length === 1) return parts[0];
          return parts;
        }
        return record;
      }
      return payload;
    };

    const callExcelTool = async (toolName: string, args: Record<string, unknown>): Promise<unknown> => {
      if (!mcpClients?.excel) return null;
      try {
        const result = await mcpClients.excel.callTool({ name: toolName, arguments: args });
        return parseMcpContent(result) ?? null;
      } catch (error) {
        console.warn(`Excel tool ${toolName} failed:`, getErrorMessage(error));
        return null;
      }
    };

    const extractSheetNames = (describeResult: unknown): string[] => {
      if (!describeResult) return [];
      if (Array.isArray(describeResult)) {
        return describeResult
          .map((entry) => {
            if (!entry) return null;
            if (typeof entry === 'string') return entry;
            const record = entry as Record<string, unknown>;
            if (typeof record.name === 'string') return record.name;
            if (typeof record.sheetName === 'string') return record.sheetName;
            return null;
          })
          .filter((value): value is string => typeof value === 'string' && value.length > 0);
      }
      const record = describeResult as Record<string, unknown>;
      const sheets = record.sheets;
      if (Array.isArray(sheets)) {
        return sheets
          .map((sheet) => {
            if (!sheet) return null;
            if (typeof sheet === 'string') return sheet;
            const record = sheet as Record<string, unknown>;
            if (typeof record.name === 'string') return record.name;
            if (typeof record.sheetName === 'string') return record.sheetName;
            return null;
          })
          .filter((value): value is string => typeof value === 'string' && value.length > 0);
      }
      const sheetNames = record.sheetNames;
      if (Array.isArray(sheetNames)) {
        return sheetNames.filter((name): name is string => typeof name === 'string' && Boolean(name));
      }
      if (typeof record.sheetName === 'string') {
        return [record.sheetName];
      }
      return [];
    };

    const loadExcelAttachmentContext = async (filePath: string): Promise<{ describe: unknown; sheets: unknown[] }> => {
      const describeResult = await callExcelTool('excel_describe_sheets', { fileAbsolutePath: filePath });
      const sheetNames = extractSheetNames(describeResult);

      const sheets: unknown[] = [];
      for (const sheetName of sheetNames) {
        try {
          const sheetData = await callExcelTool('excel_read_sheet', {
            fileAbsolutePath: filePath,
            sheetName
          });
          sheets.push({ sheetName, data: sheetData });
        } catch (error) {
          console.warn('Failed to read Excel sheet', sheetName, getErrorMessage(error));
          sheets.push({ sheetName, error: getErrorMessage(error) });
        }
      }

      return { describe: describeResult, sheets };
    };

    const ensureExcelAttachmentDetails = async (message: GraphMessage, summaryEntry: SummaryRecord | null | undefined): Promise<void> => {
      if (!summaryEntry?.agentContext) return;
      const attachments = Array.isArray(message?.attachments) ? (message.attachments as GraphAttachment[]) : [];
      if (!attachments.length) return;

      await ensureAttachmentDir();

      const enriched: Array<Record<string, unknown>> = [];
      for (const attachment of attachments) {
        const baseInfo = {
          id: attachment.id || null,
          name: attachment.name || null,
          contentType: attachment.contentType || null,
          size: attachment.size ?? null,
          isInline: Boolean(attachment.isInline)
        };

        if (!isExcelAttachment(attachment) || (attachment as any).isInline) {
          enriched.push(baseInfo);
          continue;
        }

        if (!attachment.id || !message.id) {
          enriched.push({ ...baseInfo, error: 'attachment id or message id missing' });
          continue;
        }

        const safeName = sanitizeFileName(attachment.name || `${message.id}-${attachment.id}.xlsx`);
        const targetPath = path.join(ATTACHMENTS_DIR, safeName);

        try {
          if (!existsSync(targetPath)) {
            await graph.downloadAttachment({
              messageId: message.id,
              attachmentId: attachment.id,
              targetPath
            });
          }

          const excel = await loadExcelAttachmentContext(targetPath);
          enriched.push({
            ...baseInfo,
            path: targetPath,
            excel
          });
        } catch (error) {
          console.warn('Failed to process Excel attachment:', attachment.name, getErrorMessage(error));
          enriched.push({ ...baseInfo, path: targetPath, error: getErrorMessage(error) });
        }
      }

      (summaryEntry.agentContext as Record<string, unknown>).attachments = enriched;
    };

    const escapeHtml = (text = ''): string => text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');

    const sanitizeEmailHtml = (html = ''): string => {
      if (!html) return '';
      let sanitized = html;
      sanitized = sanitized.replace(/<script[\s\S]*?<\/script>/gi, '');
      sanitized = sanitized.replace(/<style[\s\S]*?<\/style>/gi, '');
      sanitized = sanitized.replace(/<link[\s\S]*?>/gi, '');
      sanitized = sanitized.replace(/<iframe[\s\S]*?<\/iframe>/gi, '');
      sanitized = sanitized.replace(/<object[\s\S]*?<\/object>/gi, '');
      sanitized = sanitized.replace(/<embed[\s\S]*?<\/embed>/gi, '');
      sanitized = sanitized.replace(/<base[\s\S]*?>/gi, '');
      sanitized = sanitized.replace(/\s+on[a-z]+\s*=\s*"[^"]*"/gi, '');
      sanitized = sanitized.replace(/\s+on[a-z]+\s*=\s*'[^']*'/gi, '');
      sanitized = sanitized.replace(/\s+on[a-z]+\s*=\s*[^\s>]+/gi, '');
      sanitized = sanitized.replace(/javascript:/gi, '');
      sanitized = sanitized.replace(/data:text\/html;[^"'>]+/gi, '');
      return sanitized.trim();
    };

    const getSanitizedBodyHtml = (message: GraphMessage): string | null => {
      if (!message?.body?.content) return null;
      const { content, contentType } = message.body;
      if (!content) return null;
      if (contentType === 'html') {
        return sanitizeEmailHtml(content);
      }
      const plain = typeof content === 'string' ? content : String(content);
      return `<pre>${escapeHtml(plain)}</pre>`;
    };

    const extractMessageContent = (message: GraphMessage | null | undefined): string => {
      if (!message) return '';
      const { body } = message;
      if (body?.content) {
        const raw = body.contentType === 'html' ? stripHtml(body.content) : body.content;
        return normalizeWhitespace(raw);
      }
      if (message.bodyPreview) {
        return normalizeWhitespace(message.bodyPreview);
      }
      return '';
    };

    const extractModelOutput = (result: unknown): string => {
      if (!result) return '';
      if (typeof result === 'string') return result;
      const record = result as Record<string, unknown>;
      const content = record.content;
      if (typeof content === 'string') return content;
      if (Array.isArray(content)) {
        return content
          .map((part) => {
            if (typeof part === 'string') return part;
            const partRecord = part as Record<string, unknown>;
            if (typeof partRecord?.text === 'string') return partRecord.text as string;
            return '';
          })
          .filter(Boolean)
          .join(' ');
      }
      if (typeof record.text === 'string') return record.text as string;
      return '';
    };

    const extractMailParticipant = (entry: unknown): GraphParticipant | null => {
      if (!entry) return null;
      const entryRecord = entry as Record<string, unknown>;
      const emailAddress = (entryRecord.emailAddress || entryRecord) as Record<string, unknown>;
      const address = (emailAddress.address || emailAddress.emailAddress || emailAddress.value || entryRecord.address || null) as string | null;
      const name = (emailAddress.name || emailAddress.displayName || entryRecord.name || entryRecord.displayName || null) as string | null;
      const formatted = name && address ? `${name} <${address}>` : (name || address || null);
      if (!formatted) return null;
      return {
        name,
        email: address,
        formatted
      };
    };

    const formatMailAddress = (entry: unknown): string | null => {
      const participant = extractMailParticipant(entry);
      return participant?.formatted || null;
    };

    const mapRecipients = (list: unknown): string[] => {
      if (!Array.isArray(list)) return [];
      return list
        .map(formatMailAddress)
        .filter((value): value is string => typeof value === 'string' && value.length > 0);
    };

    const mapRecipientDetails = (list: unknown): Array<{ name: string | null; email: string | null }> => {
      if (!Array.isArray(list)) return [];
      return list
        .map(extractMailParticipant)
        .filter((participant): participant is GraphParticipant => Boolean(participant))
        .map((participant) => ({
          name: participant.name || null,
          email: participant.email || null
        }));
    };

    const buildAgentContext = (message: GraphMessage, summary: string, category: string): Record<string, unknown> => {
      const content = extractMessageContent(message) || '';
      const bodyPreview = normalizeWhitespace(message.bodyPreview || '').slice(0, SUMMARY_MAX_OUTPUT_CHARS);
      const sender = extractMailParticipant(message.from);
      const from = sender?.formatted || null;
      const toDetails = mapRecipientDetails(message.toRecipients);
      const ccDetails = mapRecipientDetails(message.ccRecipients);
      const bodyHtml = getSanitizedBodyHtml(message);
      const senderEmail = sender?.email ?? null;
      return {
        id: message.id,
        subject: message.subject || '',
        from,
        sender: sender
          ? {
              name: sender.name || null,
              email: sender.email || null,
              formatted: sender.formatted
            }
          : null,
        toRecipients: mapRecipients(message.toRecipients),
        toRecipientDetails: toDetails,
        ccRecipients: mapRecipients(message.ccRecipients),
        ccRecipientDetails: ccDetails,
        receivedDateTime: message.receivedDateTime || null,
        webLink: message.webLink || null,
        hasAttachments: Boolean(message.hasAttachments),
        attachmentCount: Array.isArray(message.attachments) ? message.attachments.length : null,
        category,
        summary,
        bodyPreview,
        body: content,
        bodyText: content,
        bodyHtml,
        importance: message.importance || null,
        inferenceClassification: message.inferenceClassification || null,
        replyGuidelines: {
          defaultEmailRecipients: senderEmail ? [senderEmail] : [],
          defaultCalendarAttendees: senderEmail ? [senderEmail] : [],
          instructions: 'Bei Antworten oder Kalendereinladungen den ursprünglichen Absender automatisch als Empfänger hinzufügen, es sei denn, der Nutzer nennt ausdrücklich weitere Teilnehmer.'
        },
        attachments: []
      };
    };

    const finalizeSummaryResult = (
      message: GraphMessage,
      summaryText: string | null | undefined,
      categoryText: string | null | undefined
    ): SummaryRecord => {
      const fallback = message.bodyPreview?.trim() || SUMMARY_FALLBACK;
      const normalizedSummary = normalizeWhitespace(summaryText || fallback);
      const truncated = truncate(normalizedSummary || fallback, SUMMARY_MAX_OUTPUT_CHARS);
      const normalizedCategory = typeof categoryText === 'string' && SUMMARY_CATEGORIES.includes(categoryText)
        ? categoryText
        : DEFAULT_CATEGORY;
      const agentContext = buildAgentContext(message, truncated || fallback, normalizedCategory);
      return { summary: truncated || fallback, category: normalizedCategory, agentContext };
    };

    const generateSummaryForMessage = async (message: GraphMessage): Promise<SummaryRecord> => {
      const content = extractMessageContent(message);
      const safeContent = content ? content.slice(0, SUMMARY_MAX_INPUT_CHARS) : '';
      const subject = message.subject || '';

      if (!safeContent) {
        return finalizeSummaryResult(message, message.bodyPreview, DEFAULT_CATEGORY);
      }

      const userPrompt = `Fasse die folgende E-Mail in höchstens zwei Sätzen (maximal 280 Zeichen) zusammen und kategorisiere sie.
Gültige Kategorien: To Respond, Notification, FYI, Meeting Update, Action needed, Completed.
Gib das Ergebnis ausschließlich als kompaktes JSON-Objekt zurück: {"summary":"...","category":"..."}.

Betreff: ${subject || '—'}

${safeContent}`;

      try {
        const response = await summarizer.invoke([
          {
            role: 'system',
            content: 'Du bist ein Assistent, der eingehende E-Mails prägnant in höchstens zwei Sätzen (maximal 280 Zeichen) zusammenfasst und sie in eine vorgegebene Kategorie einordnet. Antworte ausschließlich mit gültigem JSON im Format {"summary":"...","category":"..."}.'
          },
          {
            role: 'user',
            content: userPrompt
          }
        ]);

        const rawContent = (extractModelOutput(response) || '').trim();
        if (!rawContent) {
          return finalizeSummaryResult(message, null, DEFAULT_CATEGORY);
        }
        let parsed = null;
        try {
          const jsonMatch = rawContent.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            parsed = JSON.parse(jsonMatch[0]);
          } else {
            parsed = JSON.parse(rawContent);
          }
        } catch (parseError) {
          parsed = null;
        }

        if (parsed && typeof parsed === 'object') {
          const summaryCandidate = typeof parsed.summary === 'string' ? parsed.summary : null;
          const categoryCandidate = typeof parsed.category === 'string' ? parsed.category : DEFAULT_CATEGORY;
          return finalizeSummaryResult(message, summaryCandidate, categoryCandidate);
        }

        return finalizeSummaryResult(message, rawContent, DEFAULT_CATEGORY);
      } catch (error) {
        console.warn('Failed to generate mail summary:', getErrorMessage(error));
        return finalizeSummaryResult(message, message.bodyPreview, DEFAULT_CATEGORY);
      }
    };

    const ensureSummaryForMessage = async (session: NotificationSession, message: GraphMessage): Promise<SummaryRecord> => {
      if (!message?.id) return finalizeSummaryResult(message, null, DEFAULT_CATEGORY);
      const cached = session.summaries.get(message.id);
      if (cached) {
        return cached;
      }
      const summary = await generateSummaryForMessage(message);
      try {
        await ensureExcelAttachmentDetails(message, summary);
      } catch (error) {
        console.warn('ensureExcelAttachmentDetails failed:', getErrorMessage(error));
      }
      session.summaries.set(message.id, summary);
      return summary;
    };

    const ensureSummariesForMessages = async (session: NotificationSession, messages: GraphMessage[] = []): Promise<void> => {
      for (const message of messages) {
        try {
          await ensureSummaryForMessage(session, message);
        } catch (error) {
          console.warn('ensureSummaryForMessage failed:', getErrorMessage(error));
        }
      }
    };

    // Microsoft Graph client (CLI login based)
    const graph = new GraphClient({ logger: console });
    await graph.bootstrap(['Mail.Read', 'Mail.ReadWrite', 'Mail.Send', 'Calendars.Read', 'Calendars.ReadWrite']);

    const POLL_INTERVAL_MS = 10_000;
    const MAX_INIT_UNREAD = 10;

    const startPollerIfNeeded = async (userId: string): Promise<void> => {
      const session = ensureSession(userId);
      if (session.timer) return;

      // Initial fetch
      try {
        const initial = await graph.listUnreadMessages({ maxResults: MAX_INIT_UNREAD }) as GraphMessage[];
        session.buffer = initial;
        session.knownIds = new Set(initial.map(m => m.id));
        await ensureSummariesForMessages(session, session.buffer);
      } catch (e) {
        console.warn('Initial unread fetch failed:', getErrorMessage(e));
      }

      session.timer = setInterval(async () => {
        try {
          const unread = await graph.listUnreadMessages({ maxResults: MAX_INIT_UNREAD }) as GraphMessage[];
          const currentIds = new Set(unread.map(m => m.id));

          // New arrivals
          for (const msg of unread) {
            if (!session.knownIds.has(msg.id)) {
              session.knownIds.add(msg.id);
              session.buffer.unshift(msg);
              // Trim buffer
              if (session.buffer.length > MAX_INIT_UNREAD) session.buffer.length = MAX_INIT_UNREAD;
              await ensureSummaryForMessage(session, msg);
              broadcastToUser(userId, { type: 'new', item: sanitizeMessage(msg, session) });
            }
          }

          // Items that disappeared (likely got marked as read elsewhere)
          for (const id of Array.from(session.knownIds)) {
            if (!currentIds.has(id)) {
              session.knownIds.delete(id);
              session.buffer = session.buffer.filter(x => x.id !== id);
              session.summaries.delete(id);
              broadcastToUser(userId, { type: 'read', id });
            }
          }
        } catch (e) {
          console.warn('Polling unread messages failed:', getErrorMessage(e));
        }
      }, POLL_INTERVAL_MS);
    };

    const stopPollerIfOrphaned = (userId: string): void => {
      const session = notificationSessions.get(userId);
      if (!session) return;
      if (session.clients.size === 0 && session.timer) {
        clearInterval(session.timer);
        session.timer = null;
      }
    };

    const sanitizeMessage = (msg: GraphMessage, session: NotificationSession): Record<string, unknown> => {
      const cacheEntry = session?.summaries?.get(msg.id) || null;
      return {
        id: msg.id,
        subject: msg.subject || '',
        from: msg.from || null,
        receivedDateTime: msg.receivedDateTime,
        isRead: Boolean(msg.isRead),
        webLink: msg.webLink || '',
        summary: cacheEntry?.summary || null,
        category: cacheEntry?.category || null,
        agentContext: cacheEntry?.agentContext || null,
        hasAttachments: Boolean(msg.hasAttachments)
      };
    };

    // SSE stream endpoint
    app.get('/service/claims/notifications/stream', async (req: ClaimsRequest, res: Response) => {
      const userId = getUserId(req);
      res.setHeader('Content-Type', 'text/event-stream');
      res.setHeader('Cache-Control', 'no-cache');
      res.setHeader('Connection', 'keep-alive');
      res.setHeader('X-Accel-Buffering', 'no');
      res.flushHeaders?.();

      const session = ensureSession(userId);
      session.clients.add(res);

      // Send initial buffer (unread only)
      try {
        // Ensure we have fresh buffer for this connect
        if (!session.buffer.length) {
          const initial = await graph.listUnreadMessages({ maxResults: MAX_INIT_UNREAD }) as GraphMessage[];
          session.buffer = initial;
          session.knownIds = new Set(initial.map(m => m.id));
          await ensureSummariesForMessages(session, session.buffer);
        } else {
          await ensureSummariesForMessages(session, session.buffer);
        }
        sseSend(res, { type: 'init', items: session.buffer.map((msg) => sanitizeMessage(msg, session)) });
      } catch (e) {
        sseSend(res, { type: 'error', message: getErrorMessage(e) });
      }

      // Start poller if needed
      startPollerIfNeeded(userId);

      req.on('close', () => {
        const s = notificationSessions.get(userId);
        if (s) {
          s.clients.delete(res);
          stopPollerIfOrphaned(userId);
        }
      });
    });

    // Mark-as-read endpoint (backend-only, no MCP tool)
    app.post('/service/claims/notifications/markRead', express.json(), async (req: ClaimsRequest, res: Response) => {
      try {
        const userId = getUserId(req);
        const { id } = req.body || {};
        if (!id) return res.status(400).json({ error: 'id is required' });
        await graph.markMessageRead(id, true);

        const session = ensureSession(userId);
        session.knownIds.delete(id);
        session.buffer = session.buffer.filter(x => x.id !== id);
        session.summaries.delete(id);
        broadcastToUser(userId, { type: 'read', id });
        return res.json({ status: 'ok', id });
      } catch (e) {
        console.error('markRead failed:', e);
        return res.status(500).json({ error: getErrorMessage(e) });
      }
    });

    const initializeAgent = async (): Promise<AgentExecutor> => {
      if (agentExecutor) return agentExecutor;

      // +++ ERWEITERT: Log-Nachricht angepasst +++
      console.log("Initializing Agent with CAP data access, Web Search, Filesystem, Excel, Microsoft 365, and Time capabilities...");

      try {
        const clients = await ensureMcpClients();

        const [capTools, cdsModelTools, braveSearchTools, filesystemTools, excelTools, timeTools] = await Promise.all([
          loadMcpTools('cap', clients.cap),
          loadMcpTools('search_model', clients.cdsModel),
          loadMcpTools("brave_web_search,brave_local_search", clients.braveSearch),
          loadMcpTools("read_file,write_file,edit_file,create_directory,list_directory,move_file,search_files,get_file_info,list_allowed_directories", clients.filesystem),
          loadMcpTools("excel_describe_sheets,excel_read_sheet,excel_screen_capture,excel_write_to_sheet,excel_create_table,excel_copy_sheet", clients.excel),
          loadMcpTools("get_current_time,convert_time", clients.time)
        ]) as StructuredToolInterface[][];

        // PostgreSQL tools are temporarily disabled while the CAP MCP migration is in progress.
        // const postgresTools = await loadMcpTools("query", clients.postgres);
        const postgresTools: StructuredToolInterface[] = [];

        // Kombiniere alle Tools
        const allTools = [...postgresTools, ...cdsModelTools, ...capTools, ...braveSearchTools, ...filesystemTools, ...excelTools, ...timeTools];

        // Lade Microsoft 365 Tools dynamisch aus dem Manifest
        if (clients.m365) {
          console.log("Loading Microsoft 365 tools...");
          const manifest = await clients.m365.listTools();
          const m365Tools = manifest.tools.map((toolDef) => {
            const schema = jsonSchemaToZod(toolDef.inputSchema, z);
            return new DynamicStructuredTool({
              name: toolDef.name,
              description: toolDef.description,
              schema,
              func: async (input) => {
                const result = await clients.m365!.callTool({ name: toolDef.name, arguments: input });
                return typeof result === 'string' ? result : JSON.stringify(result);
              }
            });
          });
          allTools.push(...m365Tools);
          console.log(`✅ Loaded ${m365Tools.length} Microsoft 365 tools`);
        }

        console.log(`✅ Loaded ${capTools.length} CAP, ${cdsModelTools.length} cds-mcp, ${braveSearchTools.length} Brave Search, ${filesystemTools.length} Filesystem, ${excelTools.length} Excel, and ${timeTools.length} Time tools (${postgresTools.length} PostgreSQL tools currently disabled)`);
        console.log("Available tools:", allTools.map(tool => tool.name));

        const llm = new AzureOpenAiChatClient({ modelName: 'gpt-4.1' });
        const checkpointer = new MemorySaver();

        agentExecutor = createReactAgent({
          llm,
          tools: allTools,
          checkpointSaver: checkpointer
        });
        
        // +++ ERWEITERT: Log-Nachricht angepasst +++
        console.log("✅ Multi-Modal Agent is ready (Database + Web Search + Filesystem + Excel + M365 + Time).");
        return agentExecutor;

      } catch (error) {
        console.error("❌ Failed to initialize agent:", error);
        throw error;
      }
    };

    const preferredBackend = resolveAgentBackend();
    if (preferredBackend === 'langgraph') {
      await initializeAgent();
    } else {
      console.log('Claude Agent backend selected; initializing MCP clients without LangGraph warmup.');
      await ensureMcpClients();
    }

    this.on('callLLM', async (req) => {
      const { prompt: userPrompt } = req.data;
      if (!userPrompt) {
        req.error(400, 'Prompt is required');
        return;
      }

      const backend = resolveAgentBackend();
      console.log(`🚀 Received prompt for ${backend === 'claude' ? 'Claude Agent' : 'Multi-Modal Agent'}:`, userPrompt);

      try {
        if (backend === 'claude') {
          const claudeResponse = await executeClaudeCall(userPrompt, req);
          return { response: claudeResponse };
        }

        const executor = await initializeAgent();
        const clients = await ensureMcpClients();
        const capContext = buildCapContext(req);

        return await clients.cap.runWithContext(capContext, async () => {
          const systemMessage = {
            role: 'system',
            content: langGraphSystemPrompt
          };

          const userMessage = {
            role: 'user',
            content: userPrompt
          };

          const stream = await executor.stream(
            {
              messages: [systemMessage, userMessage]
            },
            {
              configurable: { thread_id: `session_test}` }
            }
          );

          const finalResponseParts: string[] = [];
          console.log("\n\n---- AGENT STREAM START ----\n");

          for await (const chunk of stream) {
            if (chunk.agent?.messages) {
              const message = chunk.agent.messages[chunk.agent.messages.length - 1];
              if (message && message.content) {
                process.stdout.write(message.content);
                finalResponseParts.push(message.content);
              }
              if (message.tool_calls && message.tool_calls.length > 0) {
                const toolCall = message.tool_calls[0];
                const toolCallStr = `

<TOOL_CALL>
  Tool: ${toolCall.name}
  Args: ${JSON.stringify(toolCall.args)}
</TOOL_CALL>

`;
                process.stdout.write(toolCallStr);
              }
            }

            if (chunk.tools?.messages) {
              const toolMessage = chunk.tools.messages[0];
              const toolOutputStr = `<TOOL_OUTPUT>
  ${toolMessage.content}
</TOOL_OUTPUT>

`;
              process.stdout.write(toolOutputStr);
            }
          }
          console.log("\n---- AGENT STREAM END ----\n");

          const rawResponse = finalResponseParts.join("");
          const htmlResponse = MarkdownConverter.convertForClaims(rawResponse);

          return { response: htmlResponse };
        });

      } catch (error) {
        console.error('💥 Error during agent execution:', error);
        const backendLabel = backend === 'claude' ? 'Claude Agent' : 'LangGraph agent';
        req.error(500, `Failed to process query via ${backendLabel}: ${getErrorMessage(error)}`);
      }
    });

    this.on('callClaudeAgent', async (req) => {
      const { prompt: userPrompt } = req.data;
      if (!userPrompt) {
        req.error(400, 'Prompt is required');
        return;
      }

      console.log('🚀 Received prompt for Claude Agent (direct):', userPrompt);

      try {
        const claudeResponse = await executeClaudeCall(userPrompt, req);
        return { response: claudeResponse };
      } catch (error) {
        console.error('💥 Error during Claude agent execution:', error);
        req.error(500, `Failed to process query via Claude Agent: ${getErrorMessage(error)}`);
      }
    });

    this.on('EXIT', async () => {
      console.log('Shutting down MCP clients...');
      for (const session of notificationSessions.values()) {
        if (session.timer) {
          clearInterval(session.timer);
        }
      }
      notificationSessions.clear();
      await graph.close();
      await closeMCPClients();
    });
  }
}
</file>

<file path="types/cds-augmentations.d.ts">
import '@sap/cds';

declare module '@sap/cds' {
  interface RequestConstructor {
    new <T = any>(init?: Record<string, unknown>): Request<T>;
    prototype: Request;
  }

  const Request: RequestConstructor;

  function raw(sql: TemplateStringsArray, ...values: unknown[]): any;
  function raw(sql: string, ...values: unknown[]): any;

  namespace utils {
    function guid(): string;
    function uuid(): string;
  }
}
</file>

<file path="utils/markdown-converter.ts">
// srv/utils/markdown-converter.ts
/**
 * Einfacher Markdown-zu-HTML Konverter für AI-Antworten
 * Speziell optimiert für SAP UI5 FormattedText Component
 */

class MarkdownConverter {
  
  /**
   * Konvertiert Markdown zu HTML für SAP UI5 FormattedText
   * @param {string} markdown - Markdown Text
   * @returns {string} HTML String
   */
  static convertToHTML(markdown: string): string {
    if (!markdown || typeof markdown !== 'string') {
      return '';
    }

    let html = markdown;

    // 1. Code-Blöcke (müssen zuerst verarbeitet werden)
    html = this.convertCodeBlocks(html);

    // 2. Inline Code
    html = this.convertInlineCode(html);

    // 3. Headers (H1-H4)
    html = this.convertHeaders(html);

    // 4. Bold und Italic
    html = this.convertTextFormatting(html);

    // 5. Listen
    html = this.convertLists(html);

    // 6. Links (falls vorhanden)
    html = this.convertLinks(html);

    // 7. Emojis und Sonderzeichen beibehalten
    html = this.preserveEmojis(html);

    // 8. Zeilenumbrüche
    html = this.convertLineBreaks(html);

    // 9. SAP UI5 spezifische Optimierungen
    html = this.optimizeForSAPUI5(html);

    return html.trim();
  }

  /**
   * Konvertiert Code-Blöcke
   */
  static convertCodeBlocks(text: string): string {
    // ```language \n code \n ```
    return text.replace(/```(\w*)\n([\s\S]*?)\n```/g, (_match: string, language: string, code: string) => {
      const cleanCode = this.escapeHTML(code.trim());
      return `<div class="ai-code-block">
        <div class="ai-code-header">${language || 'Code'}</div>
        <pre class="ai-code-content"><code>${cleanCode}</code></pre>
      </div>`;
    });
  }

  /**
   * Konvertiert Inline-Code
   */
  static convertInlineCode(text: string): string {
    return text.replace(/`([^`]+)`/g, '<code class="ai-inline-code">$1</code>');
  }

  /**
   * Konvertiert Headers
   */
  static convertHeaders(text: string): string {
    // ### Header 3
    text = text.replace(/^### (.+)$/gm, '<h3 class="ai-header-3">$1</h3>');
    // ## Header 2  
    text = text.replace(/^## (.+)$/gm, '<h2 class="ai-header-2">$1</h2>');
    // # Header 1
    text = text.replace(/^# (.+)$/gm, '<h1 class="ai-header-1">$1</h1>');
    
    return text;
  }

  /**
   * Konvertiert Bold und Italic
   */
  static convertTextFormatting(text: string): string {
    // **Bold**
    text = text.replace(/\*\*([^*]+)\*\*/g, '<strong class="ai-bold">$1</strong>');
    // *Italic*
    text = text.replace(/\*([^*]+)\*/g, '<em class="ai-italic">$1</em>');
    
    return text;
  }

  /**
   * Konvertiert Listen
   */
  static convertLists(text: string): string {
    // Unordered Lists
    text = text.replace(/^- (.+)$/gm, '<li class="ai-list-item">$1</li>');
    
    // Wrap consecutive list items in <ul>
    text = text.replace(/(<li class="ai-list-item">.*<\/li>\s*)+/gs, (match: string) => `<ul class="ai-unordered-list">${match}</ul>`);

    // Numbered Lists (vereinfacht)
    text = text.replace(/^\d+\. (.+)$/gm, '<li class="ai-numbered-item">$1</li>');
    
    // Wrap consecutive numbered items in <ol>
    text = text.replace(/(<li class="ai-numbered-item">.*<\/li>\s*)+/gs, (match: string) => `<ol class="ai-ordered-list">${match}</ol>`);

    return text;
  }

  /**
   * Konvertiert Links
   */
  static convertLinks(text: string): string {
    // [Text](URL)
    return text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="#" class="ai-link" data-url="$2" title="$2">$1</a>');
  }

  /**
   * Behält Emojis bei
   */
  static preserveEmojis(text: string): string {
    // Emojis sind bereits Unicode, keine Konvertierung nötig
    return text;
  }

  /**
   * Konvertiert Zeilenumbrüche
   */
  static convertLineBreaks(text: string): string {
    // Doppelte Zeilenumbrüche zu Paragraphen
    text = text.replace(/\n\n+/g, '</p><p class="ai-paragraph">');
    
    // Einzelne Zeilenumbrüche zu <br>
    text = text.replace(/\n/g, '<br/>');
    
    // Wrap in paragraph wenn nicht schon in anderen Tags
    if (!text.startsWith('<') && text.length > 0) {
      text = `<p class="ai-paragraph">${text}</p>`;
    }

    return text;
  }

  /**
   * SAP UI5 spezifische Optimierungen
   */
  static optimizeForSAPUI5(text: string): string {
    // Bereinige leere Paragraphen
    text = text.replace(/<p class="ai-paragraph"><\/p>/g, '');
    
    // Stelle sicher, dass alle Tags geschlossen sind
    text = this.closeOpenTags(text);
    
    return text;
  }

  /**
   * HTML Escaping für Sicherheit
   */
  static escapeHTML(text: string): string {
    const map: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    return text.replace(/[&<>"']/g, (m: string) => map[m]);
  }

  /**
   * Schließt offene Tags (vereinfacht)
   */
  static closeOpenTags(html: string): string {
    // Einfache Implementation - für Produktionsumgebung sollte ein richtiger HTML-Parser verwendet werden
    const openTags: string[] = [];
    const tagRegex = /<\/?([a-zA-Z][a-zA-Z0-9]*)[^>]*>/g;
    
    let match: RegExpExecArray | null;
    while ((match = tagRegex.exec(html)) !== null) {
      if (match[0].startsWith('</')) {
        // Closing tag
        const tag = match[1].toLowerCase();
        const index = openTags.lastIndexOf(tag);
        if (index !== -1) {
          openTags.splice(index, 1);
        }
      } else if (!match[0].endsWith('/>')) {
        // Opening tag (not self-closing)
        openTags.push(match[1].toLowerCase());
      }
    }

    // Schließe offene Tags
    for (let i = openTags.length - 1; i >= 0; i--) {
      html += `</${openTags[i]}>`;
    }

    return html;
  }

  /**
   * Spezielle Konvertierung für SAP-spezifische Inhalte
   */
  static convertSAPContent(text: string): string {
    // SAP UI5 Komponenten-Namen hervorheben
    text = text.replace(/\b(List Report|Object Page|Draft|Value Help|Smart Filter Bar)\b/g, 
      '<span class="ai-sap-term">$1</span>');
    
    // Schritt-für-Schritt Anleitungen
    text = text.replace(/^\*\*Schritt (\d+)\*\*:?/gm, 
      '<div class="ai-step-header">📋 <strong>Schritt $1</strong></div>');
    
    return text;
  }

  /**
   * Hauptmethode für die Konvertierung mit SAP-spezifischen Verbesserungen
   */
  static convertForClaims(markdown: string): string {
    let html = this.convertToHTML(markdown);
    html = this.convertSAPContent(html);
    return html;
  }
}

export default MarkdownConverter;
</file>

</files>
