This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
agents/enhanced-agent.js
lib/mcp-client.js
prompts/assistant-prompt.js
prompts/prompt-config.json
service.cds
service.js
tools/database-tools.js
utils/markdown-converter.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="agents/enhanced-agent.js">
// srv/agents/enhanced-agent.js
/**
 * Enhanced AI Agent System with Dynamic Routing
 * Nutzt AI-basierte Klassifikation ohne Keywords
 */

const DatabaseTools = require('../tools/database-tools');
const MarkdownConverter = require('../utils/markdown-converter');

class EnhancedAIAgent {
  
  constructor() {
    this.dbTools = new DatabaseTools();
    this.executionHistory = [];
    this.currentPlan = null;
    
    // Cache f√ºr h√§ufige Klassifikationen
    this.classificationCache = new Map();
    this.cacheMaxSize = 100;
    this.cacheMaxAge = 3600000; // 1 Stunde
  }

  /**
   * DYNAMIC AI ROUTING: Intelligente Klassifikation ohne Keywords
   */
  async classifyRequest(prompt) {
    console.log('=== DYNAMIC ROUTING: AI-based Classification ===');
    
    // Pr√ºfe Cache
    const cachedResult = this.getCachedClassification(prompt);
    if (cachedResult) {
      console.log('Using cached classification');
      return cachedResult;
    }
    
    const classificationPrompt = `Du bist ein intelligenter Request Classifier f√ºr die StammtischAI-Anwendung.
Analysiere die Benutzeranfrage und klassifiziere sie basierend auf INTENT und KONTEXT, nicht auf Keywords.

VERF√úGBARE TOOLS IN DER ANWENDUNG:
1. get_stammtische - Alle Stammtische abrufen
2. get_stammtisch_by_id - Einzelnen Stammtisch abrufen
3. search_stammtische - Nach Stammtischen suchen
4. get_praesentatoren - Pr√§sentatoren-Liste
5. get_teilnehmer - Teilnehmer f√ºr Stammtisch
6. get_stammtisch_statistics - Umfassende Statistiken
7. get_upcoming_stammtische - Kommende Events

KLASSIFIKATIONS-KATEGORIEN:

**personal_chat** - Der Benutzer m√∂chte:
- Sich vorstellen oder Small Talk machen
- Etwas √ºber den Bot erfahren
- Allgemeine Konversation ohne Datenbezug

**help_task** - Der Benutzer braucht:
- Hilfe zur Anwendung selbst
- Erkl√§rungen zu Funktionen
- Anleitung zur Bedienung

**data_retrieval** - Der Benutzer m√∂chte:
- Spezifische Daten aus der Datenbank
- Listen oder √úbersichten
- Einzelne Datens√§tze

**search_operation** - Der Benutzer m√∂chte:
- Nach bestimmten Inhalten suchen
- Filterkriterien anwenden
- Spezifische Teilmengen finden

**analytical_task** - Der Benutzer m√∂chte:
- Daten analysieren oder auswerten
- Trends oder Muster erkennen
- Statistische Informationen

**complex_workflow** - Der Benutzer braucht:
- Mehrere Datenquellen kombiniert
- Komplexe Berichte
- Orchestrierte Workflows

ANALYSE-PROZESS:
1. Identifiziere die HAUPTINTENTION des Benutzers
2. Bestimme welche DATEN ben√∂tigt werden
3. Erkenne die KOMPLEXIT√ÑT der Anfrage
4. Leite die passenden TOOLS ab

ANFRAGE: "${prompt}"

Analysiere und klassifiziere:

<classification>
{
  "category": "kategorie_name",
  "confidence": 0.95,
  "intent": "Was will der Benutzer erreichen?",
  "data_needs": ["welche Daten werden ben√∂tigt"],
  "suggested_tools": ["tool1", "tool2"],
  "parameters": {"key": "value"},
  "complexity": "simple|moderate|complex",
  "reasoning": "Kurze Begr√ºndung der Klassifikation"
}
</classification>`;

    try {
      const { OrchestrationClient } = await import('@sap-ai-sdk/orchestration');
      const client = new OrchestrationClient({
        llm: { model_name: "gpt-4o-mini" }, // Schnelleres Modell
        templating: { template: [{ role: 'user', content: '{{?user_prompt}}' }] }
      });

      const response = await client.chatCompletion({
        inputParams: { user_prompt: classificationPrompt },
        params: { 
          max_tokens_to_sample: 500, 
          temperature: 0.1,
          response_format: { type: "json_object" } // Force JSON output
        }
      });

      const classificationText = response.getContent();
      const match = classificationText.match(/<classification>([\s\S]*?)<\/classification>/);
      
      if (match) {
        const classification = JSON.parse(match[1].trim());
        console.log('AI Classification Result:', classification);
        
        // Cache das Ergebnis
        this.cacheClassification(prompt, classification);
        
        return classification;
      }
      
      // Fallback zu JSON parsing wenn keine Tags
      try {
        const classification = JSON.parse(classificationText);
        this.cacheClassification(prompt, classification);
        return classification;
      } catch (e) {
        console.log('Failed to parse classification, using intelligent fallback');
      }
      
    } catch (error) {
      console.error('AI Classification failed:', error);
    }

    // Intelligenter Fallback ohne Keywords
    return this.intelligentFallback(prompt);
  }

  /**
   * Intelligenter Fallback basierend auf Satzstruktur statt Keywords
   */
  intelligentFallback(prompt) {
    console.log('Using intelligent structural fallback');
    
    // Analysiere Satzstruktur
    const isQuestion = prompt.includes('?') || 
                      prompt.toLowerCase().startsWith('was') ||
                      prompt.toLowerCase().startsWith('wie') ||
                      prompt.toLowerCase().startsWith('wo') ||
                      prompt.toLowerCase().startsWith('wer');
    
    const hasNumbers = /\d+/.test(prompt);
    const isShort = prompt.split(' ').length < 5;
    const isGreeting = isShort && !isQuestion;
    
    // Intent-basierte Klassifikation
    if (isGreeting && isShort) {
      return {
        category: 'personal_chat',
        confidence: 0.7,
        intent: 'Greeting or personal interaction',
        data_needs: [],
        suggested_tools: [],
        parameters: {},
        complexity: 'simple',
        reasoning: 'Short non-question indicates greeting'
      };
    }
    
    if (isQuestion && prompt.length > 20) {
      // L√§ngere Fragen deuten auf Datenabfrage hin
      return {
        category: 'data_retrieval',
        confidence: 0.6,
        intent: 'Information request',
        data_needs: ['stammtisch_data'],
        suggested_tools: ['get_stammtische'],
        parameters: {},
        complexity: 'simple',
        reasoning: 'Question format suggests data request'
      };
    }
    
    // Default: data retrieval
    return {
      category: 'data_retrieval',
      confidence: 0.5,
      intent: 'General information request',
      data_needs: ['general_data'],
      suggested_tools: ['get_stammtische'],
      parameters: {},
      complexity: 'simple',
      reasoning: 'Default classification'
    };
  }

  /**
   * Cache-Management f√ºr Performance
   */
  getCachedClassification(prompt) {
    const normalized = prompt.toLowerCase().trim();
    const cached = this.classificationCache.get(normalized);
    
    if (cached && (Date.now() - cached.timestamp < this.cacheMaxAge)) {
      return cached.classification;
    }
    
    return null;
  }

  cacheClassification(prompt, classification) {
    const normalized = prompt.toLowerCase().trim();
    
    // LRU: Entferne √§lteste Eintr√§ge wenn Cache voll
    if (this.classificationCache.size >= this.cacheMaxSize) {
      const firstKey = this.classificationCache.keys().next().value;
      this.classificationCache.delete(firstKey);
    }
    
    this.classificationCache.set(normalized, {
      classification,
      timestamp: Date.now()
    });
  }

  /**
   * INTELLIGENT ORCHESTRATION: Dynamische Task-Planung
   */
  async orchestrateComplexTask(prompt, classification) {
    console.log('=== INTELLIGENT ORCHESTRATOR: Dynamic Planning ===');
    
    const planningPrompt = `Du bist ein intelligenter Task Orchestrator.
Erstelle einen optimalen Ausf√ºhrungsplan basierend auf dem Intent und den Datenbedarfen.

KLASSIFIKATION:
${JSON.stringify(classification, null, 2)}

BENUTZERANFRAGE: ${prompt}

VERF√úGBARE TOOLS:
- get_stammtische: Alle Events abrufen
- search_stammtische: Gezielt suchen
- get_stammtisch_statistics: Statistiken
- get_praesentatoren: Pr√§sentatoren
- get_upcoming_stammtische: Zuk√ºnftige Events

Erstelle einen MINIMALEN aber VOLLST√ÑNDIGEN Plan:

<plan>
[
  {
    "step": 1,
    "tool": "tool_name",
    "parameters": {},
    "purpose": "Warum dieser Schritt",
    "expected_output": "Was wir erwarten"
  }
]
</plan>

WICHTIG: Nutze nur die minimal n√∂tigen Tools!`;

    try {
      const { OrchestrationClient } = await import('@sap-ai-sdk/orchestration');
      const client = new OrchestrationClient({
        llm: { model_name: "gpt-4o-mini" },
        templating: { template: [{ role: 'user', content: '{{?user_prompt}}' }] }
      });

      const response = await client.chatCompletion({
        inputParams: { user_prompt: planningPrompt },
        params: { max_tokens_to_sample: 800, temperature: 0.2 }
      });

      const content = response.getContent();
      const planMatch = content.match(/<plan>([\s\S]*?)<\/plan>/);

      if (planMatch) {
        const plan = JSON.parse(planMatch[1].trim());
        console.log('Execution Plan:', plan);
        
        this.currentPlan = { steps: plan };
        return await this.executePlan(plan);
      }
    } catch (error) {
      console.error('Orchestration failed:', error);
    }

    // Fallback zu suggested tools
    return await this.executeToolsFromClassification(classification);
  }

  /**
   * Tool-Ausf√ºhrung basierend auf Klassifikation
   */
  async executeToolsFromClassification(classification) {
    const results = [];
    
    for (const tool of (classification.suggested_tools || [])) {
      try {
        const result = await this.dbTools.executeTool(
          tool, 
          classification.parameters || {}
        );
        results.push({
          tool,
          result,
          success: true
        });
      } catch (error) {
        results.push({
          tool,
          error: error.message,
          success: false
        });
      }
    }
    
    return results;
  }

  /**
   * SMART RESPONSE GENERATION: Kontextabh√§ngige Antworten
   */
  async generateResponse(prompt, classification, toolResults = []) {
    console.log('=== SMART RESPONSE: Context-aware Generation ===');
    
    // F√ºr personal_chat und help_task keine AI-Generation n√∂tig
    if (classification.category === 'personal_chat') {
      return this.generatePersonalResponse(prompt, classification);
    }
    
    if (classification.category === 'help_task') {
      return this.generateHelpResponse(prompt, classification);
    }
    
    // F√ºr datenbasierte Antworten nutze AI
    const responsePrompt = `Du bist ein hilfreicher Assistant f√ºr die StammtischAI-Anwendung.
Erstelle eine benutzerfreundliche Antwort basierend auf den Daten.

BENUTZERANFRAGE: ${prompt}

INTENT: ${classification.intent}

VERF√úGBARE DATEN:
${JSON.stringify(toolResults, null, 2)}

ANFORDERUNGEN:
- Beantworte die Frage DIREKT und PR√ÑZISE
- Nutze Markdown f√ºr bessere Lesbarkeit
- Sei freundlich aber effizient
- Fokussiere auf die relevanten Informationen
- Keine unn√∂tigen Einleitungen

ANTWORT:`;

    try {
      const { OrchestrationClient } = await import('@sap-ai-sdk/orchestration');
      const client = new OrchestrationClient({
        llm: { model_name: "gpt-4o-mini" },
        templating: { template: [{ role: 'user', content: '{{?user_prompt}}' }] }
      });

      const response = await client.chatCompletion({
        inputParams: { user_prompt: responsePrompt },
        params: { 
          max_tokens_to_sample: 2000, 
          temperature: 0.3,
          presence_penalty: 0.1 // Reduziert Wiederholungen
        }
      });

      return response.getContent();
      
    } catch (error) {
      console.error('Response generation failed:', error);
      return this.generateFallbackResponse(toolResults);
    }
  }

  /**
   * Optimierte Response-Generatoren
   */
  generatePersonalResponse(prompt, classification) {
    const responses = {
      'greeting': `## üëã Hallo! Willkommen bei StammtischAI!

Ich bin Ihr intelligenter Assistant und helfe Ihnen gerne bei allen Fragen zu Ihren Stammtisch-Events.

**Was kann ich f√ºr Sie tun?**
- üìä Daten und Statistiken abrufen
- üîç Nach Events und Teilnehmern suchen
- üìà Analysen und Auswertungen erstellen

Fragen Sie einfach los!`,

      'identity': `## ü§ñ √úber mich

Ich bin der StammtischAI Assistant - ein intelligenter Agent, der speziell f√ºr die Verwaltung und Analyse Ihrer Stammtisch-Events entwickelt wurde.

**Meine F√§higkeiten:**
- Schnelle Datenabfragen
- Intelligente Suche
- Komplexe Analysen
- Hilfreiche Empfehlungen

Wie kann ich Ihnen helfen?`,

      'default': `## üí¨ StammtischAI Assistant

Ich bin hier, um Ihnen bei Ihren Stammtisch-Events zu helfen. Stellen Sie mir gerne eine Frage!`
    };

    // W√§hle passende Antwort basierend auf Intent
    const intentType = classification.intent?.toLowerCase().includes('greet') ? 'greeting' :
                      classification.intent?.toLowerCase().includes('identity') ? 'identity' : 
                      'default';
    
    return responses[intentType];
  }

  generateHelpResponse(prompt, classification) {
    return `## üìö StammtischAI Hilfe

**Verf√ºgbare Funktionen:**

### üìä Daten abrufen
- "Zeige alle Stammtische"
- "Liste der Pr√§sentatoren"
- "Kommende Events"

### üîç Suchen
- "Finde CAP-Workshops"
- "Suche Online-Events"

### üìà Analysen
- "Statistiken anzeigen"
- "Event-Performance analysieren"

### üí° Tipps
- Stellen Sie konkrete Fragen f√ºr beste Ergebnisse
- Ich kann mehrere Datenquellen kombinieren
- Bei komplexen Analysen erstelle ich detaillierte Berichte

**Wie kann ich Ihnen konkret helfen?**`;
  }

  generateFallbackResponse(toolResults) {
    if (!toolResults || toolResults.length === 0) {
      return "Entschuldigung, ich konnte keine Daten zu Ihrer Anfrage finden.";
    }
    
    const successfulResults = toolResults.filter(r => r.success);
    if (successfulResults.length === 0) {
      return "Es gab einen Fehler beim Abrufen der Daten. Bitte versuchen Sie es erneut.";
    }
    
    // Strukturierte Darstellung der Rohdaten
    let response = "## üìä Ergebnisse\n\n";
    successfulResults.forEach((result, index) => {
      response += `### ${result.tool}\n\`\`\`json\n${JSON.stringify(result.result.data, null, 2)}\n\`\`\`\n\n`;
    });
    
    return response;
  }

  /**
   * PERFORMANCE MONITORING
   */
  async evaluatePerformance(response, classification, executionTime) {
    const performance = {
      executionTime,
      classificationConfidence: classification.confidence,
      toolsUsed: classification.suggested_tools?.length || 0,
      complexity: classification.complexity,
      cacheHit: false // wird vom Cache gesetzt
    };

    // Schnelle Selbstbewertung
    if (executionTime > 5000) {
      performance.warning = 'Slow execution detected';
    }
    
    if (classification.confidence < 0.6) {
      performance.warning = 'Low classification confidence';
    }

    return performance;
  }

  /**
   * MAIN PROCESSING mit verbessertem Flow
   */
  async processRequest(prompt) {
    console.log('\n=== ENHANCED AI AGENT: Processing Request ===');
    const startTime = Date.now();
    
    try {
      // Step 1: Intelligente Klassifikation
      const classification = await this.classifyRequest(prompt);
      
      let toolResults = [];
      let response = '';

      // Step 2: Kategorie-basierte Verarbeitung
      switch (classification.category) {
        case 'personal_chat':
        case 'help_task':
          // Direkte Antwort ohne Tools
          response = await this.generateResponse(prompt, classification);
          break;
          
        case 'data_retrieval':
        case 'search_operation':
          // Einfache Tool-Ausf√ºhrung
          toolResults = await this.executeToolsFromClassification(classification);
          response = await this.generateResponse(prompt, classification, toolResults);
          break;
          
        case 'analytical_task':
        case 'complex_workflow':
          // Orchestrierte Ausf√ºhrung
          toolResults = await this.orchestrateComplexTask(prompt, classification);
          response = await this.generateResponse(prompt, classification, toolResults);
          break;
          
        default:
          // Fallback
          toolResults = await this.executeToolsFromClassification(classification);
          response = await this.generateResponse(prompt, classification, toolResults);
      }

      // Step 3: Performance Monitoring
      const executionTime = Date.now() - startTime;
      const performance = await this.evaluatePerformance(response, classification, executionTime);

      // Step 4: Response-Optimierung
      const htmlResponse = MarkdownConverter.convertForStammtischAI(response);

      // Step 5: Logging
      this.logExecution({
        prompt,
        classification,
        performance,
        success: true
      });

      console.log(`Request processed in ${executionTime}ms`);
      return htmlResponse;

    } catch (error) {
      console.error('Agent processing failed:', error);
      
      this.logExecution({
        prompt,
        error: error.message,
        executionTime: Date.now() - startTime,
        success: false
      });

      return this.generateErrorResponse(error);
    }
  }

  /**
   * Plan-Ausf√ºhrung
   */
  async executePlan(steps) {
    console.log('=== Executing Plan ===');
    const results = [];
    
    for (const step of steps) {
      console.log(`Step ${step.step}: ${step.purpose}`);
      
      try {
        const toolResult = await this.dbTools.executeTool(
          step.tool, 
          step.parameters || {}
        );
        
        results.push({
          step: step.step,
          tool: step.tool,
          result: toolResult,
          purpose: step.purpose,
          success: true
        });
        
      } catch (error) {
        console.error(`Step ${step.step} failed:`, error);
        results.push({
          step: step.step,
          tool: step.tool,
          error: error.message,
          success: false
        });
      }
    }
    
    return results;
  }

  /**
   * Error Response
   */
  generateErrorResponse(error) {
    return `## ‚ùå Fehler aufgetreten

Es tut mir leid, aber bei der Verarbeitung ist ein Fehler aufgetreten.

**Fehler:** ${error.message}

**Was Sie tun k√∂nnen:**
- Versuchen Sie es in einem Moment erneut
- Formulieren Sie Ihre Anfrage um
- Kontaktieren Sie den Support bei anhaltenden Problemen

Kann ich Ihnen anderweitig helfen?`;
  }

  /**
   * Execution Logging
   */
  logExecution(details) {
    this.executionHistory.push({
      ...details,
      timestamp: new Date().toISOString()
    });
    
    // Keep last 100 executions
    if (this.executionHistory.length > 100) {
      this.executionHistory = this.executionHistory.slice(-100);
    }
  }

  /**
   * Performance Stats
   */
  getPerformanceStats() {
    const stats = {
      totalRequests: this.executionHistory.length,
      successRate: this.executionHistory.filter(e => e.success).length / this.executionHistory.length,
      averageExecutionTime: 0,
      categoryDistribution: {},
      cacheHitRate: 0
    };

    // Berechne Durchschnitte
    let totalTime = 0;
    let cacheHits = 0;
    
    this.executionHistory.forEach(entry => {
      if (entry.performance?.executionTime) {
        totalTime += entry.performance.executionTime;
      }
      if (entry.performance?.cacheHit) {
        cacheHits++;
      }
      if (entry.classification?.category) {
        stats.categoryDistribution[entry.classification.category] = 
          (stats.categoryDistribution[entry.classification.category] || 0) + 1;
      }
    });

    stats.averageExecutionTime = totalTime / this.executionHistory.length;
    stats.cacheHitRate = cacheHits / this.executionHistory.length;

    return stats;
  }

  /**
   * Cache-Wartung
   */
  clearCache() {
    this.classificationCache.clear();
    console.log('Classification cache cleared');
  }

  pruneCache() {
    const now = Date.now();
    for (const [key, value] of this.classificationCache.entries()) {
      if (now - value.timestamp > this.cacheMaxAge) {
        this.classificationCache.delete(key);
      }
    }
  }
}

module.exports = EnhancedAIAgent;
</file>

<file path="lib/mcp-client.js">
// srv/lib/mcp-client.js

import cds from '@sap/cds';
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const dbConfig = cds.env.requires.db;
let postgresClient = null;
let braveSearchClient = null;
let playwrightClient = null;
let filesystemClient = null;
let excelClient = null; // +++ NEU: Excel Client Variable

function getPostgresUri() {
  const creds = dbConfig.credentials;
  return `postgresql://${creds.user}:${creds.password}@${creds.host}:${creds.port}/${creds.database}`;
}

export async function initPostgresMCPClient() {
  if (postgresClient) return postgresClient;
  console.log(`Initializing PostgreSQL MCP client...`);
  const postgresUri = getPostgresUri();
  const transport = new StdioClientTransport({
    command: "npx",
    args: ["-y", "mcp-postgres-full-access", postgresUri],
  });
  postgresClient = new Client({ name: "postgres-client", version: "1.0.0" }, {});
  await postgresClient.connect(transport);
  console.log("‚úÖ PostgreSQL MCP Client initialized successfully.");
  return postgresClient;
}

export async function initBraveSearchMCPClient() {
  if (braveSearchClient) return braveSearchClient;
  const braveApiKey = process.env.BRAVE_API_KEY || cds.env.BRAVE_API_KEY;
  if (!braveApiKey) throw new Error("BRAVE_API_KEY is required but not provided");
  console.log(`Initializing Brave Search MCP client...`);
  const transport = new StdioClientTransport({
    command: "npx",
    args: ["-y", "@modelcontextprotocol/server-brave-search"],
    env: { ...process.env, BRAVE_API_KEY: braveApiKey }
  });
  braveSearchClient = new Client({ name: "brave-search-client", version: "1.0.0" }, {});
  await braveSearchClient.connect(transport);
  console.log("‚úÖ Brave Search MCP Client initialized successfully.");
  return braveSearchClient;
}

export async function initPlaywrightMCPClient() {
  if (playwrightClient) return playwrightClient;
  console.log(`Initializing Playwright MCP client...`);
  const transport = new StdioClientTransport({
    command: "npx",
    args: ["-y", "@executeautomation/playwright-mcp-server"],
    env: {
      ...process.env,
      PLAYWRIGHT_BROWSER: process.env.PLAYWRIGHT_BROWSER || "chromium",
      PLAYWRIGHT_HEADLESS: process.env.PLAYWRIGHT_HEADLESS || "true"
    }
  });
  playwrightClient = new Client({ name: "playwright-client", version: "1.0.0" }, {});
  await playwrightClient.connect(transport);
  console.log("‚úÖ Playwright MCP Client initialized successfully.");
  return playwrightClient;
}

export async function initFilesystemMCPClient() {
  if (filesystemClient) return filesystemClient;
  console.log(`Initializing Filesystem MCP client...`);
  const allowedDirectory = process.cwd();
  console.log(`Filesystem access is sandboxed to: ${allowedDirectory}`);
  const transport = new StdioClientTransport({
    command: "npx",
    args: ["-y", "@modelcontextprotocol/server-filesystem", allowedDirectory, "C:/Users/HoangDuong/Desktop/StammtischAI"]
  });
  filesystemClient = new Client({ name: "filesystem-client", version: "1.0.0" }, {});
  await filesystemClient.connect(transport);
  console.log("‚úÖ Filesystem MCP Client initialized successfully.");
  return filesystemClient;
}

// +++ NEUE FUNKTION: Excel MCP Client initialisieren +++
export async function initExcelMCPClient() {
  if (excelClient) return excelClient;

  console.log(`Initializing Excel MCP client...`);

  // Konfiguration basierend auf der README des Excel MCP Servers.
  // Diese Konfiguration ist f√ºr Windows. F√ºr andere Plattformen (macOS/Linux)
  // w√§re der Befehl: { command: "npx", args: ["--yes", "@negokaz/excel-mcp-server"] }
  const transport = new StdioClientTransport({
    command: "cmd",
    args: ["/c", "npx", "--yes", "@negokaz/excel-mcp-server"],
    env: {
      ...process.env,
      EXCEL_MCP_PAGING_CELLS_LIMIT: "4000" // Wie im Beispiel der README
    }
  });

  excelClient = new Client({ name: "excel-client", version: "1.0.0" }, {});
  await excelClient.connect(transport);
  console.log("‚úÖ Excel MCP Client initialized successfully.");
  return excelClient;
}


export async function initAllMCPClients() {
  console.log("Initializing all MCP clients...");
  
  // +++ ERWEITERT: Excel Client wird mit initialisiert +++
  const [pgClient, braveClient, playwrightClient, fsClient, xlsxClient] = await Promise.all([
    initPostgresMCPClient(),
    initBraveSearchMCPClient(),
    initPlaywrightMCPClient(),
    initFilesystemMCPClient(),
    initExcelMCPClient() // Neuer Client
  ]);

  return {
    postgres: pgClient,
    braveSearch: braveClient,
    playwright: playwrightClient,
    filesystem: fsClient,
    excel: xlsxClient, // Neuer Client im R√ºckgabeobjekt
  };
}

export async function closeMCPClients() {
  const closePromises = [];
  
  if (postgresClient) {
    console.log("Closing PostgreSQL MCP client connection");
    closePromises.push(postgresClient.close());
    postgresClient = null;
  }
  if (braveSearchClient) {
    console.log("Closing Brave Search MCP client connection");
    closePromises.push(braveSearchClient.close());
    braveSearchClient = null;
  }
  if (playwrightClient) {
    console.log("Closing Playwright MCP client connection");
    closePromises.push(playwrightClient.close());
    playwrightClient = null;
  }
  if (filesystemClient) {
    console.log("Closing Filesystem MCP client connection");
    closePromises.push(filesystemClient.close());
    filesystemClient = null;
  }
  // +++ ERWEITERT: Excel Client wird geschlossen +++
  if (excelClient) {
    console.log("Closing Excel MCP client connection");
    closePromises.push(excelClient.close());
    excelClient = null;
  }
  
  await Promise.all(closePromises);
  console.log("‚úÖ All MCP clients closed");
}

// Backward compatibility
export const initMCPClient = initPostgresMCPClient;
export const closeMCPClient = closeMCPClients;
</file>

<file path="prompts/assistant-prompt.js">
// prompts/assistant-prompt.js
/**
 * System Prompt f√ºr den StammtischAI Assistant
 * Hier k√∂nnen Sie den AI-Assistant Prompt zentral verwalten
 */

const SYSTEM_PROMPT = `Du bist ein intelligenter AI-Agent f√ºr die SAP CAP Anwendung "StammtischAI", entwickelt mit SAP Cloud Application Programming Model. Du hilfst Benutzern dabei, die Anwendung effektiv zu bedienen und hast direkten Zugriff auf die Datenbank.

## Deine Rolle und Pers√∂nlichkeit
- Du bist ein freundlicher, kompetenter SAP-Experte mit Datenbankzugriff
- Du sprichst Deutsch und verwendest SAP-Terminologie korrekt
- Du hilfst proaktiv und gibst strukturierte, datenbasierte Antworten
- Du kennst die Anwendung im Detail und kannst auf Live-Daten zugreifen
- Du bist ein AI-Agent mit Tools - nicht nur ein Chatbot

## Anwendungskontext: StammtischAI

### Zweck der Anwendung
Die StammtischAI-Anwendung verwaltet regelm√§√üige Fachvortr√§ge und Networking-Events ("Stammtische") mit folgenden Hauptfunktionen:
- Verwaltung von Stammtisch-Events mit Thema, Datum, Ort
- Verwaltung von Pr√§sentatoren mit Kontaktdaten
- Verwaltung von Teilnehmern pro Event
- AI-basierte Unterst√ºtzung mit Datenbankzugriff

### Agent-F√§higkeiten
Du kannst direkt auf diese Daten zugreifen:
- **Stammtische**: Alle Events, Details, Suche
- **Pr√§sentatoren**: Referenten-Informationen, Aktivit√§ten
- **Teilnehmer**: Anmeldungen pro Event
- **Statistiken**: Live-Auswertungen, Trends
- **Kommende Events**: Zukunftsplanung

### Datenmodell
Entit√§ten mit Live-Zugriff:
1. **Stammtische** (Hauptentit√§t)
   - ID, Thema, Datum, Ort, Notizen
   - Verkn√ºpfung zu einem Pr√§sentator
   - Komposition von Teilnehmern

2. **Pr√§sentatoren**
   - Name, E-Mail, LinkedIn-Profil
   - K√∂nnen mehrere Stammtische halten

3. **Teilnehmer**
   - Name, E-Mail
   - Zugeordnet zu einem Stammtisch

## Agent-Verhalten

### Datenbasierte Antworten
- **Immer aktuelle Daten verwenden**, wenn verf√ºgbar
- **Konkrete Zahlen und Details** aus der Datenbank nennen
- **Live-Statistiken** bei Bedarf abrufen
- **Spezifische Events** suchen und anzeigen

### Beispiel-Interaktionen

**Benutzer fragt**: "Wie viele Stammtische haben wir?"
**Du antwortest**: 

üìä **Aktuelle Stammtisch-Statistiken** (Live-Daten):

- **Gesamte Stammtische**: 47 Events
- **Aktive Pr√§sentatoren**: 12 Referenten
- **Gesamte Teilnehmer**: 284 Anmeldungen

**Top-Veranstaltungsorte:**
1. SAP Walldorf (23 Events)
2. Online (15 Events)
3. M√ºnchen (9 Events)

**Benutzer fragt**: "Suche nach CAP Workshops"
**Du antwortest**:

üîç **Suchergebnisse f√ºr "CAP Workshops":**

**Gefundene Stammtische (3 Ergebnisse):**

1. **"Einf√ºhrung in SAP CAP"**
   - üìÖ 26. Oktober 2023, 19:00
   - üìç SAP Walldorf WDF01
   - üë§ Max Mustermann

2. **"CAP Best Practices"**
   - üìÖ 15. November 2023, 18:30
   - üìç Online
   - üë§ Erika Beispiel

### Kommunikation

#### Antwortstil
- Verwende klare, strukturierte Antworten mit Live-Daten
- Nutze Markdown-Formatierung f√ºr bessere Lesbarkeit
- Gib konkrete Schritte und aktuelle Beispiele
- Verwende SAP-Fachbegriffe korrekt
- **Verweise immer auf Datenquelle** bei faktischen Aussagen

#### Hilfebereiche mit Datenzugriff

##### 1. Navigation und Bedienung mit aktuellen Daten

**Navigation in StammtischAI:**
- **Startseite**: List Report mit [AKTUELLE ANZAHL] Stammtischen
- **N√§chster Event**: [N√ÑCHSTES DATUM UND THEMA]
- **Stammtisch √∂ffnen**: Klick auf eine Zeile ‚Üí Object Page
- **AI Agent**: Ich kann Ihnen Live-Daten zu allem liefern!

##### 2. Datenmanagement mit Beispielen
- Erkl√§rung mit konkreten Daten aus der DB
- Referenz auf bestehende Pr√§sentatoren
- Live-Beispiele von Teilnehmer-Anmeldungen

##### 3. Suchfunktionen mit Ergebnissen
- Smart Filter mit aktuellen Werten
- Live-Suchbeispiele aus der Datenbank
- Export mit tats√§chlichen Datenmengen

## Erweiterte Agent-Funktionen

### Proaktive Datenanalyse
- **Trends erkennen**: "Ich sehe, dass Online-Events zunehmen..."
- **Empfehlungen geben**: "Basierend auf den Daten empfehle ich..."
- **Probleme identifizieren**: "Die Teilnehmerzahl ist bei Event X niedrig..."

### Intelligente Suche
- **Fuzzy Search**: Auch bei Tippfehlern helfen
- **Kontextuelle Suche**: √Ñhnliche Events vorschlagen
- **Multi-Parameter**: Nach Datum, Ort, Thema gleichzeitig suchen

## Wichtige Agent-Regeln

### Daten-Priorit√§t
1. **Live-Daten haben Vorrang** vor allgemeinen Aussagen
2. **Immer Datenquelle angeben**: "Laut aktuellen Datenbank-Daten..."
3. **Bei fehlenden Daten**: Klar kommunizieren was nicht verf√ºgbar ist
4. **Datenqualit√§t**: Auf unvollst√§ndige/alte Daten hinweisen

### Fehlerbehandlung
- **Tool-Fehler transparent machen**: "Datenbankzugriff fehlgeschlagen..."
- **Fallback anbieten**: "Ich kann Ihnen stattdessen bei... helfen"
- **Retry vorschlagen**: "Versuchen Sie es in einem Moment erneut"

### Responsivit√§t
- **Schnelle Antworten** bei einfachen Datenabfragen
- **Detaillierte Analysen** bei komplexen Fragen
- **Strukturierte Ausgabe** bei gro√üen Datenmengen

Wenn du spezifische Fragen zur StammtischAI-Anwendung oder deren Daten hast, bin ich hier, um zu helfen! Teile mir mit, welche Informationen du ben√∂tigst - ich habe direkten Zugriff auf alle aktuellen Daten.

**Wichtige Agent-Hinweise:**
- Antworte immer h√∂flich und professionell
- Nutze Live-Daten wann immer m√∂glich
- Gib konkrete, umsetzbare Hilfestellungen mit aktuellen Beispielen
- Erkl√§re SAP-Begriffe f√ºr weniger erfahrene Benutzer
- Frage nach, wenn etwas unklar ist
- Bei technischen Problemen: Datenbank-Tools erw√§hnen
- Verweise bei Agent-Fehlern an den Administrator`;

/**
 * Zus√§tzliche Prompts f√ºr spezielle Situationen
 */
const PROMPTS = {
  // Standard System Prompt
  system: SYSTEM_PROMPT,
  
  // Kurzer Prompt f√ºr einfache Fragen
  simple: `Du bist ein SAP-Experte f√ºr die StammtischAI-Anwendung. Beantworte Fragen klar und pr√§zise auf Deutsch. Die App verwaltet Stammtisch-Events, Pr√§sentatoren und Teilnehmer mit SAP Fiori Elements UI.`,
  
  // Technical Support Prompt
  technical: `${SYSTEM_PROMPT}

**ZUS√ÑTZLICH - Technischer Support Modus:**
- Fokus auf technische Probleme und Debugging
- Detaillierte Erkl√§rungen zu CAP, OData, und SAP UI5
- Code-Beispiele und Konfigurationshilfen
- Datenbankverbindung und Performance-Optimierung`,

  // Training Mode f√ºr neue Benutzer
  training: `${SYSTEM_PROMPT}

**ZUS√ÑTZLICH - Trainings-Modus:**
- Besonders ausf√ºhrliche Erkl√§rungen
- Grundlagen von SAP Fiori Elements erkl√§ren
- Schritt-f√ºr-Schritt Anleitungen mit Screenshots-Beschreibungen
- Geduldig bei Nachfragen
- Motivation und Ermutigung f√ºr neue Benutzer`
};

/**
 * Prompt Builder f√ºr verschiedene Kontexte
 */
class PromptBuilder {
  static getPrompt(mode = 'system', userContext = {}) {
    let prompt = PROMPTS[mode] || PROMPTS.system;
    
    // Kontext-spezifische Anpassungen
    if (userContext.currentPage) {
      prompt += `\n\n**AKTUELLER KONTEXT:** Der Benutzer befindet sich auf der "${userContext.currentPage}" Seite.`;
    }
    
    if (userContext.hasError) {
      prompt += `\n\n**FEHLERSITUATION:** Der Benutzer hat m√∂glicherweise ein technisches Problem. Fokussiere auf Probleml√∂sung.`;
    }
    
    return prompt;
  }
  
  static buildPromptWithUserMessage(userMessage, mode = 'system', userContext = {}) {
    const systemPrompt = this.getPrompt(mode, userContext);
    return `${systemPrompt}\n\n**Benutzeranfrage:** ${userMessage}`;
  }
}

module.exports = {
  SYSTEM_PROMPT,
  PROMPTS,
  PromptBuilder
};
</file>

<file path="prompts/prompt-config.json">
{
  "modes": {
    "system": {
      "description": "Standard AI Assistant",
      "maxTokens": 2000,
      "temperature": 0.3
    },
    "technical": {
      "description": "Technischer Support",
      "maxTokens": 3000,
      "temperature": 0.2
    },
    "training": {
      "description": "Benutzer-Training",
      "maxTokens": 2500,
      "temperature": 0.4
    },
    "simple": {
      "description": "Einfache Antworten",
      "maxTokens": 1000,
      "temperature": 0.3
    }
  },
  "features": {
    "emojiEnhancement": true,
    "germanTranslation": true,
    "contextAwareness": true,
    "errorHandling": true
  },
  "debugging": {
    "logFullPrompts": false,
    "logResponses": true,
    "logErrors": true
  }
}
</file>

<file path="service.cds">
using { sap.stammtisch as StammtischModel } from '../db/schema';
using from '../app/annotations'; 

service StammtischService @(path: '/service/stammtisch') { 

    @odata.draft.enabled // Aktiviere Draft-Modus f√ºr diese Entit√§t
    entity Stammtische as projection on StammtischModel.Stammtische {
        *,
        // Navigation Properties explizit exponieren
        praesentator : redirected to Praesentatoren,
        teilnehmer : redirected to Teilnehmer
    };

    entity Praesentatoren as projection on StammtischModel.Praesentatoren {
        *,
        stammtische : redirected to Stammtische
    };
    
    entity Teilnehmer as projection on StammtischModel.Teilnehmer {
        *,
        stammtisch : redirected to Stammtische
    };

    action callLLM (prompt: String) returns { response: String };

}
</file>

<file path="service.js">
// srv/StammtischService.js

import cds from '@sap/cds';
import { loadMcpTools } from '@langchain/mcp-adapters';
import { createReactAgent } from "@langchain/langgraph/prebuilt";
import { AzureOpenAiChatClient } from "@sap-ai-sdk/langchain";
import { MemorySaver } from "@langchain/langgraph-checkpoint";
import { initAllMCPClients, closeMCPClients } from './lib/mcp-client.js';
import MarkdownConverter from './utils/markdown-converter.js';

export default class StammtischService extends cds.ApplicationService {
  async init() {
    await super.init();
    let agentExecutor = null;
    let mcpClients = null;

    const initializeAgent = async () => {
      if (agentExecutor) return agentExecutor;

      // +++ ERWEITERT: Log-Nachricht angepasst +++
      console.log("Initializing Agent with Database, Web Search, Browser, Filesystem and Excel capabilities...");

      try {
        mcpClients = await initAllMCPClients();

        // +++ ERWEITERT: Lade Tools vom neuen Excel Client +++
        const [postgresTools, braveSearchTools, playwrightTools, filesystemTools, excelTools] = await Promise.all([
          loadMcpTools("query", mcpClients.postgres),
          loadMcpTools("brave_web_search,brave_local_search", mcpClients.braveSearch),
          loadMcpTools("take_screenshot,goto_page,click_element,fill_input,execute_javascript,get_page_content,wait_for_element,generate_test_code", mcpClients.playwright),
          loadMcpTools("read_file,write_file,edit_file,create_directory,list_directory,move_file,search_files,get_file_info,list_allowed_directories", mcpClients.filesystem),
          // +++ NEU: Lade alle verf√ºgbaren Excel-Tools +++
          loadMcpTools("excel_describe_sheets,excel_read_sheet,excel_screen_capture,excel_write_to_sheet,excel_create_table,excel_copy_sheet", mcpClients.excel)
        ]);

        // Kombiniere alle Tools
        const allTools = [...postgresTools, ...braveSearchTools, ...playwrightTools, ...filesystemTools, ...excelTools];

        // +++ ERWEITERT: Log-Nachricht angepasst +++
        console.log(`‚úÖ Loaded ${postgresTools.length} PostgreSQL, ${braveSearchTools.length} Brave Search, ${playwrightTools.length} Playwright, ${filesystemTools.length} Filesystem, and ${excelTools.length} Excel tools`);
        console.log("Available tools:", allTools.map(tool => tool.name));

        const llm = new AzureOpenAiChatClient({ modelName: 'gpt-4.1' });
        const checkpointer = new MemorySaver();

        agentExecutor = createReactAgent({
          llm,
          tools: allTools,
          checkpointSaver: checkpointer
        });
        
        // +++ ERWEITERT: Log-Nachricht angepasst +++
        console.log("‚úÖ Multi-Modal Agent is ready (Database + Web Search + Browser + Filesystem + Excel).");
        return agentExecutor;

      } catch (error) {
        console.error("‚ùå Failed to initialize agent:", error);
        throw error;
      }
    };

    await initializeAgent();

    this.on('callLLM', async (req) => {
      const { prompt: userPrompt } = req.data;
      if (!userPrompt) {
        req.error(400, 'Prompt is required');
        return;
      }

      console.log('üöÄ Received prompt for Multi-Modal Agent:', userPrompt);
      const executor = await initializeAgent();

      try {
        const systemMessage = {
          role: "system",
          content: `You are a helpful assistant with access to database queries, web search, browser automation, local filesystem, and MS Excel capabilities.

                  DATABASE ACCESS:
                  - You can query a PostgreSQL database using the 'query' tool.
                  - IMPORTANT: Use PostgreSQL syntax.

                  WEB SEARCH ACCESS:
                  - You can search the web using 'brave_web_search'. 

                  BROWSER AUTOMATION ACCESS (Playwright):
                  - You can control a web browser to perform tasks like testing web applications.

                  FILESYSTEM ACCESS:
                  - You can read, write, and manage files and directories in the project.
                  - SECURITY: You can ONLY operate within the allowed project directory.
                  - Use 'list_directory' with '.' or a subdirectory to see available files first.
                  - For 'edit_file', ALWAYS use 'dryRun: true' first to preview changes.

                  EXCEL ACCESS:
                  - You can read from and write to MS Excel files (.xlsx, .xlsm, etc.).
                  - Available tools: excel_describe_sheets, excel_read_sheet, excel_write_to_sheet, excel_create_table, excel_copy_sheet, excel_screen_capture (Windows only).
                  - ALWAYS start by using 'excel_describe_sheets' to understand the file's structure (sheet names).
                  - For all Excel tools, you MUST provide the 'fileAbsolutePath' to the target Excel file.
                  - When reading large sheets, the tool uses pagination. Pay attention to the 'knownPagingRanges' argument to read subsequent parts.
                  - When writing with 'excel_write_to_sheet', you can create a new sheet by setting 'newSheet: true'. Be careful as writing can modify files permanently.

                  ANALYSIS & VISUALIZATION WORKFLOW:
                  - If the user asks for an "analysis", "report", or "visualization" of data, you MUST follow this specific workflow:
                  1.  **Query Data:** First, use the 'query' tool to retrieve the necessary data from the PostgreSQL database. If the user's request is ambiguous (e.g., "analyze the data"), ask clarifying questions to determine which tables and columns are relevant for the analysis.
                  2.  **Generate HTML File:** After successfully retrieving the data, you will generate a single, self-contained HTML file to present the analysis and visualization.
                      -   **Structure:** Create a well-structured HTML5 document.
                      -   **Styling:** Include some basic CSS in a <style> tag in the <head> for a clean and professional look (e.g., set a modern font, center content, add padding).
                      -   **Visualization Library:** You MUST use a JavaScript charting library like **Chart.js** to create professional-looking charts (e.g., bar charts, line charts, pie charts). Include the library via its CDN link in a <script> tag in the <head>. Example: <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
                      -   **Content:** The HTML body should contain:
                          -   A clear headline (<h1>) describing the analysis (e.g., "Analyse der monatlichen Ums√§tze").
                          -   A <canvas> element where the chart will be rendered.
                          -   A <script> block at the end of the body. Inside this script, you will:
                              a) Store the data retrieved from the database in a JavaScript variable.
                              b) Write the JavaScript code to initialize Chart.js and render the chart on the canvas, using the data.
                  3.  **Save the File:** Use the 'edit_file' tool to write the complete HTML code into a new file.
                  4.  **Report Back:** Finally, after the file has been successfully created, inform the user that the analysis is complete and provide the full, correct path to the generated HTML file so they can open it.

                  RESPONSE GUIDELINES:
                   - First, determine which tool or combination of tools is best for the user's request.
              - Clearly explain your plan before executing it.
              - Combine information from different sources clearly, distinguishing between database results, web content, file content, and Excel data.
              - Always provide context about where information is coming from.
                    `
                      };

        const userMessage = {
          role: "user",
          content: userPrompt
        };
        
        const stream = await executor.stream(
          {
            messages: [systemMessage, userMessage]
          },
          {
            configurable: { thread_id: `session_test}` }
          }
        );

        const finalResponseParts = [];
        console.log("\n\n---- AGENT STREAM START ----\n");

        for await (const chunk of stream) {
          if (chunk.agent?.messages) {
            const message = chunk.agent.messages[chunk.agent.messages.length - 1];
            if (message && message.content) {
              process.stdout.write(message.content);
              finalResponseParts.push(message.content);
            }
            if (message.tool_calls && message.tool_calls.length > 0) {
              const toolCall = message.tool_calls[0];
              const toolCallStr = `\n\n<TOOL_CALL>\n  Tool: ${toolCall.name}\n  Args: ${JSON.stringify(toolCall.args)}\n</TOOL_CALL>\n\n`;
              process.stdout.write(toolCallStr);
            }
          }

          if (chunk.tools?.messages) {
             const toolMessage = chunk.tools.messages[0];
             const toolOutputStr = `<TOOL_OUTPUT>\n  ${toolMessage.content}\n</TOOL_OUTPUT>\n\n`;
             process.stdout.write(toolOutputStr);
          }
        }
        console.log("\n---- AGENT STREAM END ----\n");

        const rawResponse = finalResponseParts.join("");
        const htmlResponse = MarkdownConverter.convertForStammtischAI(rawResponse);

        return { response: htmlResponse };

      } catch (error) {
        console.error('üí• Error during agent execution:', error);
        req.error(500, `Failed to process query: ${error.message}`);
      }
    });

    this.on('EXIT', async () => {
      console.log('Shutting down MCP clients...');
      await closeMCPClients();
    });
  }
}
</file>

<file path="tools/database-tools.js">
// srv/tools/database-tools.js - Verbesserte Version
/**
 * Database Tools f√ºr den StammtischAI Agent
 * Moderne CDS-Syntax ohne deprecated APIs
 */

const cds = require('@sap/cds');

class DatabaseTools {
  
  constructor() {
    this.tools = {
      'get_stammtische': this.getStammtische.bind(this),
      'get_stammtisch_by_id': this.getStammtischById.bind(this),
      'search_stammtische': this.searchStammtische.bind(this),
      'get_praesentatoren': this.getPraesentatoren.bind(this),
      'get_teilnehmer': this.getTeilnehmer.bind(this),
      'get_stammtisch_statistics': this.getStammtischStatistics.bind(this),
      'get_upcoming_stammtische': this.getUpcomingStammtische.bind(this)
    };
  }

  /**
   * Hauptmethode: F√ºhrt ein Tool aus
   */
  async executeTool(toolName, parameters = {}) {
    console.log(`=== Executing Tool: ${toolName} ===`);
    console.log('Parameters:', parameters);

    if (!this.tools[toolName]) {
      throw new Error(`Tool '${toolName}' not found. Available tools: ${Object.keys(this.tools).join(', ')}`);
    }

    try {
      const result = await this.tools[toolName](parameters);
      console.log(`Tool ${toolName} executed successfully`);
      return {
        success: true,
        tool: toolName,
        data: result,
        message: `Tool ${toolName} executed successfully`
      };
    } catch (error) {
      console.error(`Error executing tool ${toolName}:`, error);
      return {
        success: false,
        tool: toolName,
        error: error.message,
        message: `Error executing tool ${toolName}: ${error.message}`
      };
    }
  }

  /**
   * Tool: Alle Stammtische abrufen
   */
  async getStammtische(params = {}) {
    const { limit = 10, offset = 0 } = params;
    
    const query = SELECT.from('sap.stammtisch.Stammtische')
      .columns(['ID', 'thema', 'datum', 'ort', 'notizen'])
      .limit(limit, offset)
      .orderBy('datum desc');

    const result = await cds.run(query);
    
    return {
      count: result.length,
      stammtische: result.map(s => ({
        id: s.ID,
        thema: s.thema,
        datum: s.datum,
        ort: s.ort,
        notizen: s.notizen ? s.notizen.substring(0, 100) + '...' : null
      }))
    };
  }

  /**
   * Tool: Einzelnen Stammtisch abrufen
   */
  async getStammtischById(params) {
    const { id } = params;
    
    if (!id) {
      throw new Error('Parameter "id" is required');
    }

    const query = SELECT.from('sap.stammtisch.Stammtische')
      .where({ ID: id })
      .columns(['ID', 'thema', 'datum', 'ort', 'notizen', 'praesentator_ID']);

    const result = await cds.run(query);

    if (!result || result.length === 0) {
      throw new Error(`Stammtisch with ID ${id} not found`);
    }

    const stammtisch = result[0];

    // Pr√§sentator-Daten laden
    if (stammtisch.praesentator_ID) {
      const praesentatorQuery = SELECT.from('sap.stammtisch.Praesentatoren')
        .where({ ID: stammtisch.praesentator_ID })
        .columns(['name', 'email', 'linkedin']);
      
      const praesentator = await cds.run(praesentatorQuery);
      stammtisch.praesentator = praesentator[0] || null;
    }

    // Teilnehmer laden
    const teilnehmerQuery = SELECT.from('sap.stammtisch.Teilnehmer')
      .where({ stammtisch_ID: id })
      .columns(['ID', 'name', 'email']);
    
    const teilnehmer = await cds.run(teilnehmerQuery);
    stammtisch.teilnehmer = teilnehmer;

    return stammtisch;
  }

  /**
   * Tool: Stammtische suchen - SICHERE VERSION
   */
  async searchStammtische(params) {
    const { query: searchQuery, limit = 10 } = params;
    
    if (!searchQuery) {
      throw new Error('Parameter "query" is required');
    }

    console.log(`Searching for: "${searchQuery}"`);

    // Option 1: Sichere Parametrisierte Query
    try {
      // Verwende mehrere einzelne WHERE-Bedingungen mit OR
      const result = await cds.run(
        SELECT.from('sap.stammtisch.Stammtische')
          .columns(['ID', 'thema', 'datum', 'ort'])
          .where(
            { thema: { like: `%${searchQuery}%` } },
            'or',
            { ort: { like: `%${searchQuery}%` } },
            'or', 
            { notizen: { like: `%${searchQuery}%` } }
          )
          .limit(limit)
          .orderBy('datum desc')
      );

      console.log(`Search found ${result.length} results`);
      
      return {
        searchQuery,
        count: result.length,
        results: result
      };

    } catch (error) {
      console.warn('Parametrisierte Query fehlgeschlagen, versuche Alternative:', error.message);
      
      // Option 2: Alternative mit separaten Queries
      return await this.searchStammtischeAlternative(searchQuery, limit);
    }
  }

  /**
   * Alternative Such-Implementierung
   */
  async searchStammtischeAlternative(searchQuery, limit = 10) {
    console.log('Using alternative search method');
    
    try {
      // Alle Stammtische laden und client-seitig filtern
      const allStammtische = await cds.run(
        SELECT.from('sap.stammtisch.Stammtische')
          .columns(['ID', 'thema', 'datum', 'ort', 'notizen'])
          .orderBy('datum desc')
      );

      // Client-seitige Filterung
      const searchLower = searchQuery.toLowerCase();
      const filtered = allStammtische.filter(s => 
        (s.thema && s.thema.toLowerCase().includes(searchLower)) ||
        (s.ort && s.ort.toLowerCase().includes(searchLower)) ||
        (s.notizen && s.notizen.toLowerCase().includes(searchLower))
      ).slice(0, limit);

      console.log(`Alternative search found ${filtered.length} results`);

      return {
        searchQuery,
        count: filtered.length,
        results: filtered.map(s => ({
          ID: s.ID,
          thema: s.thema,
          datum: s.datum,
          ort: s.ort
        }))
      };

    } catch (error) {
      console.error('Alternative search failed:', error);
      throw new Error(`Search failed: ${error.message}`);
    }
  }

  /**
   * Tool: Alle Pr√§sentatoren abrufen
   */
  async getPraesentatoren(params = {}) {
    const { limit = 20 } = params;
    
    const query = SELECT.from('sap.stammtisch.Praesentatoren')
      .columns(['ID', 'name', 'email', 'linkedin'])
      .limit(limit);

    const result = await cds.run(query);
    
    return {
      count: result.length,
      praesentatoren: result
    };
  }

  /**
   * Tool: Teilnehmer f√ºr einen Stammtisch abrufen
   */
  async getTeilnehmer(params) {
    const { stammtischId } = params;
    
    if (!stammtischId) {
      throw new Error('Parameter "stammtischId" is required');
    }

    const query = SELECT.from('sap.stammtisch.Teilnehmer')
      .where({ stammtisch_ID: stammtischId })
      .columns(['ID', 'name', 'email']);

    const result = await cds.run(query);
    
    return {
      stammtischId,
      count: result.length,
      teilnehmer: result
    };
  }

  /**
   * Tool: Statistiken abrufen
   */
  async getStammtischStatistics(params = {}) {
    try {
      // Gesamtanzahl Stammtische
      const totalStammtische = await cds.run(
        SELECT.one(['count(*) as total']).from('sap.stammtisch.Stammtische')
      );

      // Gesamtanzahl Teilnehmer
      const totalTeilnehmer = await cds.run(
        SELECT.one(['count(*) as total']).from('sap.stammtisch.Teilnehmer')
      );

      // Gesamtanzahl Pr√§sentatoren
      const totalPraesentatoren = await cds.run(
        SELECT.one(['count(*) as total']).from('sap.stammtisch.Praesentatoren')
      );

      // Stammtische nach Ort - vereinfacht
      const stammtischeByOrt = await cds.run(
        SELECT(['ort', 'count(*) as anzahl'])
          .from('sap.stammtisch.Stammtische')
          .groupBy('ort')
          .orderBy('anzahl desc')
          .limit(10)
      );

      // Aktivste Pr√§sentatoren - vereinfacht f√ºr bessere Kompatibilit√§t
      let aktivePraesentatoren = [];
      try {
        aktivePraesentatoren = await cds.run(
          SELECT(['p.name', 'count(s.ID) as stammtische_count'])
            .from('sap.stammtisch.Praesentatoren as p')
            .join('sap.stammtisch.Stammtische as s').on('s.praesentator_ID = p.ID')
            .groupBy('p.ID', 'p.name')
            .orderBy('stammtische_count desc')
            .limit(5)
        );
      } catch (joinError) {
        console.warn('JOIN query failed, using alternative approach:', joinError.message);
        // Fallback: Lade alle Daten und berechne client-seitig
        aktivePraesentatoren = await this.calculateActivePresentersAlternative();
      }

      return {
        summary: {
          totalStammtische: totalStammtische.total || 0,
          totalTeilnehmer: totalTeilnehmer.total || 0,
          totalPraesentatoren: totalPraesentatoren.total || 0
        },
        stammtischeByOrt: stammtischeByOrt || [],
        aktivePraesentatoren: aktivePraesentatoren || []
      };

    } catch (error) {
      console.error('Statistics query failed:', error);
      throw new Error(`Failed to get statistics: ${error.message}`);
    }
  }

  /**
   * Alternative Berechnung f√ºr aktivste Pr√§sentatoren
   */
  async calculateActivePresentersAlternative() {
    try {
      const praesentatoren = await cds.run(
        SELECT.from('sap.stammtisch.Praesentatoren').columns(['ID', 'name'])
      );
      
      const stammtische = await cds.run(
        SELECT.from('sap.stammtisch.Stammtische').columns(['praesentator_ID'])
      );

      // Client-seitige Aggregation
      const counts = {};
      stammtische.forEach(s => {
        if (s.praesentator_ID) {
          counts[s.praesentator_ID] = (counts[s.praesentator_ID] || 0) + 1;
        }
      });

      // Top 5 aktivste Pr√§sentatoren
      const result = praesentatoren
        .map(p => ({
          name: p.name,
          stammtische_count: counts[p.ID] || 0
        }))
        .filter(p => p.stammtische_count > 0)
        .sort((a, b) => b.stammtische_count - a.stammtische_count)
        .slice(0, 5);

      console.log('Alternative presenter calculation successful');
      return result;

    } catch (error) {
      console.error('Alternative presenter calculation failed:', error);
      return [];
    }
  }

  /**
   * Tool: Kommende Stammtische abrufen
   */
  async getUpcomingStammtische(params = {}) {
    const { limit = 5 } = params;
    const now = new Date().toISOString();

    try {
      const query = SELECT.from('sap.stammtisch.Stammtische')
        .where({ datum: { '>=': now } })
        .columns(['ID', 'thema', 'datum', 'ort'])
        .orderBy('datum asc')
        .limit(limit);

      const result = await cds.run(query);
      
      return {
        count: result.length,
        upcomingStammtische: result
      };

    } catch (error) {
      console.warn('Date query failed, using alternative approach:', error.message);
      
      // Alternative: Alle Stammtische laden und client-seitig filtern
      const allStammtische = await cds.run(
        SELECT.from('sap.stammtisch.Stammtische')
          .columns(['ID', 'thema', 'datum', 'ort'])
          .orderBy('datum asc')
      );

      const upcoming = allStammtische
        .filter(s => s.datum && new Date(s.datum) >= new Date())
        .slice(0, limit);

      return {
        count: upcoming.length,
        upcomingStammtische: upcoming
      };
    }
  }

  /**
   * Gibt verf√ºgbare Tools zur√ºck
   */
  getAvailableTools() {
    return {
      'get_stammtische': {
        description: 'Ruft alle Stammtische ab',
        parameters: {
          limit: 'Anzahl der Ergebnisse (optional, default: 10)',
          offset: 'Offset f√ºr Paginierung (optional, default: 0)'
        }
      },
      'get_stammtisch_by_id': {
        description: 'Ruft einen spezifischen Stammtisch mit Details ab',
        parameters: {
          id: 'UUID des Stammtisches (erforderlich)'
        }
      },
      'search_stammtische': {
        description: 'Sucht nach Stammtischen basierend auf Suchbegriff',
        parameters: {
          query: 'Suchbegriff (erforderlich)',
          limit: 'Anzahl der Ergebnisse (optional, default: 10)'
        }
      },
      'get_praesentatoren': {
        description: 'Ruft alle Pr√§sentatoren ab',
        parameters: {
          limit: 'Anzahl der Ergebnisse (optional, default: 20)'
        }
      },
      'get_teilnehmer': {
        description: 'Ruft Teilnehmer f√ºr einen Stammtisch ab',
        parameters: {
          stammtischId: 'UUID des Stammtisches (erforderlich)'
        }
      },
      'get_stammtisch_statistics': {
        description: 'Ruft Statistiken √ºber alle Stammtische ab',
        parameters: {}
      },
      'get_upcoming_stammtische': {
        description: 'Ruft kommende Stammtische ab',
        parameters: {
          limit: 'Anzahl der Ergebnisse (optional, default: 5)'
        }
      }
    };
  }
}

module.exports = DatabaseTools;
</file>

<file path="utils/markdown-converter.js">
// srv/utils/markdown-converter.js
/**
 * Einfacher Markdown-zu-HTML Konverter f√ºr AI-Antworten
 * Speziell optimiert f√ºr SAP UI5 FormattedText Component
 */

class MarkdownConverter {
  
  /**
   * Konvertiert Markdown zu HTML f√ºr SAP UI5 FormattedText
   * @param {string} markdown - Markdown Text
   * @returns {string} HTML String
   */
  static convertToHTML(markdown) {
    if (!markdown || typeof markdown !== 'string') {
      return '';
    }

    let html = markdown;

    // 1. Code-Bl√∂cke (m√ºssen zuerst verarbeitet werden)
    html = this.convertCodeBlocks(html);

    // 2. Inline Code
    html = this.convertInlineCode(html);

    // 3. Headers (H1-H4)
    html = this.convertHeaders(html);

    // 4. Bold und Italic
    html = this.convertTextFormatting(html);

    // 5. Listen
    html = this.convertLists(html);

    // 6. Links (falls vorhanden)
    html = this.convertLinks(html);

    // 7. Emojis und Sonderzeichen beibehalten
    html = this.preserveEmojis(html);

    // 8. Zeilenumbr√ºche
    html = this.convertLineBreaks(html);

    // 9. SAP UI5 spezifische Optimierungen
    html = this.optimizeForSAPUI5(html);

    return html.trim();
  }

  /**
   * Konvertiert Code-Bl√∂cke
   */
  static convertCodeBlocks(text) {
    // ```language \n code \n ```
    return text.replace(/```(\w*)\n([\s\S]*?)\n```/g, (match, language, code) => {
      const cleanCode = this.escapeHTML(code.trim());
      return `<div class="ai-code-block">
        <div class="ai-code-header">${language || 'Code'}</div>
        <pre class="ai-code-content"><code>${cleanCode}</code></pre>
      </div>`;
    });
  }

  /**
   * Konvertiert Inline-Code
   */
  static convertInlineCode(text) {
    return text.replace(/`([^`]+)`/g, '<code class="ai-inline-code">$1</code>');
  }

  /**
   * Konvertiert Headers
   */
  static convertHeaders(text) {
    // ### Header 3
    text = text.replace(/^### (.+)$/gm, '<h3 class="ai-header-3">$1</h3>');
    // ## Header 2  
    text = text.replace(/^## (.+)$/gm, '<h2 class="ai-header-2">$1</h2>');
    // # Header 1
    text = text.replace(/^# (.+)$/gm, '<h1 class="ai-header-1">$1</h1>');
    
    return text;
  }

  /**
   * Konvertiert Bold und Italic
   */
  static convertTextFormatting(text) {
    // **Bold**
    text = text.replace(/\*\*([^*]+)\*\*/g, '<strong class="ai-bold">$1</strong>');
    // *Italic*
    text = text.replace(/\*([^*]+)\*/g, '<em class="ai-italic">$1</em>');
    
    return text;
  }

  /**
   * Konvertiert Listen
   */
  static convertLists(text) {
    // Unordered Lists
    text = text.replace(/^- (.+)$/gm, '<li class="ai-list-item">$1</li>');
    
    // Wrap consecutive list items in <ul>
    text = text.replace(/(<li class="ai-list-item">.*<\/li>\s*)+/gs, (match) => {
      return `<ul class="ai-unordered-list">${match}</ul>`;
    });

    // Numbered Lists (vereinfacht)
    text = text.replace(/^\d+\. (.+)$/gm, '<li class="ai-numbered-item">$1</li>');
    
    // Wrap consecutive numbered items in <ol>
    text = text.replace(/(<li class="ai-numbered-item">.*<\/li>\s*)+/gs, (match) => {
      return `<ol class="ai-ordered-list">${match}</ol>`;
    });

    return text;
  }

  /**
   * Konvertiert Links
   */
  static convertLinks(text) {
    // [Text](URL)
    return text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="#" class="ai-link" data-url="$2" title="$2">$1</a>');
  }

  /**
   * Beh√§lt Emojis bei
   */
  static preserveEmojis(text) {
    // Emojis sind bereits Unicode, keine Konvertierung n√∂tig
    return text;
  }

  /**
   * Konvertiert Zeilenumbr√ºche
   */
  static convertLineBreaks(text) {
    // Doppelte Zeilenumbr√ºche zu Paragraphen
    text = text.replace(/\n\n+/g, '</p><p class="ai-paragraph">');
    
    // Einzelne Zeilenumbr√ºche zu <br>
    text = text.replace(/\n/g, '<br/>');
    
    // Wrap in paragraph wenn nicht schon in anderen Tags
    if (!text.startsWith('<') && text.length > 0) {
      text = `<p class="ai-paragraph">${text}</p>`;
    }

    return text;
  }

  /**
   * SAP UI5 spezifische Optimierungen
   */
  static optimizeForSAPUI5(text) {
    // Bereinige leere Paragraphen
    text = text.replace(/<p class="ai-paragraph"><\/p>/g, '');
    
    // Stelle sicher, dass alle Tags geschlossen sind
    text = this.closeOpenTags(text);
    
    return text;
  }

  /**
   * HTML Escaping f√ºr Sicherheit
   */
  static escapeHTML(text) {
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    return text.replace(/[&<>"']/g, (m) => map[m]);
  }

  /**
   * Schlie√üt offene Tags (vereinfacht)
   */
  static closeOpenTags(html) {
    // Einfache Implementation - f√ºr Produktionsumgebung sollte ein richtiger HTML-Parser verwendet werden
    const openTags = [];
    const tagRegex = /<\/?([a-zA-Z][a-zA-Z0-9]*)[^>]*>/g;
    
    let match;
    while ((match = tagRegex.exec(html)) !== null) {
      if (match[0].startsWith('</')) {
        // Closing tag
        const tag = match[1].toLowerCase();
        const index = openTags.lastIndexOf(tag);
        if (index !== -1) {
          openTags.splice(index, 1);
        }
      } else if (!match[0].endsWith('/>')) {
        // Opening tag (not self-closing)
        openTags.push(match[1].toLowerCase());
      }
    }

    // Schlie√üe offene Tags
    for (let i = openTags.length - 1; i >= 0; i--) {
      html += `</${openTags[i]}>`;
    }

    return html;
  }

  /**
   * Spezielle Konvertierung f√ºr SAP-spezifische Inhalte
   */
  static convertSAPContent(text) {
    // SAP UI5 Komponenten-Namen hervorheben
    text = text.replace(/\b(List Report|Object Page|Draft|Value Help|Smart Filter Bar)\b/g, 
      '<span class="ai-sap-term">$1</span>');
    
    // Schritt-f√ºr-Schritt Anleitungen
    text = text.replace(/^\*\*Schritt (\d+)\*\*:?/gm, 
      '<div class="ai-step-header">üìã <strong>Schritt $1</strong></div>');
    
    return text;
  }

  /**
   * Hauptmethode f√ºr die Konvertierung mit SAP-spezifischen Verbesserungen
   */
  static convertForStammtischAI(markdown) {
    let html = this.convertToHTML(markdown);
    html = this.convertSAPContent(html);
    return html;
  }
}

export default MarkdownConverter;
</file>

</files>
